# 1 "rtl8651_tblDrv.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "rtl8651_tblDrv.c"
# 31 "rtl8651_tblDrv.c"
# 1 "rtl_types.h" 1
# 204 "rtl_types.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/config.h" 1



# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/autoconf.h" 1
# 5 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/config.h" 2
# 205 "rtl_types.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/ctype.h" 1
# 18 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/ctype.h"
extern unsigned char _ctype[];
# 37 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/ctype.h"
static inline unsigned char __tolower(unsigned char c)
{
        if ((((_ctype[(int)(unsigned char)(c)])&(0x01)) != 0))
                c -= 'A'-'a';
        return c;
}

static inline unsigned char __toupper(unsigned char c)
{
        if ((((_ctype[(int)(unsigned char)(c)])&(0x02)) != 0))
                c -= 'a'-'A';
        return c;
}
# 206 "rtl_types.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h" 1
# 11 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/spinlock.h" 1





# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h" 1
# 16 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/sgidefs.h" 1
# 17 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h" 2

# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h" 1
# 10 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h"
# 1 "/uclibc/toolchain_mips/lib/gcc-lib/mips-linux/3.2/include/stdarg.h" 1 3
# 43 "/uclibc/toolchain_mips/lib/gcc-lib/mips-linux/3.2/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 110 "/uclibc/toolchain_mips/lib/gcc-lib/mips-linux/3.2/include/stdarg.h" 3
typedef __gnuc_va_list va_list;
# 11 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/linkage.h" 1
# 12 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/stddef.h" 1
# 13 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/types.h" 1
# 15 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/types.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/posix_types.h" 1
# 36 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/posix_types.h"
typedef struct {
        unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);



typedef int __kernel_key_t;



# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/posix_types.h" 1
# 17 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/posix_types.h"
typedef unsigned int __kernel_dev_t;
typedef unsigned long __kernel_ino_t;
typedef unsigned int __kernel_mode_t;
typedef unsigned long __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef int __kernel_ipc_pid_t;
typedef int __kernel_uid_t;
typedef int __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef long __kernel_daddr_t;
typedef char * __kernel_caddr_t;

typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef int __kernel_uid32_t;
typedef int __kernel_gid32_t;
typedef __kernel_uid_t __kernel_old_uid_t;
typedef __kernel_gid_t __kernel_old_gid_t;


typedef long long __kernel_loff_t;


typedef struct {
        long val[2];
} __kernel_fsid_t;




static __inline__ void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
{
        unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
        unsigned long __rem = __fd % (8 * sizeof(unsigned long));
        __fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
}


static __inline__ void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
{
        unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
        unsigned long __rem = __fd % (8 * sizeof(unsigned long));
        __fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
}


static __inline__ int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__p)
{
        unsigned long __tmp = __fd / (8 * sizeof(unsigned long));
        unsigned long __rem = __fd % (8 * sizeof(unsigned long));
        return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
}






static __inline__ void __FD_ZERO(__kernel_fd_set *__p)
{
        unsigned long *__tmp = __p->fds_bits;
        int __i;

        if (__builtin_constant_p((1024/(8 * sizeof(unsigned long))))) {
                switch ((1024/(8 * sizeof(unsigned long)))) {
                case 16:
                        __tmp[ 0] = 0; __tmp[ 1] = 0;
                        __tmp[ 2] = 0; __tmp[ 3] = 0;
                        __tmp[ 4] = 0; __tmp[ 5] = 0;
                        __tmp[ 6] = 0; __tmp[ 7] = 0;
                        __tmp[ 8] = 0; __tmp[ 9] = 0;
                        __tmp[10] = 0; __tmp[11] = 0;
                        __tmp[12] = 0; __tmp[13] = 0;
                        __tmp[14] = 0; __tmp[15] = 0;
                        return;

                case 8:
                        __tmp[ 0] = 0; __tmp[ 1] = 0;
                        __tmp[ 2] = 0; __tmp[ 3] = 0;
                        __tmp[ 4] = 0; __tmp[ 5] = 0;
                        __tmp[ 6] = 0; __tmp[ 7] = 0;
                        return;

                case 4:
                        __tmp[ 0] = 0; __tmp[ 1] = 0;
                        __tmp[ 2] = 0; __tmp[ 3] = 0;
                        return;
                }
        }
        __i = (1024/(8 * sizeof(unsigned long)));
        while (__i) {
                __i--;
                *__tmp = 0;
                __tmp++;
        }
}
# 50 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/posix_types.h" 2
# 16 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/types.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/types.h" 1
# 14 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/types.h"
typedef unsigned short umode_t;






typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;
# 38 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/types.h"
typedef __signed__ long long __s64;
typedef unsigned long long __u64;
# 49 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/types.h"
typedef __signed char s8;
typedef unsigned char u8;

typedef __signed short s16;
typedef unsigned short u16;

typedef __signed int s32;
typedef unsigned int u32;
# 66 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/types.h"
typedef __signed__ long long s64;
typedef unsigned long long u64;
# 77 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/types.h"
typedef u32 dma_addr_t;

typedef u64 dma64_addr_t;




typedef unsigned long phys_t;
# 17 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/types.h" 2



typedef __kernel_fd_set fd_set;
typedef __kernel_dev_t dev_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;
typedef __kernel_off_t off_t;
typedef __kernel_pid_t pid_t;
typedef __kernel_daddr_t daddr_t;
typedef __kernel_key_t key_t;
typedef __kernel_suseconds_t suseconds_t;


typedef __kernel_uid32_t uid_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_uid16_t uid16_t;
typedef __kernel_gid16_t gid16_t;
# 52 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/types.h"
typedef __kernel_loff_t loff_t;
# 61 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/types.h"
typedef __kernel_size_t size_t;




typedef __kernel_ssize_t ssize_t;




typedef __kernel_ptrdiff_t ptrdiff_t;




typedef __kernel_time_t time_t;




typedef __kernel_clock_t clock_t;




typedef __kernel_caddr_t caddr_t;



typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;


typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;




typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;



typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;


typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
# 130 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/types.h"
struct ustat {
        __kernel_daddr_t f_tfree;
        __kernel_ino_t f_tinode;
        char f_fname[6];
        char f_fpack[6];
};
# 14 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/compiler.h" 1
# 15 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/byteorder.h" 1
# 23 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/byteorder.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/big_endian.h" 1
# 11 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/big_endian.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/swab.h" 1
# 159 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/swab.h"
static __inline__ __const__ __u16 __fswab16(__u16 x)
{
        return ({ __u16 __tmp = (x) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); });
}
static __inline__ __u16 __swab16p(__u16 *x)
{
        return ({ __u16 __tmp = (*(x)) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); });
}
static __inline__ void __swab16s(__u16 *addr)
{
        do { *(addr) = ({ __u16 __tmp = (*((addr))) ; ({ __u16 __x = (__tmp); ((__u16)( (((__u16)(__x) & (__u16)0x00ffU) << 8) | (((__u16)(__x) & (__u16)0xff00U) >> 8) )); }); }); } while (0);
}

static __inline__ __const__ __u32 __fswab24(__u32 x)
{
        return ({ __u32 __tmp = (x) ; ({ __u32 __x = (__tmp); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL) | ((__x & (__u32)0x00ff0000UL) >> 16) )); }); });
}
static __inline__ __u32 __swab24p(__u32 *x)
{
        return ({ __u32 __tmp = (*(x)) ; ({ __u32 __x = (__tmp); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL) | ((__x & (__u32)0x00ff0000UL) >> 16) )); }); });
}
static __inline__ void __swab24s(__u32 *addr)
{
        do { *(addr) = ({ __u32 __tmp = (*((addr))) ; ({ __u32 __x = (__tmp); ((__u32)( ((__x & (__u32)0x000000ffUL) << 16) | (__x & (__u32)0x0000ff00UL) | ((__x & (__u32)0x00ff0000UL) >> 16) )); }); }); } while (0);
}

static __inline__ __const__ __u32 __fswab32(__u32 x)
{
        return ({ __u32 __tmp = (x) ; ({ __u32 __x = (__tmp); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }); });
}
static __inline__ __u32 __swab32p(__u32 *x)
{
        return ({ __u32 __tmp = (*(x)) ; ({ __u32 __x = (__tmp); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }); });
}
static __inline__ void __swab32s(__u32 *addr)
{
        do { *(addr) = ({ __u32 __tmp = (*((addr))) ; ({ __u32 __x = (__tmp); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }); }); } while (0);
}


static __inline__ __const__ __u64 __fswab64(__u64 x)
{

        __u32 h = x >> 32;
        __u32 l = x & ((1ULL<<32)-1);
        return (((__u64)(__builtin_constant_p((__u32)(l)) ? ({ __u32 __x = ((l)); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }) : __fswab32((l)))) << 32) | ((__u64)((__builtin_constant_p((__u32)(h)) ? ({ __u32 __x = ((h)); ((__u32)( (((__u32)(__x) & (__u32)0x000000ffUL) << 24) | (((__u32)(__x) & (__u32)0x0000ff00UL) << 8) | (((__u32)(__x) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(__x) & (__u32)0xff000000UL) >> 24) )); }) : __fswab32((h)))));



}
static __inline__ __u64 __swab64p(__u64 *x)
{
        return ({ __u64 __tmp = (*(x)) ; ({ __u64 __x = (__tmp); ((__u64)( (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) << 8) | (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >> 8) | (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); }); });
}
static __inline__ void __swab64s(__u64 *addr)
{
        do { *(addr) = ({ __u64 __tmp = (*((addr))) ; ({ __u64 __x = (__tmp); ((__u64)( (__u64)(((__u64)(__x) & (__u64)0x00000000000000ffULL) << 56) | (__u64)(((__u64)(__x) & (__u64)0x000000000000ff00ULL) << 40) | (__u64)(((__u64)(__x) & (__u64)0x0000000000ff0000ULL) << 24) | (__u64)(((__u64)(__x) & (__u64)0x00000000ff000000ULL) << 8) | (__u64)(((__u64)(__x) & (__u64)0x000000ff00000000ULL) >> 8) | (__u64)(((__u64)(__x) & (__u64)0x0000ff0000000000ULL) >> 24) | (__u64)(((__u64)(__x) & (__u64)0x00ff000000000000ULL) >> 40) | (__u64)(((__u64)(__x) & (__u64)0xff00000000000000ULL) >> 56) )); }); }); } while (0);
}
# 12 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/big_endian.h" 2
# 82 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/big_endian.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/generic.h" 1
# 149 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/generic.h"
extern __u32 ntohl(__u32);
extern __u32 htonl(__u32);
extern unsigned short int ntohs(unsigned short int);
extern unsigned short int htons(unsigned short int);
# 83 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/byteorder/big_endian.h" 2
# 24 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/byteorder.h" 2
# 16 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h" 2
# 41 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h"
extern int console_printk[];
# 58 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h"
struct completion;

extern struct notifier_block *panic_notifier_list;
 void panic(const char * fmt, ...)
        __attribute__ ((noreturn, format (printf, 1, 2)));
 void do_exit(long error_code)
        __attribute__((noreturn));
 void complete_and_exit(struct completion *, long)
        __attribute__((noreturn));
extern int abs(int);
extern unsigned long simple_strtoul(const char *,char **,unsigned int);
extern long simple_strtol(const char *,char **,unsigned int);
extern unsigned long long simple_strtoull(const char *,char **,unsigned int);
extern long long simple_strtoll(const char *,char **,unsigned int);
extern int sprintf(char * buf, const char * fmt, ...)
        __attribute__ ((format (printf, 2, 3)));
extern int vsprintf(char *buf, const char *, va_list);
extern int snprintf(char * buf, size_t size, const char * fmt, ...)
        __attribute__ ((format (printf, 3, 4)));
extern int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);

extern int sscanf(const char *, const char *, ...)
        __attribute__ ((format (scanf,2,3)));
extern int vsscanf(const char *, const char *, va_list);

extern int get_option(char **str, int *pint);
extern char *get_options(char *str, int nints, int *ints);
extern unsigned long long memparse(char *ptr, char **retptr);
extern void dev_probe_lock(void);
extern void dev_probe_unlock(void);

extern int session_of_pgrp(int pgrp);

 int printk(const char * fmt, ...)
        __attribute__ ((format (printf, 1, 2)));

static inline void console_silent(void)
{
        (console_printk[0]) = 0;
}

static inline void console_verbose(void)
{
        if ((console_printk[0]))
                (console_printk[0]) = 15;
}

extern void bust_spinlocks(int yes);
extern int oops_in_progress;

extern int tainted;
extern const char *print_tainted(void);

extern void dump_stack(void);
# 174 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/kernel.h"
extern void __out_of_line_bug(int line) __attribute__((noreturn));





struct sysinfo {
        long uptime;
        unsigned long loads[3];
        unsigned long totalram;
        unsigned long freeram;
        unsigned long sharedram;
        unsigned long bufferram;
        unsigned long totalswap;
        unsigned long freeswap;
        unsigned short procs;
        unsigned short pad;
        unsigned long totalhigh;
        unsigned long freehigh;
        unsigned int mem_unit;
        char _f[20-2*sizeof(long)-sizeof(int)];
};
# 19 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h" 2

# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/addrspace.h" 1
# 21 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/ptrace.h" 1
# 14 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/ptrace.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/isadep.h" 1
# 15 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/ptrace.h" 2
# 31 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/ptrace.h"
struct pt_regs {

        unsigned long pad0[6];


        unsigned long regs[32];


        unsigned long cp0_status;
        unsigned long lo;
        unsigned long hi;
        unsigned long cp0_badvaddr;
        unsigned long cp0_cause;
        unsigned long cp0_epc;
};
# 102 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/ptrace.h"
extern void show_regs(struct pt_regs *);
# 22 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h" 2

__asm__ (
        ".macro\t__sti\n\t"
        ".set\tpush\n\t"
        ".set\treorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t$1,$12\n\t"
        "ori\t$1,0x1f\n\t"
        "xori\t$1,0x1e\n\t"
        "mtc0\t$1,$12\n\t"
        ".set\tpop\n\t"
        ".endm");

static __inline__ void
__sti(void)
{
        __asm__ __volatile__(
                "__sti"
                :
                :
                : "memory");
}
# 52 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h"
__asm__ (
        ".macro\t__cli\n\t"
        ".set\tpush\n\t"
        ".set\tnoat\n\t"
        "mfc0\t$1,$12\n\t"
        "ori\t$1,1\n\t"
        "xori\t$1,1\n\t"
        ".set\tnoreorder\n\t"
        "mtc0\t$1,$12\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        ".set\tpop\n\t"
        ".endm");

static __inline__ void
__cli(void)
{
        __asm__ __volatile__(
                "__cli"
                :
                :
                : "memory");
}

__asm__ (
        ".macro\t__save_flags flags\n\t"
        ".set\tpush\n\t"
        ".set\treorder\n\t"
        "mfc0\t\\flags, $12\n\t"
        ".set\tpop\n\t"
        ".endm");






__asm__ (
        ".macro\t__save_and_cli result\n\t"
        ".set\tpush\n\t"
        ".set\treorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t\\result, $12\n\t"
        "ori\t$1, \\result, 1\n\t"
        "xori\t$1, 1\n\t"
        ".set\tnoreorder\n\t"
        "mtc0\t$1, $12\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        ".set\tpop\n\t"
        ".endm");
# 113 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h"
__asm__ (
        ".macro\t__save_and_sti result\n\t"
        ".set\tpush\n\t"
        ".set\treorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t\\result, $12\n\t"
        "ori\t$1, \\result, 1\n\t"
        ".set\tnoreorder\n\t"
        "mtc0\t$1, $12\n\t"
        ".set\tpop\n\t"
        ".endm");
# 132 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h"
__asm__(".macro\t__restore_flags flags\n\t"
        ".set\tnoreorder\n\t"
        ".set\tnoat\n\t"
        "mfc0\t$1, $12\n\t"
        "andi\t\\flags, 1\n\t"
        "ori\t$1, 1\n\t"
        "xori\t$1, 1\n\t"
        "or\t\\flags, $1\n\t"
        "mtc0\t\\flags, $12\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        "sll\t$0, $0, 1\t\t\t# nop\n\t"
        ".set\tat\n\t"
        ".set\treorder\n\t"
        ".endm");
# 263 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h"
extern void *resume(void *last, void *next);



struct task_struct;
# 278 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h"
static __inline__ unsigned long xchg_u32(volatile int * m, unsigned long val)
{
# 300 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/system.h"
        unsigned long flags, retval;

        __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory");
        retval = *m;
        *m = val;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
        return retval;

}




static __inline__ unsigned long
__xchg(unsigned long x, volatile void * ptr, int size)
{
        switch (size) {
                case 4:
                        return xchg_u32(ptr, x);
        }
        return x;
}

extern void *set_except_vector(int n, void *addr);
extern void per_cpu_trap_init(void);

extern void __die(const char *, struct pt_regs *, const char *file,
        const char *func, unsigned long line) __attribute__((noreturn));
extern void __die_if_kernel(const char *, struct pt_regs *, const char *file,
        const char *func, unsigned long line);
# 7 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/spinlock.h" 2
# 42 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/spinlock.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/stringify.h" 1
# 43 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/spinlock.h" 2
# 77 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/spinlock.h"
  typedef struct { } spinlock_t;
# 141 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/spinlock.h"
  typedef struct { } rwlock_t;
# 172 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/spinlock.h"
typedef struct {
    spinlock_t lock;
} spinlock_cacheline_t;
# 12 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h" 1





# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/prefetch.h" 1
# 13 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/prefetch.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 1
# 15 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/cache.h" 1




# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/cache.h" 1
# 6 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/cache.h" 2
# 16 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/isadep.h" 1
# 17 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2







# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/smp.h" 1
# 25 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/threads.h" 1
# 26 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2

# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/cachectl.h" 1
# 28 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/cpu.h" 1
# 29 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/mipsregs.h" 1
# 18 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/mipsregs.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/hazards.h" 1
# 19 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/mipsregs.h" 2
# 839 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/mipsregs.h"
static inline void tlb_probe(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbp\n\t"
                ".set reorder");
        do { } while (0);
}

static inline void tlb_read(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbr\n\t"
                ".set reorder");
        do { } while (0);
}

static inline void tlb_write_indexed(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbwi\n\t"
                ".set reorder");
        do { } while (0);
}

static inline void tlb_write_random(void)
{
        do { } while (0);
        __asm__ __volatile__(
                ".set noreorder\n\t"
                "tlbwr\n\t"
                ".set reorder");
        do { } while (0);
}
# 920 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/mipsregs.h"
static inline unsigned int set_c0_status(unsigned int set) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$12" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$12" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res |= set; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$12" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$12" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static inline unsigned int clear_c0_status(unsigned int clear) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$12" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$12" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~clear; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$12" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$12" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static inline unsigned int change_c0_status(unsigned int change, unsigned int new) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$12" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$12" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~change; res |= (new & change); do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$12" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$12" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; }
static inline unsigned int set_c0_cause(unsigned int set) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$13" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$13" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res |= set; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$13" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$13" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static inline unsigned int clear_c0_cause(unsigned int clear) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$13" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$13" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~clear; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$13" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$13" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static inline unsigned int change_c0_cause(unsigned int change, unsigned int new) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$13" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$13" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~change; res |= (new & change); do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$13" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$13" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; }
static inline unsigned int set_c0_config(unsigned int set) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$16" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$16" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res |= set; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$16" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$16" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static inline unsigned int clear_c0_config(unsigned int clear) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$16" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$16" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~clear; do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$16" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$16" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; } static inline unsigned int change_c0_config(unsigned int change, unsigned int new) { unsigned int res; res = ({ int __res; if (0 == 0) __asm__ __volatile__( "mfc0\t%0, " "$16" "\n\t" : "=r" (__res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mfc0\t%0, " "$16" ", " "0" "\n\t" ".set\tmips0\n\t" : "=r" (__res)); __res; }); res &= ~change; res |= (new & change); do { if (0 == 0) __asm__ __volatile__( "mtc0\t%z0, " "$16" "\n\t" : : "Jr" (res)); else __asm__ __volatile__( ".set\tmips32\n\t" "mtc0\t%z0, " "$16" ", " "0" "\n\t" ".set\tmips0" : : "Jr" (res)); } while (0); return res; }
# 30 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/reg.h" 1
# 31 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h" 2





struct cache_desc {
        unsigned short linesz;
        unsigned short ways;
        unsigned short sets;
        unsigned int waysize;
        unsigned int waybit;
        unsigned int flags;
};
# 53 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h"
struct cpuinfo_mips {
        unsigned long udelay_val;
        unsigned long *pgd_quick;
        unsigned long *pte_quick;
        unsigned long pgtable_cache_sz;
        unsigned long asid_cache;



        unsigned long options;
        unsigned int processor_id;
        unsigned int fpu_id;
        unsigned int cputype;
        int isa_level;
        int tlbsize;
        struct cache_desc icache;
        struct cache_desc dcache;
        struct cache_desc scache;
        struct cache_desc tcache;
} __attribute__((aligned(16)));
# 106 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h"
extern struct cpuinfo_mips cpu_data[];


extern void cpu_probe(void);
extern void cpu_report(void);




extern void (*cpu_wait)(void);

extern unsigned int vced_count, vcei_count;
# 151 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h"
struct mips_fpu_hard_struct {
        double fp_regs[32];
        unsigned int control;
};







typedef u64 fpureg_t;
struct mips_fpu_soft_struct {
        fpureg_t regs[32];
        unsigned int sr;
};

union mips_fpu_union {
        struct mips_fpu_hard_struct hard;
        struct mips_fpu_soft_struct soft;
};





typedef struct {
        unsigned long seg;
} mm_segment_t;




struct thread_struct {

        unsigned long reg16;
        unsigned long reg17, reg18, reg19, reg20, reg21, reg22, reg23;
        unsigned long reg29, reg30, reg31;


        unsigned long cp0_status;


        union mips_fpu_union fpu;


        unsigned long cp0_badvaddr;
        unsigned long cp0_baduaddr;
        unsigned long error_code;
        unsigned long trap_no;


        unsigned long mflags;
        mm_segment_t current_ds;
        unsigned long irix_trampoline;
        unsigned long irix_oldctx;
};
# 244 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/processor.h"
extern int arch_kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);





struct mips_frame_info {
        int frame_offset;
        int pc_offset;
};
extern struct mips_frame_info schedule_frame;



static inline unsigned long thread_saved_pc(struct thread_struct *t)
{
        extern void ret_from_fork(void);


        if (t->reg31 == (unsigned long) ret_from_fork)
                return t->reg31;

        if (schedule_frame.pc_offset < 0)
                return 0;
        return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
}




extern void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp);

struct task_struct;
unsigned long get_wchan(struct task_struct *p);
# 14 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/prefetch.h" 2
# 43 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/prefetch.h"
static inline void prefetch(const void *x) {;}




static inline void prefetchw(const void *x) {;}
# 7 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h" 2
# 18 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h"
struct list_head {
        struct list_head *next, *prev;
};
# 37 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h"
static inline void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
        next->prev = new;
        new->next = next;
        new->prev = prev;
        prev->next = new;
}
# 55 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h"
static inline void list_add(struct list_head *new, struct list_head *head)
{
        __list_add(new, head, head->next);
}
# 68 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h"
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
        __list_add(new, head->prev, head);
}
# 80 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h"
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
        next->prev = prev;
        prev->next = next;
}






static inline void list_del(struct list_head *entry)
{
        __list_del(entry->prev, entry->next);
        entry->next = (void *) 0;
        entry->prev = (void *) 0;
}





static inline void list_del_init(struct list_head *entry)
{
        __list_del(entry->prev, entry->next);
        do { (entry)->next = (entry); (entry)->prev = (entry); } while (0);
}






static inline void list_move(struct list_head *list, struct list_head *head)
{
        __list_del(list->prev, list->next);
        list_add(list, head);
}






static inline void list_move_tail(struct list_head *list,
                                  struct list_head *head)
{
        __list_del(list->prev, list->next);
        list_add_tail(list, head);
}





static inline int list_empty(struct list_head *head)
{
        return head->next == head;
}

static inline void __list_splice(struct list_head *list,
                                 struct list_head *head)
{
        struct list_head *first = list->next;
        struct list_head *last = list->prev;
        struct list_head *at = head->next;

        first->prev = head;
        head->next = first;

        last->next = at;
        at->prev = last;
}






static inline void list_splice(struct list_head *list, struct list_head *head)
{
        if (!list_empty(list))
                __list_splice(list, head);
}
# 172 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/list.h"
static inline void list_splice_init(struct list_head *list,
                                    struct list_head *head)
{
        if (!list_empty(list)) {
                __list_splice(list, head);
                do { (list)->next = (list); (list)->prev = (list); } while (0);
        }
}
# 13 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h" 2
# 25 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/atomic.h" 1
# 19 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/atomic.h"
typedef struct { volatile int counter; } atomic_t;
# 58 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/atomic.h"
static __inline__ void atomic_add(int i, atomic_t * v)
{
        unsigned long flags;

        __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory");
        v->counter += i;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}
# 75 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/atomic.h"
static __inline__ void atomic_sub(int i, atomic_t * v)
{
        unsigned long flags;

        __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory");
        v->counter -= i;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);
}

static __inline__ int atomic_add_return(int i, atomic_t * v)
{
        unsigned long flags;
        int temp;

        __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory");
        temp = v->counter;
        temp += i;
        v->counter = temp;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);

        return temp;
}

static __inline__ int atomic_sub_return(int i, atomic_t * v)
{
        unsigned long flags;
        int temp;

        __asm__ __volatile__( "__save_and_cli\t%0" : "=r" (flags) : : "memory");
        temp = v->counter;
        temp -= i;
        v->counter = temp;
        do { unsigned long __tmp1; __asm__ __volatile__( "__restore_flags\t%0" : "=r" (__tmp1) : "0" (flags) : "memory"); } while(0);

        return temp;
}
# 26 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h" 2


struct exception_table_entry;


struct kernel_sym
{
        unsigned long value;
        char name[60];
};

struct module_symbol
{
        unsigned long value;
        const char *name;
};

struct module_ref
{
        struct module *dep;
        struct module *ref;
        struct module_ref *next_ref;
};


struct module_persist;

struct module
{
        unsigned long size_of_struct;
        struct module *next;
        const char *name;
        unsigned long size;

        union
        {
                atomic_t usecount;
                long pad;
        } uc;

        unsigned long flags;

        unsigned nsyms;
        unsigned ndeps;

        struct module_symbol *syms;
        struct module_ref *deps;
        struct module_ref *refs;
        int (*init)(void);
        void (*cleanup)(void);
        const struct exception_table_entry *ex_table_start;
        const struct exception_table_entry *ex_table_end;






        const struct module_persist *persist_start;
        const struct module_persist *persist_end;
        int (*can_unload)(void);
        int runsize;
        const char *kallsyms_start;
        const char *kallsyms_end;
        const char *archdata_start;
        const char *archdata_end;
        const char *kernel_data;
};

struct module_info
{
        unsigned long addr;
        unsigned long size;
        unsigned long flags;
        long usecount;
};
# 183 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h"
extern void inter_module_register(const char *, struct module *, const void *);
extern void inter_module_unregister(const char *);
extern const void *inter_module_get(const char *);
extern const void *inter_module_get_request(const char *, const char *);
extern void inter_module_put(const char *);

struct inter_module_entry {
        struct list_head list;
        const char *im_name;
        struct module *owner;
        const void *userdata;
};

extern int try_inc_mod_count(struct module *mod);
# 331 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/module.h"
extern struct module *module_list;
# 207 "rtl_types.h" 2
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/string.h" 1
# 19 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/string.h"
# 1 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/string.h" 1
# 15 "../../../../../../uClinux-dist/linux-2.4.x/include/asm/string.h"
static __inline__ char *strcpy(char *__dest, __const__ char *__src)
{
  char *__xdest = __dest;

  __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n"
        "1:\tlbu\t$1,(%1)\n\t"
        "addiu\t%1,1\n\t"
        "sb\t$1,(%0)\n\t"
        "bnez\t$1,1b\n\t"
        "addiu\t%0,1\n\t"
        ".set\tat\n\t"
        ".set\treorder"
        : "=r" (__dest), "=r" (__src)
        : "0" (__dest), "1" (__src)
        : "memory");

  return __xdest;
}


static __inline__ char *strncpy(char *__dest, __const__ char *__src, size_t __n)
{
  char *__xdest = __dest;

  if (__n == 0)
    return __xdest;

  __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n"
        "1:\tlbu\t$1,(%1)\n\t"
        "subu\t%2,1\n\t"
        "sb\t$1,(%0)\n\t"
        "beqz\t$1,2f\n\t"
        "addiu\t%0,1\n\t"
        "bnez\t%2,1b\n\t"
        "addiu\t%1,1\n"
        "2:\n\t"
        ".set\tat\n\t"
        ".set\treorder"
        : "=r" (__dest), "=r" (__src), "=r" (__n)
        : "0" (__dest), "1" (__src), "2" (__n)
        : "memory");

  return __xdest;
}


static __inline__ int strcmp(__const__ char *__cs, __const__ char *__ct)
{
  int __res;

  __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n\t"
        "lbu\t%2,(%0)\n"
        "1:\tlbu\t$1,(%1)\n\t"
        "addiu\t%0,1\n\t"
        "bne\t$1,%2,2f\n\t"
        "addiu\t%1,1\n\t"
        "bnez\t%2,1b\n\t"
        "lbu\t%2,(%0)\n\t"

        "nop\n\t"

        "move\t%2,$1\n"
        "2:\tsubu\t%2,$1\n"
        "3:\t.set\tat\n\t"
        ".set\treorder"
        : "=r" (__cs), "=r" (__ct), "=r" (__res)
        : "0" (__cs), "1" (__ct));

  return __res;
}


static __inline__ int
strncmp(__const__ char *__cs, __const__ char *__ct, size_t __count)
{
        int __res;

        __asm__ __volatile__(
        ".set\tnoreorder\n\t"
        ".set\tnoat\n"
        "1:\tlbu\t%3,(%0)\n\t"
        "beqz\t%2,2f\n\t"
        "lbu\t$1,(%1)\n\t"
        "subu\t%2,1\n\t"
        "bne\t$1,%3,3f\n\t"
        "addiu\t%0,1\n\t"
        "bnez\t%3,1b\n\t"
        "addiu\t%1,1\n"
        "2:\n\t"

        "nop\n\t"

        "move\t%3,$1\n"
        "3:\tsubu\t%3,$1\n\t"
        ".set\tat\n\t"
        ".set\treorder"
        : "=r" (__cs), "=r" (__ct), "=r" (__count), "=r" (__res)
        : "0" (__cs), "1" (__ct), "2" (__count));

        return __res;
}


extern void *memset(void *__s, int __c, size_t __count);


extern void *memcpy(void *__to, __const__ void *__from, size_t __n);


extern void *memmove(void *__dest, __const__ void *__src, size_t __n);





static __inline__ void *memscan(void *__addr, int __c, size_t __size)
{
        char *__end = (char *)__addr + __size;
        unsigned char __uc = (unsigned char) __c;

        __asm__(".set\tpush\n\t"
                ".set\tnoat\n\t"
                ".set\treorder\n\t"
                "1:\tbeq\t%0,%1,2f\n\t"
                "addiu\t%0,1\n\t"
                "lbu\t$1,-1(%0)\n\t"
                "bne\t$1,%z4,1b\n"
                "2:\t.set\tpop"
                : "=r" (__addr), "=r" (__end)
                : "0" (__addr), "1" (__end), "Jr" (__uc));

        return __addr;
}
# 20 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/string.h" 2


extern char * ___strtok;
extern char * strpbrk(const char *,const char *);
extern char * strtok(char *,const char *);
extern char * strsep(char **,const char *);
extern __kernel_size_t strspn(const char *,const char *);
# 36 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/string.h"
extern char * strcat(char *, const char *);


extern char * strncat(char *, const char *, __kernel_size_t);
# 48 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/string.h"
extern int strnicmp(const char *, const char *, __kernel_size_t);


extern char * strchr(const char *,int);


extern char * strrchr(const char *,int);


extern char * strstr(const char *,const char *);


extern __kernel_size_t strlen(const char *);


extern __kernel_size_t strnlen(const char *,__kernel_size_t);
# 79 "../../../../../../uClinux-dist/linux-2.4.x/include/linux/string.h"
extern int memcmp(const void *,const void *,__kernel_size_t);


extern void * memchr(const void *,int,__kernel_size_t);
# 208 "rtl_types.h" 2
# 309 "rtl_types.h"
typedef unsigned long long uint64;
typedef long long int64;
typedef unsigned int uint32;
typedef int int32;
typedef unsigned short uint16;
typedef short int16;
typedef unsigned char uint8;
typedef char int8;


typedef uint32 memaddr;
typedef uint32 ipaddr_t;
typedef struct {
    uint16 mac47_32;
    uint16 mac31_16;
    uint16 mac15_0;
} macaddr_t;


typedef struct ether_addr_s {
        uint8 octet[6];
} ether_addr_t;
# 32 "rtl8651_tblDrv.c" 2
# 1 "assert.h" 1
# 33 "rtl8651_tblDrv.c" 2
# 1 "rtl8651_layer2.h" 1
# 82 "rtl8651_layer2.h"
extern uint32 rtl8651_tblDrvCpuMirrorPortMask;
extern int32 rtl8651_totalExtPortNum;
extern int32 rtl8651_allExtPortMask;
extern int32 rtl8651_bridgeEnable;



extern uint32 fake_DisableFlowControl[];
extern uint32 prePortState[];




int32 rtl8651_installPortStatusChangeNotifier(void (*notifier)(uint32 port, int8 linkUp));
int32 rtl8651_getEthernetPortLinkStatus(uint32 port, int8 * linkUp, uint16 *speed, int8 *fullduplex, int8 *autoNeg);
int32 rtl8651_setEthernetPortDuplexMode(uint32 port, int8 fullDuplex);
int32 rtl8651_setEthernetPortSpeed(uint32 port, uint32 speed);
int32 rtl8651_setEthernetPortAutoNegotiation(uint32 port, int8 autoNegotiation, uint32 advCapability);
int32 rtl8651_setEthernetPortBandwidthControl(uint32 port, int8 input, uint32 rate);




int32 rtl8651_addSpanningTreeInstance(uint16 sid);
int32 rtl8651_setSpanningTreeInstanceProtocolWorking(uint16 sid, int8 working);
int32 rtl8651_delSpanningTreeInstance(uint16 sid);
int32 rtl8651_setSpanningTreeInstancePortState(uint16 stid, uint16 port, uint8 portState);


int32 rtl8651_addFilterDatabase(uint16 fid);
int32 rtl8651_delFilterDatabase(uint16 fid);
int32 rtl8651_specifyFilterDatabaseSpanningTreeInstance(uint16 fid, uint16 sid);
int32 rtl8651_addFilterDatabaseEntry(uint16 fid, ether_addr_t * macAddr, uint32 type, uint32 portMask);
int32 rtl8651_delFilterDatabaseEntry(uint16 fid, ether_addr_t * macAddr);
int32 rtl8651_installFDBEntryChangeNotifier( void (*notify)(void *l2entry_t,void *arg));





int32 rtl8651_setAggregatorIndividual(uint16 aggregator, int8 individual);
int32 rtl8651_setPortAggregator(uint32 port, uint16 aggregator);
int32 rtl8651_getAggregatorActiveStatus(uint16 aggregator, int8 * isActive);
int32 rtl8651_setPvid(uint32 aggregator, uint16 vid);



int32 rtl8651_addVlan(uint16 vid);

int32 rtl8651_delVlan(uint16 vid);

int32 rtl8651_allocateVlanMacAddress(uint16 vid, uint16 macAddrNumber);
int32 rtl8651_getVlanMacAddress(uint16 vid, ether_addr_t * macAddr, uint16 * macAddrNumber);

int32 rtl8651_assignVlanMacAddress(uint16 vid, ether_addr_t * macAddress, uint16 macAddrNumber);
int32 rtl8651_delVlanPortMember(uint16 vid, uint32 port);
int32 rtl8651_addVlanPortMember(uint16 vid, uint32 port);
int32 rtl8651_specifyVlanFilterDatabase(uint16 vid, uint16 fid);


int32 rtl8651_setVlanPromiscuous(uint16 vid, int8 isPromiscuous);
int32 rtl8651_setVlanFwdTxMirror(uint16 vid, int8 isFwdTxMirror);
int32 rtl8651_getVlanActiveStatus(uint16 vid, int8 * isActive);
int32 rtl8651_setVlanPortUntag(uint16 vid, uint32 port, int8 untag);



int32 rtl8651_pureSoftwareFwd(int8 isSoftFwd);

int32 rtl8651_addProtoTrap(uint8 protoType, uint16 protoContent);
int32 rtl8651_delProtoTrap(uint8 protoType, uint16 protoContent);

int32 rtl8651_enableBroadCastStormPrevention(int8 enable);
struct rtl_pktHdr;
struct rtl_mBuf;
void rtl8651_installArpAgent(int32 (*arpAgent)(struct rtl_pktHdr *pkthdrPtr,struct rtl_mBuf *mbufPtr,uint16 vid));

int32 rtl8651_resetRxTxMirror(void);
int32 rtl8651_addRxTxMirror(int8 isRxMirror, uint32 port);
int32 rtl8651_addMirrorPort(uint32 port);
int32 rtl8651_delMirrorPort(uint32 port);

extern uint32 rtl8651_l2protoPassThrough;





extern int8 rtl8651_drvDropUnknownPppoePADT;
extern struct ether_header rtl8651_knownPppoePassthruEthHdr;
# 34 "rtl8651_tblDrv.c" 2
# 1 "rtl8651_tblDrv.h" 1
# 15 "rtl8651_tblDrv.h"
# 1 "types.h" 1
# 16 "rtl8651_tblDrv.h" 2


# 1 "rtl_errno.h" 1
# 19 "rtl8651_tblDrv.h" 2

# 1 "rtl8651_tblDrvProto.h" 1
# 21 "rtl8651_tblDrvProto.h"
struct ether_header {
        uint8 ether_dhost[6];
        uint8 ether_shost[6];
        uint16 ether_type;
};
# 36 "rtl8651_tblDrvProto.h"
struct ether_addr {
        uint8 octet[6];
};


typedef struct pppoeHdr_s {



        uint8 ver:4, type:4;

        uint8 code;
        uint16 sessionId,
                        length;
        uint16 proto;
} pppoeHdr_t;





struct in_addr{
        uint32 s_addr;
};







struct ip {
# 90 "rtl8651_tblDrvProto.h"
        uint8 ip_vhl;


        uint8 ip_tos;
        uint16 ip_len;
        uint16 ip_id;
        uint16 ip_off;
        uint8 ip_ttl;
        uint8 ip_p;
        uint16 ip_sum;
        struct in_addr ip_src,ip_dst;
};
typedef struct ip ip_t;
# 114 "rtl8651_tblDrvProto.h"
struct icmp_ra_addr {
        uint32 ira_addr;
        uint32 ira_preference;
};

struct icmp {
        uint8 icmp_type;
        uint8 icmp_code;
        uint16 icmp_cksum;
        union {
                uint8 ih_pptr;
                struct in_addr ih_gwaddr;
                struct ih_idseq {
                        uint16 icd_id;
                        uint16 icd_seq;
                } ih_idseq;
                uint32 ih_void;


                struct ih_pmtu {
                        uint16 ipm_void;
                        uint16 ipm_nextmtu;
                } ih_pmtu;

                struct ih_rtradv {
                        uint8 irt_num_addrs;
                        uint8 irt_wpa;
                        uint16 irt_lifetime;
                } ih_rtradv;
        } icmp_hun;
# 154 "rtl8651_tblDrvProto.h"
        union {
                struct id_ts {
                        uint32 its_otime;
                        uint32 its_rtime;
                        uint32 its_ttime;
                } id_ts;
                struct id_ip {
                        struct ip idi_ip;

                } id_ip;
                struct icmp_ra_addr id_radv;
                uint32 id_mask;
                int8 id_data[1];
        } icmp_dun;







};
# 228 "rtl8651_tblDrvProto.h"
struct igmp_gr {
        uint8 igmp_gr_rt;
        uint8 igmp_gr_auxlen;
        uint16 igmp_gr_nofs;
        ipaddr_t igmp_gr_group;
        ipaddr_t src_list;

 };
struct igmp {
        uint8 igmp_type;
        uint8 igmp_code;
        uint16 igmp_cksum;

        union {
                struct in_addr group;
                struct v3_report{
                        uint16 resv;
                        uint16 nofg;
                } v3_report;
        } grp;

        union {
                struct query {
                        uint8 rsq;



                        uint8 qqic;
                        uint16 nofs;
                        ipaddr_t src_list;
                } query;
                struct report {
                        struct igmp_gr gr_list;
                } report;
        } un_v3;
# 276 "rtl8651_tblDrvProto.h"
};
# 304 "rtl8651_tblDrvProto.h"
typedef uint32 tcp_seq;
struct tcphdr {
        uint16 th_sport;
        uint16 th_dport;
        tcp_seq th_seq;
        tcp_seq th_ack;
# 320 "rtl8651_tblDrvProto.h"
        uint8 th_off_x;



        uint8 th_flags;
# 335 "rtl8651_tblDrvProto.h"
        uint16 th_win;
        uint16 th_sum;
        uint16 th_urp;
# 362 "rtl8651_tblDrvProto.h"
};





struct udphdr
{
        uint16 uh_sport;
        uint16 uh_dport;
        uint16 uh_ulen;
        uint16 uh_sum;
};





struct tftpRequest {
        uint16 opcode;
        char *string;
};
# 394 "rtl8651_tblDrvProto.h"
typedef struct espHdr_s
{
        uint32 spi;
        uint32 seq;
} espHdr_t;

typedef struct cbcHdr64_s
{
        uint32 iv[2];
} cbcHdr64_t;

typedef struct cbcHdr128_s
{
        uint32 iv[4];
} cbcHdr128_t;
# 21 "rtl8651_tblDrv.h" 2
# 1 "mbuf.h" 1
# 30 "mbuf.h"
struct rtl_mBuf
{



        struct rtl_mBuf *m_next;

        struct rtl_pktHdr *m_pkthdr;

        uint16 m_len;
        int8 m_flags;





        int8 m_unused1;

        uint8 *m_data;



        uint8 *m_extbuf;
        uint32 m_extClusterId;
        void *m_unused2;
        uint16 m_extsize;

        uint8 m_reserved[2];
};


struct ifnet;




struct rtl_pktHdr
{




        union
        {
                struct rtl_pktHdr *pkthdr_next;
                struct rtl_mBuf *mbuf_first;
        }PKTHDRNXT;




        uint16 ph_len;
        uint16 ph_flags;
# 127 "mbuf.h"
        uint16 ph_proto:3;
        uint16 ph_vlanTagged:1;
        uint16 ph_LLCTagged:1;
        uint16 ph_pppeTagged:1;
        uint16 ph_pppoeIdx:3;



        uint16 ph_vlanIdx:3;
        uint16 ph_reserved2:4;
# 148 "mbuf.h"
        uint16 ph_reason;


        uint8 ph_extPortList;

        uint8 ph_srcExtPortNum;

        uint16 ph_portlist;






        uint32 ph_reserved;


        struct rtl_pktHdr *ph_nextHdr;
        uint32 ph_sip, ph_dip;


        int8 ph_routeIdx;
        uint8 ph_iphdrOffset;
        int16 ph_rxdesc;
# 186 "mbuf.h"
        int16 ph_rxmbufdesc;

        union {
                struct {
                       uint16 _ph_dataLen;
                        uint16 _ph_fragOffset;
                        uint8 _ph_unnumber;
                        uint8 _ph_dsid;
                        uint16 _ph_sport;
                        uint8 _ph_priority;
                        uint8 _ph_procFlag;
                        uint8 _ph_reserved1;
                        uint8 _ph_reserved2;
                } ROMEDRV_USG;
                union {

                        struct {
                                uint16 _ph_category;
                                uint16 _ph_reserved1;
                                uint16 _ph_reserved2;
                                uint16 _ph_reserved3;
                        } TO_PS;

                        struct {
                                uint32 _ph_pkt_property;
                                uint16 _ph_reserved1;
                                uint16 _ph_reserved2;
                        } FROM_PS;
                } PS_USG;
        } ph_un_sw;
# 236 "mbuf.h"
};

struct rtl_mBufStatus
{
        uint32 m_totalmbufs;
        uint32 m_totalclusters;
        uint32 m_totalpkthdrs;
        uint32 m_freembufs;
        uint32 m_freeclusters;
        uint32 m_freepkthdrs;
        uint32 m_msize;
        uint32 m_mclbytes;
        uint32 m_pkthdrsize;

        uint32 m_wait;
};
# 268 "mbuf.h"
extern int32 m_clusterSize;
# 289 "mbuf.h"
extern int32 mBuf_init(uint32, uint32, uint32, uint32, uint32);
# 310 "mbuf.h"
extern int32 mBuf_getBufStat(struct rtl_mBufStatus *mbs);
# 321 "mbuf.h"
extern int32 mBuf_leadingSpace(struct rtl_mBuf *m);
# 335 "mbuf.h"
extern int32 mBuf_trailingSpace(struct rtl_mBuf *m);
# 349 "mbuf.h"
extern int32 mBuf_clusterIsWritable(struct rtl_mBuf *m);
# 364 "mbuf.h"
extern uint32 mBuf_getPktlen(struct rtl_mBuf *m);
# 376 "mbuf.h"
extern struct rtl_mBuf *mBuf_data2Mbuf(int8 * x);
# 400 "mbuf.h"
extern struct rtl_mBuf *mBuf_get(int32 how, int32 unused, uint32 Nbuf);
# 435 "mbuf.h"
extern struct rtl_mBuf *mBuf_getCleared(int32 how, int32 unused, uint32 Nbuf);
# 459 "mbuf.h"
extern uint32 mBuf_driverGet(uint32 Nmbuf,struct rtl_mBuf **ppFirstMbuf, struct rtl_mBuf **ppLastMbuf);
# 482 "mbuf.h"
extern struct rtl_mBuf *mBuf_getm(struct rtl_mBuf *m, uint32 len, int32 how, int32 unused);
# 516 "mbuf.h"
extern struct rtl_mBuf *mBuf_getPkthdr(struct rtl_mBuf *m, int32 how);
# 543 "mbuf.h"
extern uint32 mBuf_driverGetPkthdr(uint32 Npkthdr,struct rtl_pktHdr **ppHeadPkthdr, struct rtl_pktHdr **ppTailPkthdr);
# 566 "mbuf.h"
extern void mBuf_freeMbuf(struct rtl_mBuf *m);
# 582 "mbuf.h"
extern int32 mBuf_attachCluster(struct rtl_mBuf *m, void *buffer, uint32 id, uint32 size, uint16 datalen, uint16 align);
# 601 "mbuf.h"
extern int32 mBuf_freeOneMbufPkthdr(struct rtl_mBuf *m, void **buffer, uint32 *id, uint16 *size);
# 625 "mbuf.h"
extern struct rtl_mBuf *mBuf_freeOne(struct rtl_mBuf *m);
# 644 "mbuf.h"
extern uint32 mBuf_freeMbufChain(register struct rtl_mBuf *m);
# 667 "mbuf.h"
extern uint32 mBuf_driverFreeMbufChain(struct rtl_mBuf *pFirstMbuf);
# 691 "mbuf.h"
extern void mBuf_freePkthdr(struct rtl_pktHdr *ph);
# 703 "mbuf.h"
uint32 mBuf_driverFreePkthdr(struct rtl_pktHdr *ph, uint32 Npkthdr, struct rtl_pktHdr **ppHeadPkthdr);
# 717 "mbuf.h"
extern struct rtl_mBuf *mBuf_adjHead(struct rtl_mBuf *, uint32 req_len);
# 736 "mbuf.h"
extern struct rtl_mBuf *mBuf_adjTail(struct rtl_mBuf *, uint32 req_len);
# 755 "mbuf.h"
extern struct rtl_mBuf *mBuf_trimHead(struct rtl_mBuf *, uint32 req_len);
# 775 "mbuf.h"
extern struct rtl_mBuf *mBuf_trimTail(struct rtl_mBuf *, uint32 req_len);
# 797 "mbuf.h"
extern int32 mBuf_copyToMbuf(struct rtl_mBuf *, uint32 offset, uint32 len, int8 *cp);
# 832 "mbuf.h"
extern int32 mBuf_copyToUserBuffer(struct rtl_mBuf *m, uint32 off, uint32 len, int8 * cp);
# 856 "mbuf.h"
extern struct rtl_mBuf *mBuf_cloneMbufChain(struct rtl_mBuf *pThisMbuf, int32 iOffset,
                                                        int32 iLength, int32 iWait);
# 888 "mbuf.h"
extern struct rtl_mBuf *mBuf_dupMbufChain(struct rtl_mBuf *pMbufChain, int32 iOffset, int32 iLength, int32 flag);
# 920 "mbuf.h"
extern struct rtl_mBuf *mBuf_clonePacket(struct rtl_mBuf *pMbuf, int32 iHow);
# 945 "mbuf.h"
extern struct rtl_mBuf *mBuf_dupPacket(struct rtl_mBuf *pMbuf, int32 iHow);
# 974 "mbuf.h"
extern struct rtl_mBuf *mBuf_prepend(struct rtl_mBuf *m, uint32 plen, int32 how);
# 1007 "mbuf.h"
extern struct rtl_mBuf *mBuf_padding(struct rtl_mBuf *m, uint32 plen, int32 how);
# 1037 "mbuf.h"
extern struct rtl_mBuf *mBuf_cat(struct rtl_mBuf *m, struct rtl_mBuf *n);
# 1054 "mbuf.h"
extern int32 mBuf_pullup(struct rtl_mBuf *, int32);
# 1096 "mbuf.h"
struct rtl_mBuf *mBuf_split(register struct rtl_mBuf *m0, uint32 len0, int32 wait);
# 1119 "mbuf.h"
void mBuf_getBMjmpTable(uint8 *pat, uint16 *jump_tbl,uint16 patLen, uint8 caseSensitive);
int32 mBuf_BMpatternMatch(struct rtl_mBuf *m, uint32 len, uint8 *delimiter, uint32 delimitLen, uint16 *jmp_tbl, uint8 caseSensitive);
# 1135 "mbuf.h"
 struct rtl_mBuf *mBuf_attachHeader(void *buffer, uint32 id, uint32 bufsize,uint32 datalen, uint16 align);
int32 mBuf_setNICRxRingSize(uint32 size);
# 22 "rtl8651_tblDrv.h" 2

# 1 "rtl8651_debug.h" 1
# 24 "rtl8651_tblDrv.h" 2
# 136 "rtl8651_tblDrv.h"
typedef struct rtl8651_tblDrvInitPara_s {
        uint32 macAddressDbSize;
        uint32 filterDbSize;
        uint32 networkIntfTableSize;
        uint32 ipIntfEntryNumber;
        uint32 ipIntfIpAddrNumber;
        uint32 arpTableSize;
        uint32 routingTableSize;
        uint32 natSize;
        uint32 natCtlSize;
        uint32 naptServerPortEntryNumber;
        uint32 naptTcpUdpFlowSize;
        uint32 naptIcmpFlowSize;
        uint32 aclSize;
        uint32 algSize;
        uint32 urlfilterDBSize;
        uint32 urlfilterStringLen;
        uint32 pathfilterStringLen;
        uint32 urlPktfilterDBSize;
        uint32 dialSessionNumber;
        uint32 dmzHostsNum;
        uint32 policyRules;
        uint32 dynamicPolicy;
        uint32 pptpSize;
        uint32 l2tpSize;
        uint32 pppoePassthruSize;
        uint32 protocolBasedNatSize;
        uint32 mCastTblSize;
        uint32 macAccessControllSize;
        uint32 ipUnnumberSize;




        uint32 urlfilterTrustedUserEntryCnt;


} rtl8651_tblDrvInitPara_t;


typedef struct ___rtl8651_tblDrvPolicyRoute_t
{
        int type;
        union
        {
                uint32 ip_s;
                uint32 ip_d;

                struct {
                        uint16 start ;
                        uint16 end;
                }dport;

                struct {
                        ipaddr_t sip;
                        ipaddr_t dip;
                } sipDipPair;

        }trigger;
        uint32 ip_start;
        uint32 ip_end;
        uint32 ip_alias;

} rtl8651_tblDrvPolicyRoute_t;
typedef struct __rtl8651_tblDrvPolicyRoute_t
{
        int type;
        union
        {
                uint32 ip_s;
                uint32 ip_d;
                struct {
                        uint16 start ;
                        uint16 end;
                }dport;

                struct {
                        ipaddr_t sip;
                        ipaddr_t dip;
                } sipDipPair;

        } trigger;
        uint32 ip_start;
        uint32 ip_end;
        uint32 ip_alias;
        void *rt;


        struct __rtl8651_tblDrvPolicyRoute_t *timenext;
        struct __rtl8651_tblDrvPolicyRoute_t *timeprev;
        struct __rtl8651_tblDrvPolicyRoute_t *linknext;
        struct __rtl8651_tblDrvPolicyRoute_t *linkprev;
        uint32 fullAge;
        uint32 age;

} _rtl8651_tblDrvPolicyRoute_t;
# 251 "rtl8651_tblDrv.h"
typedef struct __rtl8651_tblDrvDemandRoute_t
{
        int type;
        union
        {
                int ip_s;
                int ip_d;
                struct {
                        uint16 start ;
                        uint16 end;
                }dport;
        }trigger;
        uint32 ip_start;
        uint32 ip_end;
        int identity;
        int32 (*p_handler)(uint32);
} rtl8651_tblDrvDemandRoute_t;





typedef struct rtl8651_tblDrvPolicy_s {
        uint32 proto;
        ipaddr_t sip, sipMask,
                                dip, dipMask;
        uint16 sport_start, sport_end,
                                dport_start, dport_end;
        ipaddr_t naptip;

} rtl8651_tblDrvPolicy_t;
# 297 "rtl8651_tblDrv.h"
typedef struct rtl8651_tblDrvAclRule_s {
        union {

                struct {
                        ether_addr_t _dstMac, _dstMacMask;
                        ether_addr_t _srcMac, _srcMacMask;
                        uint16 _typeLen, _typeLenMask;
                } MAC;

                struct {
                        uint8 _gidxSel;
                } IFSEL;

                struct {
                        ipaddr_t _srcIpAddr, _srcIpAddrMask;
                        ipaddr_t _dstIpAddr, _dstIpAddrMask;
                        uint8 _tos, _tosMask;
                        union {

                                struct {
                                        uint8 _proto, _protoMask, _flagMask;


                                        uint32 _FOP:1, _FOM:1, _httpFilter:1, _httpFilterM:1, _identSrcDstIp:1, _identSrcDstIpM:1;

                                        union {
                                                uint8 _flag;
                                                struct {
                                                        uint8 pend1:5,
                                                                 pend2:1,
                                                                 _DF:1,
                                                                 _MF:1;
                                                } s;
                                        } un;
                                } ip;

                                struct {
                                        uint8 _type, _typeMask, _code, _codeMask;
                                } icmp;

                                struct {
                                        uint8 _type, _typeMask;
                                } igmp;

                                struct {
                                        ether_addr_t _l2srcMac, _l2srcMacMask;
                                        uint8 _flagMask;
                                        uint16 _srcPortUpperBound, _srcPortLowerBound;
                                        uint16 _dstPortUpperBound, _dstPortLowerBound;
                                        union {
                                                uint8 _flag;
                                                struct {
                                                        uint8 _pend:2,
                                                                  _urg:1,
                                                                  _ack:1,
                                                                  _psh:1,
                                                                  _rst:1,
                                                                  _syn:1,
                                                                  _fin:1;
                                                }s;
                                        }un;
                                }tcp;

                                struct {
                                        ether_addr_t _l2srcMac, _l2srcMacMask;
                                        uint16 _srcPortUpperBound, _srcPortLowerBound;
                                        uint16 _dstPortUpperBound, _dstPortLowerBound;
                                }udp;
                        }is;
                }L3L4;



                struct {
                        ether_addr_t _srcMac, _srcMacMask;
                        uint16 _srcPort, _srcPortMask;
                        uint16 _srcVlanIdx, _srcVlanIdxMask;
                        ipaddr_t _srcIpAddr, _srcIpAddrMask;
                        uint16 _srcPortUpperBound, _srcPortLowerBound;
                        uint32 _ignoreL4:1,
                                        _ignoreL3L4:1;
                } SRCFILTER;

                struct {
                        ether_addr_t _dstMac, _dstMacMask;
                        uint16 _vlanIdx, _vlanIdxMask;
                        ipaddr_t _dstIpAddr, _dstIpAddrMask;
                        uint16 _dstPortUpperBound, _dstPortLowerBound;
                        uint32 _ignoreL4:1,
                                         _ignoreL3L4:1;
                } DSTFILTER;

        }un_ty;

        uint32 ruleType_:4;
        uint32 actionType_:4;

        uint32 pktOpApp:3;

        uint32 isEgressRateLimitRule_: 1;
        uint32 matchType_;
} rtl8651_tblDrvAclRule_t;
# 541 "rtl8651_tblDrv.h"
typedef struct rtl865x_tblDrv_basicCounterParam_s {
        uint32 txPackets;
        uint32 txBytes;
        uint32 rxPackets;
        uint32 rxBytes;
        uint32 rxErrors;
        uint32 drops;
} rtl865x_tblDrv_basicCounterParam_t;







void rtl8651_realtimeSchedule(void);
void rtl8651_timeUpdate(uint32 dummy);
int32 rtl8651_enableNaptAutoAdd(int8 enable);


int32 rtl8651a_addAclRule(uint32 SessionID,int8 * ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule);

int32 rtl8651a_delAclRule(uint32 SessionID,int8 *ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule);

int32 rtl8651a_addAclRuleExt(uint32 sessionId, int8 *ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule);

int32 rtl8651a_delAclRuleExt(uint32 sessionID,int8 *ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule);



int32 rtl8651a_flushAclRule(uint32 SessionID,int8 *ifName, int8 Ingress);

int32 rtl8651a_setDefaultAcl(uint32 SessionID,int8 *ifName, int8 defAction);




int32 rtl8651_addPppoeSession(uint32 SessionID, uint16 vid);
int32 rtl8651_delPppoeSession(uint32 SessionID);

int32 rtl8651_setPppoeSessionProperty(uint32 SessionID, uint16 sid, ether_addr_t * macAddr, uint32 port);


int32 rtl8651_resetPppoeSessionProperty(uint32 SessionID);
int32 rtl8651_getPppoeSessionMac(uint32 SessionID, ether_addr_t * macAddr);
int32 rtl8651_bindPppoeSession(ipaddr_t ipaddr, uint32 SessionID);
int32 rtl8651_setPppoeSessionHangUp(uint32 SessionID, int32 enable, uint32 sec, int32 (*p_callBack)(uint32));

uint32 * rtl8651_getNextPppoeSession(uint32 * curSessionId, uint32 *retSessionId);
int32 rtl8651_getPppoeCounter(uint32 curSessionId, rtl865x_tblDrv_basicCounterParam_t * counter);
int32 rtl8651_setPppoeSessionHangUp(uint32 SessionID, int32 enable, uint32 sec, int32 (*p_callBack)(uint32)) ;
int32 rtl8651_setPppoeDefaultSessionId(uint32 SessionID);
int32 rtl8651_addDemandRoute(rtl8651_tblDrvDemandRoute_t * rtAdd, int identity,int32(*p_callBack)(uint32));
uint32 _rtl8651_getDemandRoutingEntry(uint32 ip_s,uint32 ip_d,uint8 proto,uint16 ip_dp);
int32 rtl8651_flushDemandRoute(int identity);
int32 _rtl8651_softIcmpPolicyRoute(ipaddr_t sip, uint16 sID, ipaddr_t dip, ipaddr_t *gip, uint16 *gID);




int32 _rtl8651_softNaptPolicyRoute(int type, ipaddr_t ip_s, ipaddr_t ip_d,uint16 ip_dp,
                                int *ip_alias, uint16 *ip_aliasp);
int32 rtl8651_flushPolicyRoute(uint32 ip);
int32 rtl8651_addPolicyRoute(rtl8651_tblDrvPolicyRoute_t *rtAdd);






int32 rtl8651_addNetworkIntf(int8 *ifName);

int32 rtl8651_delNetworkIntf(int8 *ifName);

int32 rtl8651_setNetIfAclMismatchDrop(int8 *ifName, int8 isDrop);
int32 rtl8651_addExtNetworkInterface(int8 * ifName);

int32 rtl8651_delExtNetworkInterface(int8 * ifName);



int32 rtl8651_addDmzNetworkInterface(int8 *ifName);
int32 rtl8651_delDmzNetworkInterface(int8 *ifName);
int32 rtl8651_specifyNetworkIntfLinkLayerType(int8 * ifName, uint32 llType, uint16 vid);
int32 rtl8651_removeNetworkIntfLinkLayerType(int8 * ifName);


int32 rtl8651_addIpIntf(int8 * ifName, ipaddr_t ipAddr, ipaddr_t ipMask);
int32 rtl8651_delIpIntf(int8 * ifName, ipaddr_t ipAddr, ipaddr_t ipMask);


int32 rtl8651_addArp(ipaddr_t ipAddr, ether_addr_t * macAddr, int8 * ifName, uint32 port);
int32 rtl8651_delArp(ipaddr_t ipAddr);
int32 rtl8651_setArpAgingTime(uint16 agTime);


int32 rtl8651_addNatMapping(ipaddr_t extIpAddr, ipaddr_t intIpAddr);
int32 rtl8651_delNatMapping(ipaddr_t extIpAddr, ipaddr_t intIpAddr);


int32 rtl8651_addLocalServer(ipaddr_t ipAddr);
int32 rtl8651_delLocalServer(ipaddr_t ipAddr);


int32 rtl8651_addRoute(ipaddr_t ipAddr, ipaddr_t ipMask, int8 * ifName, ipaddr_t nextHop);
int32 rtl8651_delRoute(ipaddr_t ipAddr, ipaddr_t ipMask);


int32 rtl8651_addNaptMapping(ipaddr_t extIpAddr);
int32 rtl8651_delNaptMapping(ipaddr_t extIpAddr);
int32 rtl8651_setNaptIcmpTimeout(uint32 timeout);
int32 rtl8651_setNaptIcmpFastTimeout(uint32 timeout);
int32 rtl8651_setNaptUdpTimeout(uint32 timeout);
int32 rtl8651_setNaptTcpLongTimeout(uint32 timeout);
int32 rtl8651_setNaptTcpMediumTimeout(uint32 timeout);
int32 rtl8651_setNaptTcpFastTimeout(uint32 timeout);
int32 rtl8651_setNaptTcpUdpPortRange(uint16 start, uint16 end);
int32 rtl8651_is4WayHashEnable(uint8 *isEnable);
int32 rtl8651_enable4WayHash(uint8 isEnable);





int32 rtl8651a_addNaptServerPortMapping(uint32 SessionID,int8 isTcp, ipaddr_t extIpAddr, uint16 extPort, ipaddr_t intIpAddr, uint16 intPort);

int32 rtl8651a_delNaptServerPortMapping(uint32 SessionID,int8 isTcp, ipaddr_t extIpAddr, uint16 extPort, ipaddr_t intIpAddr, uint16 intPort);

int32 rtl8651a_addNaptServerPortRange(uint32 SessionID,int8 isTcp, ipaddr_t extIp, uint16 extPort, ipaddr_t intIp, uint16 intPort, uint16 nCount);

int32 rtl8651a_delNaptServerPortRange(uint32 SessionID,int8 isTcp, ipaddr_t extIp, uint16 extPort, ipaddr_t intIp, uint16 intPort, uint16 nCount);

int32 rtl8651_flushNaptServerPortbyExtIp(ipaddr_t extIp);



int32 rtl8651_flushAllNaptConnections(void);
int32 rtl8651_addNaptConnection(int16 assigned, int8 flowType, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                        ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort, ipaddr_t dstIpAddr, uint16 dstPort);
# 690 "rtl8651_tblDrv.h"
int32 rtl8651_delNaptConnection(int8 isTcp, ipaddr_t insideLocalIpAddr,
                        uint16 insideLocalPort, ipaddr_t dstIpAddr, uint16 dstPort);
void rtl8651_updateAsicNaptTable(void);
int32 rtl8651_addNaptIcmpFlow(int8 assigned, ipaddr_t insideLocalIpAddr, uint16 insideLocalId,
                        ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalId, ipaddr_t dstIpAddr);
int32 rtl8651_delNaptIcmpFlow(ipaddr_t insideLocalIpAddr, uint16 insideLocalId, ipaddr_t dstIpAddr);
void rtl8651_updateAsicIcmpTable(void);
struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s;
void _rtl8651_refillOrClearAsicNaptEntry(uint32 tblIdx,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * selectedRefillFlow);



int32 rtl8651_addALGRule(uint16 startPort, uint16 endPort, int8 isTcp, int8 isServer, int8 isClient);
int32 rtl8651_delALGRule(uint16 startPort, uint16 endPort, int8 isTcp, int8 isServer, int8 isClient);
# 715 "rtl8651_tblDrv.h"
typedef void (*rtl8651_tblDrv_urlFiltering_CallBackFunc_t)(uint32 sessionId, struct rtl_pktHdr *pkt, struct ip *iphdr, const char *urlFiltered, const char *pathFiltered);

typedef struct rtl8651_tblDrv_urlFilter_s {
        int8 *urlFilterString;
        int32 urlFilterStrLen;
        uint8 urlExactlyMatch;
        int8 *pathFilterString;
        int32 pathFilterStrLen;
        uint8 pathExactlyMatch;
        uint32 sessionId;

        uint8 ruleType:1;

} rtl8651_tblDrv_urlFilter_t;

typedef struct rtl8651_tblDrv_urlPktFilter_s {
        uint32 rule_type;

        ipaddr_t sip_start;
        ipaddr_t sip_end;

        ether_addr_t smac;

} rtl8651_tblDrv_urlPktFilter_t;

int32 rtl8651a_delURLfilterString(uint32 SessionID,int8 *string, int32 strlen);

int32 rtl8651a_delURLExactlyfilterString(uint32 SessionID,int8 *string, int32 strlen);

int32 rtl8651a_addURLfilterString(uint32 SessionID,int8 *string, int32 strlen);

int32 rtl8651a_addURLExactlyfilterString(uint32 SessionID,int8 *string, int32 strlen);

int32 rtl8651_addURLFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end);
int32 rtl8651_addURLExactlyFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end);
int32 rtl8651_delURLFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end);
int32 rtl8651_delURLExactlyFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end);
int32 rtl8651_addGenericURLFilterRule(rtl8651_tblDrv_urlFilter_t *urlFilter, rtl8651_tblDrv_urlPktFilter_t *pktFilter);
int32 rtl8651_delGenericURLFilterRule(rtl8651_tblDrv_urlFilter_t *urlFilter, rtl8651_tblDrv_urlPktFilter_t *pktFilter);
int32 rtl8651_registerURLFilterCallBackFunction(rtl8651_tblDrv_urlFiltering_CallBackFunc_t callBackFunc);

int32 rtl8651_urlUnknownTypeCaseSensitive(int8 enable);



int rtl8651_addUrlFilterTrustedUser(uint32 ipaddr);
void rtl8651_flushUrlFilterTrustedUser(void);
# 855 "rtl8651_tblDrv.h"
typedef struct rtl8651_logInfo_s {
        uint32 infoType;

        union {
                struct urlLogInfo {
                        uint32 dsid;
                        uint8 protocol;
                        uint8 direction;
                        ipaddr_t sip;
                        ipaddr_t dip;
                        uint16 sport;
                        uint16 dport;
                        char * string;

                        char * pathString;
                        char * urlFilterString;
                        char * pathFilterString;

                } url;
                struct packetLogInfo {
                        uint32 dsid;
                        uint8 protocol;
                        uint8 direction;
                        ipaddr_t sip;
                        ipaddr_t dip;
                        uint16 sport;
                        uint16 dport;
                        uint8 icmpType;
                        uint16 icmpId;
                } pkt;
        }un;
# 910 "rtl8651_tblDrv.h"
        uint32 action;
} rtl8651_logInfo_t;
# 930 "rtl8651_tblDrv.h"
typedef int32 (*rtl8651_loggingFuncPtr_t)
(
        uint32 moduleId,
        uint32 logNo,
        rtl8651_logInfo_t* info
);


int32 rtl8651_installLoggingFunction(void * pMyLoggingFunc);
int32 rtl8651a_enableLogging(uint32 SessionID,uint32 moduleId,int8 enable);

extern rtl8651_loggingFuncPtr_t _pUserLoggingFunc;



int32 rtl8651_tblDrvReset(void);
int32 rtl8651_tblDrvReinit(void);

int32 rtl8651_tblDrvInit(rtl8651_tblDrvInitPara_t * configPara);

int32 rtl8651_getPppoeSessionSourceMac(uint32 SessionID, ether_addr_t * macAddr);
ipaddr_t _rtl8651_getNaptInsideGlobalIpAddr(int8 isTcp, ipaddr_t insideLocalIpAddr, uint16 insideLocalPortOrId, ipaddr_t dstIpAddr, uint16 dstPort);



int32 rtl8651a_addDmzHost(uint32 SessionID,ipaddr_t naptIp, ipaddr_t dmzHostIp);

int32 rtl8651a_delDmzHost(uint32 SessionID,ipaddr_t naptIp);



int32 rtl8651_addIpUnnumbered(int8 *wanIfName, int8 *lanIfName, ipaddr_t netMask);
int32 rtl8651_delIpUnnumbered(int8 *wanIfName, int8 *lanIfName);
int32 rtl8651_getIpUnnumbered(int8 *wanIfName, int8 *ifName, ipaddr_t *netMask);
int32 rtl8651_setLanSideExternalIpInterface(int8 * ifName, ipaddr_t ipAddr, ipaddr_t ipMask, int8 isExternal);


int32 rtl8651_setFlowControl(uint32 port, int8 enable);
int32 rtl8651_setQueueScheduling(uint32 type, uint32 weight);
int32 rtl8651_setPortPriorityQueue(uint32 port, int8 highPriority);
int32 rtl8651_setDiffServDSCP(uint32 dscp, int8 highPriority);
int32 rtl8651_getMNQueueEntry(rtl8651_tblDrvAclRule_t *rule,uint32 GroupId,uint32 index);


int8 rtl8651_EnablePppoePassthru( int8 enable );
int8 rtl8651_enableDropUnknownPppoePADT( int8 enable );
int32 rtl8651_getPppoePassthruVid(void);
int32 rtl8651_getExternalInterfaceforPPPoEPassthru(void);


int8 rtl8651_EnableIpv6Passthru(int8 enable);
int32 rtl8651_getIpv6PassthruVid(void);
int32 rtl8651_getExternalInterfaceforIPv6Passthru(void);


int8 rtl8651_EnableIpxPassthru(int8 enable);
int32 rtl8651_getIpxPassthruVid(void);
int32 rtl8651_getExternalInterfaceforIPXPassthru(void);


int8 rtl8651_EnableNetbiosPassthru(int8 enable);
int32 rtl8651_getNetbiosPassthruVid(void);
int32 rtl8651_getExternalInterfaceforNetbiosPassthru(void);


int32 rtl8651_transformPasstheuVlanId( uint32 oldVlanIdx, uint32* newVlanIdx );

void rtl8651_setMtu(uint16 mtu);
int32 rtl8651_setNetMtu(int8 *ifName, uint16 mtu);
void rtl8651_getMtu(uint16 * mtu);

uint8 rtl8651_EnableProtocolBasedNAT( uint8 enable );
int32 rtl8651_addProtocolBasedNAT( uint8 protocol, ipaddr_t ExtIp, ipaddr_t IntIp );
int32 rtl8651_delProtocolBasedNAT( uint8 protocol, ipaddr_t ExtIp, ipaddr_t IntIp );

int32 rtl8651_enableMacAccessControl(int8 enable);
int32 rtl8651_setMacAccessControlDefaultPermit(int8 isPermit);
int32 rtl8651_delMacAccessControl(ether_addr_t *sMac, ether_addr_t *macMask);
int32 rtl8651_flushMacAccessControl(void);
int32 rtl8651_addMacAccessControl(ether_addr_t *sMac, ether_addr_t *macMask, int8 isPermit);



int32 rtl8651_addExternalMulticastPort(uint32 extMPort);
int32 rtl8651_delExternalMulticastPort(uint32 extMPort);

int32 rtl8651_autoCrossOverDetect(uint32 isEnable);
int32 rtl8651_portAutoCrossOverDetect(uint32 port, uint32 isEnable);
int32 rtl8651_setMdiMdix(uint32 isMdi);
int32 rtl8651_setPortMdiMdix(uint32 port, uint32 isMdi);




extern int8 rtl8651_tblDrv_Id[];
extern int8 rtl8651_tblDrvFwd_Id[];
# 1109 "rtl8651_tblDrv.h"
typedef struct rtl8651_PS_Action_Entry_s {
        ipaddr_t dstIp;
        ipaddr_t lowerIp;
        ipaddr_t upperIp;
        uint16 orgPort;
        uint16 orgPortEnd;
        uint16 fwdPort;
        uint8 protocol;
        uint8 action;
        uint8 role;
} rtl8651_PS_Action_Entry_t;

extern int32 wlan_acc_debug;



extern uint8 rtl8651_gPPPoEExternalVlanIndex;
extern ether_addr_t rtl8651_gPPPoEExternalGatewayMAC;
extern uint16 rtl8651_gPPPoEPassthruVlanID;




uint32 _rtl8651_setPPPoEPassthruTimeout( uint32 timeout );
int32 rtl8651_addPPPoEPassthru( uint16 sid, ether_addr_t* clientMac, ether_addr_t* serverMac,
                                uint16 clientVid, uint16 serverVid );
int32 rtl8651_getPPPoEPassthru( uint16 sid, ether_addr_t* clientMac, ether_addr_t* serverMac,
                                uint16 *clientVid, uint16 *serverVid, int32 updateTouch );
int32 rtl8651_delPPPoEPassthru( uint16 sid );

extern uint32 gPPPoEPassthruTimeout;




extern uint8 rtl8651_gIPv6ExternalVlanIndex;
extern ether_addr_t rtl8651_gIPv6ExternalGatewayMAC;
extern uint16 rtl8651_gIPv6PassthruVlanID;
extern uint32 rtl8651_pbv_ipv6passthru;





extern uint8 rtl8651_gIPXExternalVlanIndex;
extern ether_addr_t rtl8651_gIPXExternalGatewayMAC;
extern uint16 rtl8651_gIPXPassthruVlanID;
extern uint32 rtl8651_pbv_ipxpassthru;





extern uint8 rtl8651_gNetbiosExternalVlanIndex;
extern ether_addr_t rtl8651_gNetbiosExternalGatewayMAC;
extern uint16 rtl8651_gNetbiosPassthruVlanID;
extern uint32 rtl8651_pbv_netbiospassthru;




extern int8 rtl8651_drvProtocolBasedNatEnable;
# 1187 "rtl8651_tblDrv.h"
typedef struct rtl8651_sessionHangUp_s {
        int32 enable;
        uint32 sessionID;
        uint32 idleTimeout_sec;
        int32 (*idleTimeout_callBack)(uint32);
} rtl8651_sessionHangUp_t;

int32 rtl8651_setSessionHangUp(rtl8651_sessionHangUp_t *param);
# 35 "rtl8651_tblDrv.c" 2
# 1 "rtl8651_tblAsicDrv.h" 1
# 11 "rtl8651_tblAsicDrv.h"
extern int8 RtkHomeGatewayChipName[16];
extern int32 RtkHomeGatewayChipRevisionID;
# 58 "rtl8651_tblAsicDrv.h"
enum {
    TYPE_L2_SWITCH_TABLE = 0,
    TYPE_ARP_TABLE,
    TYPE_L3_ROUTING_TABLE,
    TYPE_MULTICAST_TABLE,
    TYPE_PROTOCOL_TRAP_TABLE,
    TYPE_VLAN_TABLE,
    TYPE_EXT_INT_IP_TABLE,
    TYPE_ALG_TABLE,
    TYPE_SERVER_PORT_TABLE,
    TYPE_L4_TCP_UDP_TABLE,
    TYPE_L4_ICMP_TABLE,
    TYPE_PPPOE_TABLE,
    TYPE_ACL_RULE_TABLE,
    TYPE_NEXT_HOP_TABLE,
    TYPE_RATE_LIMIT_TABLE,
};






typedef struct {


    uint16 mac31_16;
    uint16 mac15_0;

    uint16 vhid : 9;
    uint16 memberPort : 6;
    uint16 valid : 1;
    uint16 mac47_32;

    uint8 reserv5 : 1;
    uint8 outACLEnd : 7;
    uint8 reserv4 : 1;
    uint8 outACLStart : 7;
    uint8 reserv3 : 1;
    uint8 inACLEnd : 7;
    uint8 reserv2 : 1;
    uint8 inACLStart : 7;

    uint32 mtuL : 8;
    uint32 macMask : 2;
    uint32 egressUntag : 6;
    uint32 promiscuous : 1;
    uint32 bcastToCPU : 1;
    uint32 STPStatus : 12;
    uint32 enHWRoute : 1;
    uint32 isInternal : 1;

    uint32 reserv7 : 15;
    uint32 macNotExist : 1;
    uint32 isDMZ : 1;
    uint32 extSTPStatus : 6;
    uint32 extEgressUntag : 3;
    uint32 extMemberPort : 3;
    uint32 mtuH : 3;
# 154 "rtl8651_tblAsicDrv.h"
    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_vlanTable_t;

typedef struct {


    uint16 reserv5 : 12;
    uint16 valid : 1;
    uint16 trapProtocol: 3;
    uint16 trapContent;
# 176 "rtl8651_tblAsicDrv.h"
    uint32 reservw1;

    uint32 reservw2;

    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_protoTrapTable_t;

typedef struct {


    ipaddr_t internalIP;

    ipaddr_t externalIP;




    uint32 reserv0 : 24;
    uint32 nextHop : 5;

    uint32 isLocalPublic : 1;
    uint32 isOne2One : 1;
    uint32 valid : 1;
# 224 "rtl8651_tblAsicDrv.h"
    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_extIpTable_t;

typedef struct {


    ipaddr_t internalIP;

    ipaddr_t externalIP;

    uint16 externalPort;
    uint16 internalPort;




    uint32 reserv0 : 25;
    uint32 isPortRange : 1;
    uint32 nextHop : 5;

    uint32 valid : 1;
# 272 "rtl8651_tblAsicDrv.h"
    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_srvPortTable_t;

typedef struct {


    uint16 reserv : 15;
    uint16 valid : 1;
    uint16 L4Port;







    uint32 reservw1;

    uint32 reservw2;

    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_algTable_t;

typedef struct {


    ipaddr_t IPAddr;

    union {
        struct {
            uint32 reserv0 : 5;
            uint32 ARPIpIdx : 2;
            uint32 ARPEnd : 6;
            uint32 ARPStart : 6;
            uint32 IPMask : 5;
            uint32 vid : 3;
            uint32 hPriority : 1;
            uint32 process : 3;
            uint32 valid : 1;
        } ARPEntry;
        struct {
            uint32 reserv0 : 9;
            uint32 nextHop : 10;
            uint32 IPMask : 5;
            uint32 vid : 3;
            uint32 hPriority : 1;
            uint32 process : 3;
            uint32 valid : 1;
        } L2Entry;
        struct {
            uint32 reserv0 : 6;
            uint32 PPPoEIndex : 3;
            uint32 nextHop : 10;
            uint32 IPMask : 5;
            uint32 vid : 3;
            uint32 hPriority : 1;
            uint32 process : 3;
            uint32 valid : 1;
        } PPPoEEntry;

        struct {
            uint32 reserv0 : 5;
            uint32 IPDomain : 3;
            uint32 nhAlgo : 2;
            uint32 nhNxt : 5;
            uint32 nhStart : 4;
            uint32 IPMask : 5;
            uint32 nhNum : 3;
            uint32 hPriority : 1;
            uint32 process : 3;
            uint32 valid : 1;
        } NxtHopEntry;

    } linkTo;
# 412 "rtl8651_tblAsicDrv.h"
    uint32 reservw2;

    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_l3RouteTable_t;

typedef struct {





    uint16 reserv0 : 13;
    uint16 ageTime : 3;

    uint16 sessionID;
# 446 "rtl8651_tblAsicDrv.h"
    uint32 reservw1;

    uint32 reservw2;

    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_pppoeTable_t;

typedef struct {


    uint16 mac39_24;
    uint16 mac23_8;




    uint16 reserv0 : 8;
    uint16 extMemberPort : 3;

    uint16 nxtHostFlag : 1;
    uint16 srcBlock : 1;
    uint16 agingTime : 2;
    uint16 isStatic : 1;
    uint16 toCPU : 1;
    uint16 hPriority : 1;
    uint16 memberPort : 6;
    uint16 mac47_40 : 8;
# 502 "rtl8651_tblAsicDrv.h"
    uint32 reservw2;

    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_l2Table_t;

typedef struct {


    uint32 reserv0 : 21;
    uint32 nextHop : 10;
    uint32 valid : 1;







    uint32 reservw1;

    uint32 reservw2;

    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_arpTable_t;

typedef struct {


    ipaddr_t intIPAddr;
# 558 "rtl8651_tblAsicDrv.h"
    uint32 reserv0 : 1;
    uint32 selEIdx : 10;
    uint32 selIPIdx : 4;
    uint32 isStatic : 1;
    uint32 dedicate : 1;
    uint32 collision2 : 1;
    uint32 offset : 6;
    uint32 agingTime : 6;
    uint32 collision : 1;
    uint32 valid : 1;


    uint32 reserv2 : 12;
    uint32 isTCP : 1;
    uint32 TCPFlag : 3;
    uint32 intPort : 16;
# 606 "rtl8651_tblAsicDrv.h"
    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_naptTcpUdpTable_t;

typedef struct {


    ipaddr_t intIPAddr;

    uint32 ICMPIDL : 15;
    uint32 isStatic : 1;



    uint32 type : 2;

    uint32 offset : 6;
    uint32 agingTime : 6;
    uint32 collision : 1;
    uint32 valid : 1;

    uint32 reserv2 : 15;
    uint32 count : 16;
    uint32 ICMPIDH : 1;
# 658 "rtl8651_tblAsicDrv.h"
    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_naptIcmpTable_t;

typedef struct {

    union {
        struct {

            uint16 dMacP31_16;
            uint16 dMacP15_0;

            uint16 dMacM15_0;
            uint16 dMacP47_32;

            uint16 dMacM47_32;
            uint16 dMacM31_16;

            uint16 sMacP31_16;
            uint16 sMacP15_0;

            uint16 sMacM15_0;
            uint16 sMacP47_32;

            uint16 sMacM47_32;
            uint16 sMacM31_16;

            uint16 ethTypeM;
            uint16 ethTypeP;
        } ETHERNET;
        struct {

            uint32 reserv1 : 24;
            uint32 gidxSel : 8;

            uint32 reserv2[6];
        } IFSEL;
        struct {

            ipaddr_t sIPP;

            ipaddr_t sIPM;

            ipaddr_t dIPP;

            ipaddr_t dIPM;
            union {
                struct {

                    uint8 IPProtoM;
                    uint8 IPProtoP;
                    uint8 IPTOSM;
                    uint8 IPTOSP;




                    uint32 reserv0 : 20;
                    uint32 identSDIPM : 1;
                    uint32 identSDIPP : 1;
                    uint32 HTTPM : 1;
                    uint32 HTTPP : 1;
                    uint32 FOM : 1;
                    uint32 FOP : 1;

                    uint32 IPFlagM : 3;
                    uint32 IPFlagP : 3;

                    uint32 reserv1;
                } IP;
                struct {

                    uint8 ICMPTypeM;
                    uint8 ICMPTypeP;
                    uint8 IPTOSM;
                    uint8 IPTOSP;

                    uint16 reserv0;
                    uint8 ICMPCodeM;
                    uint8 ICMPCodeP;

                    uint32 reserv1;
                } ICMP;
                struct {

                    uint8 IGMPTypeM;
                    uint8 IGMPTypeP;
                    uint8 IPTOSM;
                    uint8 IPTOSP;

                    uint32 reserv0[2];
                } IGMP;
                struct {

                    uint8 TCPFlagM;
                    uint8 TCPFlagP;
                    uint8 IPTOSM;
                    uint8 IPTOSP;

                    uint16 TCPSPLB;
                    uint16 TCPSPUB;

                    uint16 TCPDPLB;
                    uint16 TCPDPUB;
                } TCP;
                struct {

                    uint16 reserv0;
                    uint8 IPTOSM;
                    uint8 IPTOSP;

                    uint16 UDPSPLB;
                    uint16 UDPSPUB;

                    uint16 UDPDPLB;
                    uint16 UDPDPUB;
                } UDP;
            } is;
        } L3L4;

        struct {

            uint16 sMacP31_16;
            uint16 sMacP15_0;

            uint16 sMacM15_0;
            uint16 sMacP47_32;

            uint16 sMacM47_32;
            uint16 sMacM31_16;

            uint32 reserv2 : 6;
            uint32 protoType : 2;
            uint32 sVidxM : 3;
            uint32 sVidxP : 3;
            uint32 spaM : 9;
            uint32 spaP : 9;

            ipaddr_t sIPP;

            ipaddr_t sIPM;

            uint16 SPORTLB;
            uint16 SPORTUB;
        } SRC_FILTER;
        struct {

            uint16 dMacP31_16;
            uint16 dMacP15_0;

            uint16 dMacM15_0;
            uint16 dMacP47_32;

            uint16 dMacM47_32;
            uint16 dMacM31_16;

            uint32 reserv2 : 24;
            uint32 protoType : 2;
            uint32 vidxM : 3;
            uint32 vidxP : 3;

            ipaddr_t dIPP;

            ipaddr_t dIPM;

            uint16 DPORTLB;
            uint16 DPORTUB;
        } DST_FILTER;

    } is;




    uint32 pktOpApp : 3;
    uint32 reserv0 : 4;

    uint32 PPPoEIndex : 3;
    uint32 vid : 3;
    uint32 hPriority : 1;
    uint32 nextHop : 10;
    uint32 actionType : 4;
    uint32 ruleType : 4;
# 1027 "rtl8651_tblAsicDrv.h"
} rtl8651_tblAsic_aclTable_t;

typedef struct {


    ipaddr_t srcIPAddr;

    uint32 srcPortL : 1;
    uint32 srcVid : 3;
    uint32 destIPAddrLsbs : 28;




    uint32 reserv0 : 11;
    uint32 extIPIndexH : 1;
    uint32 ageTime : 3;
    uint32 extPortList : 3;
    uint32 srcPortExt : 1;

    uint32 toCPU : 1;
    uint32 valid : 1;
    uint32 extIPIndex : 3;
    uint32 portList : 6;
    uint32 srcPortH : 2;
# 1076 "rtl8651_tblAsicDrv.h"
    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_ipMulticastTable_t;


typedef struct {


    uint32 reserv0 : 11;
    uint32 nextHop : 10;
    uint32 PPPoEIndex : 3;
    uint32 dstVid : 3;
    uint32 IPIndex : 4;
    uint32 type : 1;
# 1107 "rtl8651_tblAsicDrv.h"
    uint32 reservw1;

    uint32 reservw2;

    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_nextHopTable_t;

typedef struct {


    uint32 reserv0 : 2;
    uint32 refillRemainTime : 6;
    uint32 token : 24;

    uint32 reserv1 : 2;
    uint32 refillTime : 6;
    uint32 maxToken : 24;

    uint32 reserv2 : 8;
    uint32 refill : 24;
# 1149 "rtl8651_tblAsicDrv.h"
    uint32 reservw3;

    uint32 reservw4;

    uint32 reservw5;

    uint32 reservw6;

    uint32 reservw7;
} rtl8651_tblAsic_rateLimitTable_t;







int32 _rtl8651_addAsicEntry(uint32 tableType, uint32 eidx, void *entryContent_P);
int32 _rtl8651_forceAddAsicEntry(uint32 tableType, uint32 eidx, void *entryContent_P);
int32 _rtl8651_readAsicEntry(uint32 tableType, uint32 eidx, void *entryContent_P);
int32 _rtl8651_delAsicEntry(uint32 tableType, uint32 startEidx, uint32 endEidx);

uint32 _rtl8651_NaptAgingToSec(uint32 value);
uint32 _rtl8651_NaptAgingToUnit(uint32 sec);
uint32 rtl8651_filterDbIndex(ether_addr_t * macAddr);

uint32 rtl8651_naptTcpUdpTableIndex(int8 isTCP, ipaddr_t srcAddr, uint16 srcPort, ipaddr_t destAddr, uint16 destPort);
uint32 rtl8651_naptIcmpTableIndex(ipaddr_t srcAddr, uint16 icmpId, ipaddr_t destAddr, uint32 * tblIdx);
uint32 rtl8651_ipMulticastTableIndex(ipaddr_t srcAddr, ipaddr_t dstAddr);

int32 rtl8651_clearAsicAllTable(void);

int32 _rtl8651_mapToVirtualRegSpace( void );
int32 _rtl8651_mapToRealRegSpace( void );
int32 rtl8651_initAsic(void);

int32 rtl8651_setAsicOperationLayer(uint32 layer);
int32 rtl8651_getAsicOperationLayer(void);
int32 rtl8651_setAsicSpanningEnable(int8 spanningTreeEnabled);
int32 rtl8651_getAsicSpanningEnable(int8 *spanningTreeEnabled);
void rtl8651_setEthernetPortLinkStatus(uint32 port, int8 linkUp);
int32 rtl8651_updateLinkStatus(void);
int32 rtl8651_setAsicEthernetLinkStatus(uint32 port, int8 linkUp);
int32 rtl8651_getAsicEthernetLinkStatus(uint32 port, int8 *linkUp);
int32 rtl8651_setAsicEthernetPHY(uint32 port, int8 autoNegotiation, uint32 advCapability, uint32 speed, int8 fullDuplex);
int32 rtl8651_getAsicEthernetPHY(uint32 port, int8 *autoNegotiation, uint32 *advCapability, uint32 *speed, int8 *fullDuplex);
int32 rtl8651_setAsicEthernetBandwidthControl(uint32 port, int8 input, uint32 rate);
int32 rtl8651_getAsicEthernetBandwidthControl(uint32 port, int8 input, uint32 *rate);
int32 rtl8651_setAsicEthernetBandwidthControlX4(int8 enable);
int32 rtl8651_getAsicEthernetBandwidthControlX4(int8 *enable);
int32 rtl8651_setAsicEthernetBandwidthControlX8(int8 enable);
int32 rtl8651_getAsicEthernetBandwidthControlX8(int8 *enable);
int32 rtl8651_setAsicEthernetMII(uint32 phyAddress, int32 mode, int32 enabled);
int32 rtl8651_setAsicEthernetPHYLoopback(uint32 port, int32 enabled);
int32 rtl8651_getAsicEthernetPHYLoopback(uint32 port, int32 *flag);
int32 rtl8651_setAsicMulticastSpanningTreePortState(uint32 port, uint32 portState);
int32 rtl8651_getAsicMulticastSpanningTreePortState(uint32 port, uint32 *portState);
int32 rtl8651_setAsicMulticastPortInternal(uint32 port, int8 isInternal);
int32 rtl8651_getAsicMulticastPortInternal(uint32 port, int8 *isInternal);

typedef struct rtl865x_tblAsicDrv_l2Param_s {
        ether_addr_t macAddr;
        uint32 memberPortMask;
        uint32 ageSec;
        uint32 cpu:1,
                                srcBlk:1,
                                isStatic:1,
                                nhFlag:1;
} rtl865x_tblAsicDrv_l2Param_t;
int32 rtl8651_setAsicL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p);
int32 rtl8651_delAsicL2Table(uint32 row, uint32 column);

int32 rtl8651_getAsicL2Table(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *l2p);
int32 rtl8651_updateAsicLinkAggregatorLMPR(int32 portmask);
int32 rtl8651_setAsicLinkAggregator(uint32 portMask);
int32 rtl8651_getAsicLinkAggregator(uint32 * portMask, uint32 *mapping);
int32 rtl8651_turnOnHardwiredProtoTrap(uint8 protoType, uint16 protoContent);
int32 rtl8651_turnOffHardwiredProtoTrap(uint8 protoType, uint16 protoContent);
int32 rtl8651_getHardwiredProtoTrap(uint8 protoType, uint16 protoContent, int8 *isEnable);
typedef struct rtl865x_tblAsicDrv_protoTrapParam_s {
        uint8 type;
        uint16 content;
} rtl865x_tblAsicDrv_protoTrapParam_t;
int32 rtl8651_setAsicProtoTrap(uint32 index, rtl865x_tblAsicDrv_protoTrapParam_t *protoTrapp);
int32 rtl8651_delAsicProtoTrap(uint32 index);
int32 rtl8651_getAsicProtoTrap(uint32 index, rtl865x_tblAsicDrv_protoTrapParam_t *protoTrapp);
int32 rtl8651_setAsicPvid(uint32 port, uint32 pvidx);
int32 rtl8651_getAsicPvid(uint32 port, uint32 *pvidx);


typedef struct rtl865x_tblAsicDrv_vlanParam_s {
        ether_addr_t macAddr;
        uint32 memberPortMask;
        uint32 untagPortMask;
        uint16 macAddrNumber;
        uint16 vid;
        uint32 inAclStart, inAclEnd, outAclStart, outAclEnd;
        int8 portState[9];
        uint32 mtu;
        uint16 internal:1,
                        enableRoute:1,
                        broadcastToCpu:1,
                        promiscuous:1,
                        DMZFlag:1,
                        valid:1;
} rtl865x_tblAsicDrv_vlanParam_t;
int32 rtl8651_setAsicVlan(rtl865x_tblAsicDrv_vlanParam_t *vlanp);
int32 rtl8651_delAsicVlan(uint16 vid);
int32 rtl8651_getAsicVlan(uint16 vid, rtl865x_tblAsicDrv_vlanParam_t *vlanp);
typedef struct rtl865x_tblAsicDrv_pppoeParam_s {
        uint16 sessionId;

        uint16 age;

} rtl865x_tblAsicDrv_pppoeParam_t;
int32 rtl8651_setAsicPppoe(uint32 index, rtl865x_tblAsicDrv_pppoeParam_t *pppoep);
int32 rtl8651_getAsicPppoe(uint32 index, rtl865x_tblAsicDrv_pppoeParam_t *pppoep);
typedef struct rtl865x_tblAsicDrv_routingParam_s {
            ipaddr_t ipAddr;
            ipaddr_t ipMask;
            uint32 process;
            uint32 vidx;
            uint32 arpStart;
            uint32 arpEnd;
            uint32 arpIpIdx;
            uint32 nextHopRow;
            uint32 nextHopColumn;
            uint32 pppoeIdx;

            uint32 nhStart;
            uint32 nhNum;
            uint32 nhNxt;
            uint32 nhAlgo;
            uint32 ipDomain;

} rtl865x_tblAsicDrv_routingParam_t;
int32 rtl8651_setAsicRouting(uint32 index, rtl865x_tblAsicDrv_routingParam_t *routingp);
int32 rtl8651_delAsicRouting(uint32 index);
int32 rtl8651_getAsicRouting(uint32 index, rtl865x_tblAsicDrv_routingParam_t *routingp);
typedef struct rtl865x_tblAsicDrv_arpParam_s {
        uint32 nextHopRow;
        uint32 nextHopColumn;
} rtl865x_tblAsicDrv_arpParam_t;
int32 rtl8651_setAsicArp(uint32 index, rtl865x_tblAsicDrv_arpParam_t *arpp);
int32 rtl8651_delAsicArp(uint32 index);
int32 rtl8651_getAsicArp(uint32 index, rtl865x_tblAsicDrv_arpParam_t *arpp);
int32 rtl8651_setAsicGidxRegister(uint32 regValue);
int32 rtl8651_getAsicGidxRegister(uint32 * reg);
typedef struct rtl865x_tblAsicDrv_extIntIpParam_s {
            ipaddr_t extIpAddr;
            ipaddr_t intIpAddr;

            uint32 nhIndex;

            uint32 localPublic:1,
                                nat:1;
} rtl865x_tblAsicDrv_extIntIpParam_t;
int32 rtl8651_setAsicExtIntIpTable(uint32 index, rtl865x_tblAsicDrv_extIntIpParam_t *extIntIpp);

int32 rtl8651_setInvalidAsicExtIntIpTable(uint32 index, rtl865x_tblAsicDrv_extIntIpParam_t *extIntIpp);

int32 rtl8651_delAsicExtIntIpTable(uint32 index);
int32 rtl8651_getAsicExtIntIpTable(uint32 index, rtl865x_tblAsicDrv_extIntIpParam_t *extIntIpp);
typedef struct rtl865x_tblAsicDrv_serverPortParam_s {
        ipaddr_t extIpAddr;
        ipaddr_t intIpAddr;
        uint16 extPort;
        uint16 intPort;

        uint32 nhIndex;
        uint32 portRange:1;

        uint32 valid:1;
} rtl865x_tblAsicDrv_serverPortParam_t;
int32 rtl8651_setAsicServerPortTable(uint32 index, rtl865x_tblAsicDrv_serverPortParam_t *serverPortp);
int32 rtl8651_delAsicServerPortTable(uint32 index);
int32 rtl8651_getAsicServerPortTable(uint32 index, rtl865x_tblAsicDrv_serverPortParam_t *serverPortp);
int32 rtl8651_setAsicAgingFunction(int8 l2Enable, int8 l4Enable);
int32 rtl8651_getAsicAgingFunction(int8 * l2Enable, int8 * l4Enable);
int32 rtl8651_setAsicNaptAutoAddDelete(int8 autoAdd, int8 autoDelete);
int32 rtl8651_getAsicNaptAutoAddDelete(int8 *autoAdd, int8 *autoDelete);
int32 rtl8651_setAsicNaptIcmpTimeout(uint32 timeout);
int32 rtl8651_getAsicNaptIcmpTimeout(uint32 *timeout);
int32 rtl8651_setAsicNaptUdpTimeout(uint32 timeout);
int32 rtl8651_getAsicNaptUdpTimeout(uint32 *timeout);
int32 rtl8651_setAsicNaptTcpLongTimeout(uint32 timeout);
int32 rtl8651_getAsicNaptTcpLongTimeout(uint32 *timeout);
int32 rtl8651_setAsicNaptTcpMediumTimeout(uint32 timeout);
int32 rtl8651_getAsicNaptTcpMediumTimeout(uint32 *timeout);
int32 rtl8651_setAsicNaptTcpFastTimeout(uint32 timeout);
int32 rtl8651_getAsicNaptTcpFastTimeout(uint32 *timeout);

int32 rtl8651_setAsicPortMirror(uint32 mTxMask, uint32 mRxMask, uint32 mPortMask);
int32 rtl8651_getAsicPortMirror(uint32 *mRxMask, uint32 *mTxMask, uint32 *mPortMask);

typedef struct rtl865x_tblAsicDrv_nextHopParam_s {
        uint32 nextHopRow;
        uint32 nextHopColumn;
        uint32 pppoeIdx;
        uint32 dvid;
        uint32 extIntIpIdx;
        uint32 isPppoe:1;
} rtl865x_tblAsicDrv_nextHopParam_t;
int32 rtl8651_setAsicNextHopTable(uint32 index, rtl865x_tblAsicDrv_nextHopParam_t *nextHopp);
int32 rtl8651_getAsicNextHopTable(uint32 index, rtl865x_tblAsicDrv_nextHopParam_t *nextHopp);
# 1378 "rtl8651_tblAsicDrv.h"
typedef struct rtl865x_tblAsicDrv_naptTcpUdpParam_s {
        ipaddr_t insideLocalIpAddr;
        uint16 insideLocalPort;
        uint32 ageSec;
        uint8 tcpFlag;
        uint8 offset;

        uint8 selExtIPIdx;
        uint16 selEIdx;

        uint32 isTcp:1,
                        isCollision:1,
                        isStatic:1,

                        isCollision2:1,
                        isDedicated:1,

                        isValid:1;
} rtl865x_tblAsicDrv_naptTcpUdpParam_t;
int32 rtl8651_setAsicNaptTcpUdpTable(int8 forced, uint32 index, rtl865x_tblAsicDrv_naptTcpUdpParam_t *naptTcpUdpp);
int32 rtl8651_getAsicNaptTcpUdpTable(uint32 index, rtl865x_tblAsicDrv_naptTcpUdpParam_t *naptTcpUdpp);
int32 rtl8651_delAsicNaptTcpUdpTable(uint32 start, uint32 end);
int32 _rtl8651_findAsicExtIpTableIdx(ipaddr_t extIp);
int32 rtl8651_setAsicRawNaptTable(uint32 index, void * entry, int8 forced);
int32 rtl8651_getAsicRawNaptTable(uint32 index, void *entry);

int32 rtl8651_setAsicLiberalNaptTcpUdpTable(int8 forced, uint16 index, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort, int8 selExtIPIdx, uint16 insideGlobalPort, uint32 ageSec, int8 entryType, int8 isTcp, int8 isCollision, int8 isCollision2, int8 isValid);


typedef struct rtl865x_tblAsicDrv_naptIcmpParam_s {
        ipaddr_t insideLocalIpAddr;
        uint16 insideLocalId;
        uint16 ageSec;
        uint8 offset;
        uint32 isStatic:1,
                        isCollision:1,

                        isSpi:1,
                        isPptp:1,

                        isValid:1;
        uint16 count;
} rtl865x_tblAsicDrv_naptIcmpParam_t;
int32 rtl8651_setAsicNaptIcmpTable(int8 forced, uint32 index, rtl865x_tblAsicDrv_naptIcmpParam_t *naptIcmpp);
int32 rtl8651_getAsicNaptIcmpTable(uint32 index, rtl865x_tblAsicDrv_naptIcmpParam_t *naptIcmpp);
int32 rtl8651_setAsicL4Offset(uint16 start, uint16 end);
int32 rtl8651_getAsicL4Offset(uint16 *start, uint16 *end);

typedef struct rtl865x_tblAsicDrv_algParam_s {
        uint16 port;
} rtl865x_tblAsicDrv_algParam_t;
int32 rtl8651_setAsicAlg(uint32 index, rtl865x_tblAsicDrv_algParam_t *algp);
int32 rtl8651_delAsicAlg(uint32 index);
int32 rtl8651_getAsicAlg(uint32 index, rtl865x_tblAsicDrv_algParam_t *algp);
int32 rtl8651_getAsicNaptTcpUdpOffset(uint16 index, uint16 * offset, int8 * isValid);
int32 rtl8651_getAsicNaptIcmpOffset(uint16 index, uint16 * offset, int8 * isValid);

typedef struct rtl865x_tblAsicDrv_multiCastParam_s {
        ipaddr_t sip;
        ipaddr_t dip;
        uint16 svid;
        uint16 port;
        uint32 mbr;
        uint16 age;
        uint16 cpu;
        uint16 extIdx;
} rtl865x_tblAsicDrv_multiCastParam_t;

int32 rtl8651_setAsicIpMulticastTable(rtl865x_tblAsicDrv_multiCastParam_t *mCast_t);
int32 rtl8651_delAsicIpMulticastTable(uint32 index);
int32 rtl8651_getAsicIpMulticastTable(uint32 index, rtl865x_tblAsicDrv_multiCastParam_t *mCast_t);


typedef struct rtl865x_tblAsicDrv_basicCounterParam_s {
        uint32 mbr;
        uint32 txPackets;
        uint32 txBytes;
        uint32 rxPackets;
        uint32 rxBytes;
        uint32 rxErrors;
        uint32 drops;
        uint32 cpus;
} rtl865x_tblAsicDrv_basicCounterParam_t;

int32 rtl8651_returnAsicCounter(uint32 offset);
int32 rtl8651_clearAsicCounter(void);

int32 rtl8651_clearAsicSpecifiedCounter(uint32 counterIdx);
int32 rtl8651_resetAsicCounterMemberPort(uint32 counterIdx);
int32 rtl8651_addAsicCounterMemberPort(uint32 counterIdx, uint32 port);
int32 rtl8651_delAsicCounterMemberPort(uint32 counterIdx, uint32 port);
int32 rtl8651_getAsicCounter(uint32 counterIdx, rtl865x_tblAsicDrv_basicCounterParam_t * basicCounter);



typedef struct rtl865x_tblAsicDrv_rateLimitParam_s {
        uint32 token;
        uint32 maxToken;
        uint32 t_remainUnit;
        uint32 t_intervalUnit;
        uint32 refill_number;
} rtl865x_tblAsicDrv_rateLimitParam_t;

int32 rtl8651_setAsicRateLimitTable(uint32 index, rtl865x_tblAsicDrv_rateLimitParam_t *rateLimit_t);
int32 rtl8651_delAsicRateLimitTable(uint32 index);
int32 rtl8651_getAsicRateLimitTable(uint32 index, rtl865x_tblAsicDrv_rateLimitParam_t *rateLimit_t);



int32 rtl8651_setBroadCastStormReg(int8 enable);
int32 rtl8651_getBroadCastSTormReg(int8 *enable);
int32 rtl8651_testAsicDrv(void);

typedef struct {
    uint32 spa;
    uint32 bc;
    uint32 vid;
    uint32 vlan;
    uint32 pppoe;
    uint8 sip[4];
    uint32 sprt;

    uint8 dip[4];
    uint32 dprt;

    uint32 ipptl;
    uint32 ipflg;
    uint32 iptos;
    uint32 tcpflg;
    uint32 type;
    uint32 prtnmat;
        uint32 ethrtype;
    uint8 da[6];
    uint8 pad1[2];
    uint8 sa[6];
    uint8 pad2[2];
    uint32 hp;
    uint32 llc;
    uint32 udp_nocs;
    uint32 ttlst;
    uint32 pktend;
    uint32 dirtx;
    uint32 l4crcok;
    uint32 l3crcok;
    uint32 ipfragif;
    uint32 dp ;
    uint32 hp2;

        uint16 ipLen;
        uint8 L2only;


} rtl8651_tblAsic_hsb_param_watch_t;

typedef struct {

        uint8 mac[6];
        uint8 pad1[2];
        uint8 ip[4];
        uint32 prt;
        uint32 l3cs;
        uint32 l4cs;
        uint32 egress;
        uint32 l2act;
        uint32 l34act;
        uint32 dirtx;
        uint32 type;
        uint32 llc;
        uint32 vlan;
        uint32 dvid;
        uint32 pppoe;
        uint32 pppid;
        uint32 ttl_1;
        uint32 dpc;
        uint32 bc;
        uint32 pktend;
        uint32 mulcst;
        uint32 svid;
        uint32 cpursn;
        uint32 spa;
        uint32 lastfrag;
        uint32 frag;
        uint32 l4csok;
        uint32 l3csok;
        uint32 bc10_5;

        uint32 extSrcPortNum;
        uint32 extDstPortMask;
        uint32 cpuacl;
        uint32 extTTL_1;

} rtl8651_tblAsic_hsa_param_watch_t;
# 1580 "rtl8651_tblAsicDrv.h"
void rtl8651_updateLinkChangePendingCount(void);

int32 rtl8651_getAsicHsB(rtl8651_tblAsic_hsb_param_watch_t * hsbWatch);
int32 rtl8651_getAsicHsA(rtl8651_tblAsic_hsa_param_watch_t * hsaWatch);

extern int8 rtl8651_tblAsicDrv_Id[];

int32 rtl8651_setAsicPortPatternMatch(uint32 port, uint32 pattern, uint32 patternMask, int32 operation);
int32 rtl8651_getAsicFlowControlRegister(uint32 *fcren);
int32 rtl8651_setAsicFlowControlRegister(uint32 port, int8 enable);
int32 rtl8651_setAsicHLQueueWeight(uint32 weight);
int32 rtl8651_setAsicPortPriority(uint32 port, int8 highPriority);
int32 rtl8651_getAsicQoSControlRegister(uint32 *qoscr);
int32 rtl8651_setAsicDiffServReg(uint32 dscp, int8 highPriority);
int32 rtl8651_getAsicDiffServReg(uint32 *dscr0, uint32 *dscr1);

int32 rtl8651_asicEthernetCableMeter(uint32 port, int32 *rxStatus, int32 *txStatus);
int32 rtl8651_getAsicEthernetMII(uint32 *phyAddress);
int32 rtl8651_queryProtocolBasedVLAN( uint32 ruleNo, uint8* ProtocolType, uint16* ProtocolValue );
# 1612 "rtl8651_tblAsicDrv.h"
int32 rtl8651_defineProtocolBasedVLAN( uint32 ruleNo, uint8 ProtocolType, uint16 ProtocolValue );
int32 rtl8651_setProtocolBasedVLAN( uint32 ruleNo, uint32 port, uint8 valid, uint8 vlanIdx );
int32 rtl8651_getProtocolBasedVLAN( uint32 ruleNo, uint32 port, uint8* valid, uint8* vlanIdx );

int32 rtl8651_autoMdiMdix(uint32 port, uint32 isEnable);
int32 rtl8651_getAutoMdiMdix(uint32 port, uint32 *isEnable);
int32 rtl8651_selectMdiMdix(uint32 port, uint32 isMdi);
int32 rtl8651_getSelectMdiMdix(uint32 port, uint32 *isMdi);




uint32 _Is4WayHashEnabled( void );
# 36 "rtl8651_tblDrv.c" 2
# 1 "rtl8651_tblDrvFwdLocal.h" 1
# 169 "rtl8651_tblDrvFwdLocal.h"
# 1 "assert.h" 1
# 170 "rtl8651_tblDrvFwdLocal.h" 2






# 1 "rtl_queue.h" 1
# 177 "rtl8651_tblDrvFwdLocal.h" 2



# 1 "rtl8651_tblDrvFwd_utility.h" 1
# 181 "rtl8651_tblDrvFwdLocal.h" 2

# 1 "rtl8651_tblDrvLocal.h" 1
# 31 "rtl8651_tblDrvLocal.h"
# 1 "rtl8651_aclLocal.h" 1
# 34 "rtl8651_aclLocal.h"
typedef struct rtl8651_tblDrv_aclAsicArrangementEntry_s {
        uint16 vidOrNum;
        uint16 inOrOut;
        int32 identy;
} rtl8651_tblDrv_aclAsicArrangementEntry_t;



typedef struct _rtl8651_tblDrvAclRule_s {
        union {

                struct {
                        ether_addr_t _dstMac, _dstMacMask;
                        ether_addr_t _srcMac, _srcMacMask;
                        uint16 _typeLen, _typeLenMask;
                } MAC;

                struct {
                        uint8 _gidxSel;
                } IFSEL;

                struct {
                        ipaddr_t _srcIpAddr, _srcIpAddrMask;
                        ipaddr_t _dstIpAddr, _dstIpAddrMask;
                        uint8 _tos, _tosMask;
                        union {

                                struct {
                                        uint8 _proto, _protoMask, _flagMask;

                                        uint32 _FOP:1, _FOM:1, _httpFilter:1, _httpFilterM:1, _identSrcDstIp:1, _identSrcDstIpM:1;

                                        union {
                                                uint8 _flag;
                                                struct {
                                                        uint8 pend1:5,
                                                                 pend2:1,
                                                                 _DF:1,
                                                                 _MF:1;
                                                } s;
                                        } un;
                                } ip;

                                struct {
                                        uint8 _type, _typeMask, _code, _codeMask;
                                } icmp;

                                struct {
                                        uint8 _type, _typeMask;
                                } igmp;

                                struct {
                                        ether_addr_t _l2srcMac, _l2srcMacMask;
                                        uint8 _flagMask;
                                        uint16 _srcPortUpperBound, _srcPortLowerBound;
                                        uint16 _dstPortUpperBound, _dstPortLowerBound;
                                        union {
                                                uint8 _flag;
                                                struct {
                                                        uint8 _pend:2,
                                                                  _urg:1,
                                                                  _ack:1,
                                                                  _psh:1,
                                                                  _rst:1,
                                                                  _syn:1,
                                                                  _fin:1;
                                                }s;
                                        }un;
                                }tcp;

                                struct {
                                        ether_addr_t _l2srcMac, _l2srcMacMask;
                                        uint16 _srcPortUpperBound, _srcPortLowerBound;
                                        uint16 _dstPortUpperBound, _dstPortLowerBound;
                                }udp;
                        }is;
                }L3L4;


                struct {
                        ether_addr_t _srcMac, _srcMacMask;
                        uint16 _srcPort, _srcPortMask;
                        uint16 _srcVlanIdx, _srcVlanIdxMask;
                        ipaddr_t _srcIpAddr, _srcIpAddrMask;
                        uint16 _srcPortUpperBound, _srcPortLowerBound;
                        uint32 _ignoreL3L4:1,
                                         _ignoreL4:1;
                } SRCFILTER;

                struct {
                        ether_addr_t _dstMac, _dstMacMask;
                        uint16 _vlanIdx, _vlanIdxMask;
                        ipaddr_t _dstIpAddr, _dstIpAddrMask;
                        uint16 _dstPortUpperBound, _dstPortLowerBound;
                        uint32 _ignoreL4:1,
                                   _ignoreL3L4:1;
                } DSTFILTER;

        }un_ty;
        uint32 ruleType_:4;
        uint32 actionType_:4;

        uint32 pktOpApp:3;

        uint32 isEgressRateLimitRule_:1;
        uint32 matchType_;

        uint32 dsid;
        uint32 dvid_:3;
        uint32 priority_:1;
        uint32 nextHop_:10;
        uint32 pppoeIdx_:3;
        uint32 isIPRange_:1;
        uint32 isRateLimitCounter_:1;

        uint16 nhIndex;
        uint16 rlIndex;


        uint32 aclIdx;
        struct { struct _rtl8651_tblDrvAclRule_s *tqe_next; struct _rtl8651_tblDrvAclRule_s **tqe_prev; } nextRule;
} _rtl8651_tblDrvAclRule_t;
# 185 "rtl8651_aclLocal.h"
void _rtl8651_arrangeAllACL(void);
# 32 "rtl8651_tblDrvLocal.h" 2
# 1 "rtl8651_layer2local.h" 1
# 21 "rtl8651_layer2local.h"
typedef struct rtl8651_tblAsic_ethernet_s {
        uint8 linkUp:1;
} rtl8651_tblAsic_ethernet_t;
# 35 "rtl8651_layer2local.h"
typedef struct rtl8651_tblDrv_ethernet_s {
        uint32 speed:2,
                        duplex:1,
                        autoNegotiation:1,
                        fake_forceMode:1,
                        autoAdvCapability:3,
                        inputBandwidthControl:4,
                        outputBandwidthControl:4,
                        linkUp:1;
        uint16 aggregatorIndex;
} rtl8651_tblDrv_ethernet_t;

typedef struct rtl8651_tblDrv_linkAggregation_s {
        uint16 pvid;
        uint16 individual:1,
                        aggregated:1;
        uint32 ethernetPortMask;
        uint32 ethernetPortUpStatus;
} rtl8651_tblDrv_linkAggregation_t;
# 64 "rtl8651_layer2local.h"
typedef struct rtl8651_tblDrv_filterDbTableEntry_s {
        ether_addr_t macAddr;
        uint16 l2type;
        uint16 process:2,

                        refCount:8,
                        configToAsic:1,
                        asicPos:2;
        uint16 vid;
        uint32 linkId;




        uint32 memberPortMask;
        struct { struct rtl8651_tblDrv_filterDbTableEntry_s *sle_next; } nextFDB;
} rtl8651_tblDrv_filterDbTableEntry_t;
# 91 "rtl8651_layer2local.h"
typedef struct rtl8651_tblDrv_filterDbTable_s {
        uint16 sid;
        uint32 valid:1;
        struct { struct rtl8651_tblDrv_filterDbTableEntry_s *slh_first; } database[256];
} rtl8651_tblDrv_filterDbTable_t;

typedef struct rtl8651_tblDrv_spanningTreeTable_s {
        uint32 protocolWorking:1,
                        valid:1;

        int8 portState[9];
} rtl8651_tblDrv_spanningTreeTable_t;


typedef struct rtl8651_tblDrv_macAddressEntry_s {
        ether_addr_t mac;
        uint16 vid;
        uint32 valid:1,
                        allocated:1;
} rtl8651_tblDrv_macAddressEntry_t;



struct rtl8651_tblDrv_networkIntfTable_s;
typedef struct rtl8651_tblDrv_vlanTable_s {
        ether_addr_t macAddr;
        uint32 memberPortMask;
        uint32 memberPortUpStatus;
        uint32 untagPortMask;
        uint16 macAddrNumber;
        uint16 vid;
        uint16 fid;
        uint32 inAclStart, inAclEnd, outAclStart, outAclEnd;
        uint16 mtu;
        uint16 internal:1,
                        ipAttached:1,
                        manualAssign:1,
                        promiscuous:1,
                        fwdTxMirror:1,
                        DMZflag:1,
                        valid:1,
                        softRoute:1,
                        broadcastToCpu:1;
        struct rtl8651_tblDrv_vlanTable_s *fvlan_t;



        struct rtl8651_tblDrv_networkIntfTable_s *netif_t;

} rtl8651_tblDrv_vlanTable_t;
# 156 "rtl8651_layer2local.h"
extern uint32 peripheralExtPortMask;
# 190 "rtl8651_layer2local.h"
typedef struct rtl8651_tblDrv_miiTunneling_s {
        uint32 valid;
        uint16 wanPort;
        uint16 wanVid;
        uint16 loopbackPort;
        uint16 loopBackVid;
} rtl8651_tblDrv_miiTunneling_t;

int32 rtl8651_setAsicAclRule(uint32 index, _rtl8651_tblDrvAclRule_t *rule);
int32 rtl8651_getAsicAclRule(uint32 index, _rtl8651_tblDrvAclRule_t *rule);
extern rtl8651_tblDrv_miiTunneling_t tunnel;
# 33 "rtl8651_tblDrvLocal.h" 2
# 1 "rtl8651_layer3local.h" 1
# 21 "rtl8651_layer3local.h"
struct rtl8651_tblDrv_ipUnnumbered_s;
# 52 "rtl8651_layer3local.h"
typedef struct rtl8651_tblDrv_ipIntfIpAddrEntry_s {
        ipaddr_t ipAddr;
        struct { struct rtl8651_tblDrv_ipIntfIpAddrEntry_s *sle_next; } nextIpAddr;
}rtl8651_tblDrv_ipIntfIpAddrEntry_t;
# 66 "rtl8651_layer3local.h"
struct rtl8651_tblDrvSession_s;

typedef struct rtl8651_tblDrv_pppTable_s {
        struct rtl8651_tblDrv_networkIntfTable_s *netif_t;
        struct rtl8651_tblDrvSession_s *session_t;
        uint32 sessionId;
        uint32 mss;
        uint16 vid;
        uint16 type:5,
                        valid:1,
                        initiated:1;
        rtl8651_tblDrv_filterDbTableEntry_t * macInfo;
        uint8 dsid;
        uint32 txPackets, txBytes;
        uint32 rxPackets, rxBytes, rxErrors;
        uint32 drops;
        union {
                struct {
                        uint16 pppoeSessionId__;
                } pppoe;
                struct {
                        uint16 callId__;
                        uint16 peerCallId__;
                        uint32 lastSeq__;
                        uint32 lastAck__;
                        uint32 delta__;
                        uint32 lastReceiveSeq__;
                        ipaddr_t serverIp__;
                        ipaddr_t defaultGwIp__;
                        uint8* greBuf1__;
                        uint8* greBuf2__;
                        uint8 greOffset2__;
                } pptp;
                struct {
                        uint16 tunnelId__;
                        uint16 l2tpSessionId__;
                        ipaddr_t serverIp__;
                        ipaddr_t defaultGwIp__;
                        uint8* l2tpBuf1__;
                        uint8 l2tpLengthBit__;
                        uint8 l2tpOffset__;
                        uint8 l2tpBuf1State__;
                        uint8* l2tpBuf2__;
                        uint8 l2tpOffset2__;
                } l2tp;
        } un;
} rtl8651_tblDrv_pppTable_t;
# 137 "rtl8651_layer3local.h"
typedef struct rtl8651_tblDrvSession_s {
        rtl8651_tblDrv_pppTable_t *session_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        struct { struct rtl8651_tblDrvSession_s *tqe_next; struct rtl8651_tblDrvSession_s **tqe_prev; } nextSession;
} rtl8651_tblDrvSession_t;





typedef struct rtl8651_tblDrv_arpEntry_s {
        ipaddr_t ipAddr;
        rtl8651_tblDrv_filterDbTableEntry_t * macInfo;
        uint32 routingTablePos;
        uint16 vid;
        uint32
                        fromDrv:1,
                        fromApp:1,
                        dmzIpPending:1,
                        isBcArp:1,
                        routeAllocated:1;
        uint32 age;
        struct { struct rtl8651_tblDrv_arpEntry_s *sle_next; } next;
} rtl8651_tblDrv_arpEntry_t;


typedef struct rtl8651_tblDrv_ipIntfEntry_s {
        ipaddr_t ipMask;
        uint32 arpAllocated:1,
                        routeAllocated:1,
                        lanSideExternal:1,
                        networkType:3;
        uint32 arpStartPos, arpEndPos;
        uint32 routingTablePos;
        struct rtl8651_tblDrv_ipUnnumbered_s *ipUnnumber;
        struct { struct rtl8651_tblDrv_ipIntfIpAddrEntry_s *slh_first; } ipAddr;
        struct { struct rtl8651_tblDrv_ipIntfIpAddrEntry_s *slh_first; } localServer;
        struct { struct rtl8651_tblDrv_ipIntfEntry_s *sle_next; } nextIp;
        struct { struct rtl8651_tblDrv_arpEntry_s *slh_first; } nextArp;
} rtl8651_tblDrv_ipIntfEntry_t;

typedef struct rtl8651_tblDrv_natEntry_s {
        ipaddr_t localIp;
        ipaddr_t globalIp;
        struct { struct rtl8651_tblDrv_natEntry_s *sle_next; } nextNatEntry;
} rtl8651_tblDrv_natEntry_t;




struct rtl8651_tblDrv_ipEntry_s;
typedef struct rtl8651_tblDrv_nextHopEntry_s {
        uint16 dvid;
        uint16 nextHopType:3,
                        rt_flag:1,
                        valid:1,
                        v:1;
        uint32 refcount;
        uint32 entryIndex;
        ipaddr_t nexthop;
        void *nexthop_t;
        struct rtl8651_tblDrv_ipEntry_s *ip_t;
        struct { struct rtl8651_tblDrv_nextHopEntry_s *sle_next; } next;
} rtl8651_tblDrv_nextHopEntry_t;
# 222 "rtl8651_layer3local.h"
typedef struct rtl8651_ipUnnumbered_ctrlBlock_s {
        uint32 ip_unnumber_LS_budget;
        uint32 ip_unnumber_ACL_budget;
} rtl8651_ipUnnumbered_ctrlBlock_t;


typedef struct rtl8651_tblDrv_ipUnnumbered_s {
        ipaddr_t ipAddr;
        ipaddr_t ipMask;

        uint32 ip_as_LS;
        uint8 ip_as_ACL_budget;
        rtl8651_tblDrv_ipIntfEntry_t *ipIntf_t;
        struct { struct rtl8651_tblDrv_ipUnnumbered_s *sle_next; } nextIpUnnumberEntry;
} rtl8651_tblDrv_ipUnnumbered_t;
# 249 "rtl8651_layer3local.h"
typedef struct rtl8651_tblDrv_ipEntry_s {
        ipaddr_t intip;
        ipaddr_t extip;
        uint32 type:2,
                                def_flag:1,
                                valid:1;
        uint32 ref_cnt;
        struct rtl8651_tblDrv_nextHopEntry_s *nextHop_t;
} rtl8651_tblDrv_ipEntry_t;
# 278 "rtl8651_layer3local.h"
struct rtl8651_tblDrv_rateLimit_s;
typedef struct rtl8651_tblDrv_networkIntfTable_s {
        int8 ifName[16];
        uint16 vid;
        uint32 valid:1,
                        flag:1,



                        linkLayerType:3;
        uint32 pppoeAge;
        uint16 mtu;
        int8 defAclAction;
        ipaddr_t netMask;
        struct { struct rtl8651_tblDrv_ipIntfEntry_s *slh_first; } IpHead;
        struct { struct rtl8651_tblDrv_natEntry_s *slh_first; } nextNat;
        struct { struct rtl8651_tblDrv_naptServerPortEntry_s *slh_first; } nextNaptServerPort;
        struct { struct rtl8651_tblDrvSession_s *tqh_first; struct rtl8651_tblDrvSession_s **tqh_last; int tqh_count;} sessionHead;
        struct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} inAclHead;
        struct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} outAclHead;
        struct { struct _rtl8651_tblDrvPolicy_s *tqh_first; struct _rtl8651_tblDrvPolicy_s **tqh_last; int tqh_count;} policyQosHead;
        struct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} inRateLimitHead;
        struct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} outRateLimitHead;
        struct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} mnqHead;
} rtl8651_tblDrv_networkIntfTable_t;
# 311 "rtl8651_layer3local.h"
struct rtl8651_tblDrv_policyRoute_s;
typedef struct rtl8651_tblDrv_routeTable_s {
        ipaddr_t ipAddr;
        ipaddr_t ipMask;
        ipaddr_t nextHop;
        uint32 process:4,
                                ifrt_flag:1,
                                nextHopType:5,
                                ipClass:1,
                                valid:1;
        uint16 dvid;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;


        union {
                struct {
                        uint32 arpsta;
                        uint32 arpend;
                } arp;
                struct {
                        union {
                                struct {
                                        rtl8651_tblDrv_arpEntry_t *arp_t;
                                } direct;
                                struct {
                                        rtl8651_tblDrv_pppTable_t *session_t;
                                } session;
                        } un1;
                        rtl8651_tblDrv_nextHopEntry_t *start_t;
                        rtl8651_tblDrv_nextHopEntry_t *end_t;
                        rtl8651_tblDrv_nextHopEntry_t *next_t;
                        uint8 nhalog;
                        uint8 ipDomain;
                } nxthop;
                struct {
                        struct rtl8651_tblDrv_policyRoute_s *policy_t;
                } policy;
        } un;
        rtl8651_tblDrv_nextHopEntry_t *rt_nexthop_t;
} rtl8651_tblDrv_routeTable_t;
# 406 "rtl8651_layer3local.h"
typedef struct ipClassABMonitorTable_s {
        ipaddr_t dip;
        uint32 value;
        rtl8651_tblDrv_arpEntry_t *arp_t;
} ipClassABMonitorTable_t;
# 421 "rtl8651_layer3local.h"
typedef struct rtl8651_tblDrv_arpAsicArrangementEntry_s {
        int16 valid;
} rtl8651_tblDrv_arpAsicArrangementEntry_t;
# 435 "rtl8651_layer3local.h"
typedef struct _rtl8651_tblDrvPolicy_s {
        uint32 proto;
        ipaddr_t sip, sipMask,
                                dip, dipMask;
        uint16 sport_start, sport_end,
                                dport_start, dport_end;
        ipaddr_t naptip;


        rtl8651_tblDrv_nextHopEntry_t *nexthop_t;
        rtl8651_tblDrv_pppTable_t *pppoe_t;
        int32 (*p_handler)(uint32);

        struct { struct _rtl8651_tblDrvPolicy_s *cqe_next; struct _rtl8651_tblDrvPolicy_s *cqe_prev; } nextTime_t;
        struct { struct _rtl8651_tblDrvPolicy_s *tqe_next; struct _rtl8651_tblDrvPolicy_s **tqe_prev; } nextPolicy_t;
} _rtl8651_tblDrvPolicy_t;

typedef struct _rtl8651_tblDrvDynamicPolicy_s {
        _rtl8651_tblDrvPolicy_t *policy_t;
        struct { struct _rtl8651_tblDrvPolicy_s *tqh_first; struct _rtl8651_tblDrvPolicy_s **tqh_last; } *hashTable;
        struct { struct _rtl8651_tblDrvPolicy_s *cqh_first; struct _rtl8651_tblDrvPolicy_s *cqh_last; } dyHead;
} _rtl8651_tblDrvDynamicPolicy_t;





int32 _rtl8651_addPolicyRoute(rtl8651_tblDrvPolicyRoute_t *rtAdd, uint32 dynamicPolicyRtAge);
# 475 "rtl8651_layer3local.h"
typedef struct rtl8651_tblDrv_mCast_s {
        ipaddr_t sip;
        ipaddr_t dip;
        uint16 svid;
        uint16 port;
        uint32 mbr;
        uint16 age;
        uint16 cpu;
        rtl8651_tblDrv_ipEntry_t *ipEntry_t;
        uint32 vlanMask;
        uint32 count;
        uint32 flag;
        uint32 inAsic;
        struct { struct rtl8651_tblDrv_mCast_s *tqe_next; struct rtl8651_tblDrv_mCast_s **tqe_prev; } nextMCast;
} rtl8651_tblDrv_mCast_t;






typedef struct rtl8651_tblDrv_macACEntry_s {
        ether_addr_t mac;
        ether_addr_t macMask;
        uint32 actionType;
        struct { struct rtl8651_tblDrv_macACEntry_s *tqe_next; struct rtl8651_tblDrv_macACEntry_s **tqe_prev; } nextMAC;
} rtl8651_tblDrv_macACEntry_t;


typedef struct rtl8651_tblDrv_macContrl_s {
        uint16 def_permit;
        uint16 enable;
        struct { struct rtl8651_tblDrv_macACEntry_s *tqh_first; struct rtl8651_tblDrv_macACEntry_s **tqh_last; int tqh_count;} macAccessControl;
} rtl8651_tblDrv_macContrl_t;
# 519 "rtl8651_layer3local.h"
typedef struct rtl8651_tblDrv_rateLimit_s {




        uint32 maxToken;
        uint32 rateMappedToken;



        uint32 lastConfigToken;
        uint32 sliceIncrementToken;
        uint32 accumulatedToken;
        uint32 vRate;
        int32 eagerCounter;

        uint32 isByteCount;
        uint32 addToken;
        uint32 interval;

        uint32 groupId;
        uint8 queueType;
        uint8 dscp;
        uint8 mark;
        uint8 nQueueNeedProcess;
        uint32 ref_count;
        uint32 ratio;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
} rtl8651_tblDrv_rateLimit_t;
# 561 "rtl8651_layer3local.h"
typedef struct rtl8651_tblDrv_rateLimitCounter_s {
        uint8 valid;
        uint8 counterType;
        uint32 rateLimitIndex;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
} rtl8651_tblDrv_rateLimitCounter_t;






typedef struct rtl8651_tblDrv_mnqueue_sys_s {
        uint32 wanBandwidth;
        uint32 mVRate, mEVRate, nVRate;
        uint32 nAvailableRate;
        uint32 eagerNQueueNumber, nQueueNumber;
} rtl8651_tblDrv_mnqueue_sys_t;



rtl8651_tblDrv_networkIntfTable_t *GET_NETWORK_INTERFACE(int8 *ifname, uint32 *ifIdx);





typedef struct rtl8651_tblDrv_protocolBasedNat_s
{
        uint8 protocol;
        ipaddr_t ExtIp;
        ipaddr_t IntIp;

        struct { struct rtl8651_tblDrv_protocolBasedNat_s *sle_next; } next;
} rtl8651_tblDrv_protocolBasedNat_t;
# 34 "rtl8651_tblDrvLocal.h" 2
# 1 "rtl8651_layer4local.h" 1
# 21 "rtl8651_layer4local.h"
struct ip;
struct rtl_pktHdr;





typedef struct rtl8651_tblDrv_global_s {
        uint32 icmpTimeout;
        uint32 icmpFastTimeout;
        uint32 udpTimeout;
        uint32 tcpLongTimeout;
        uint32 tcpMediumTimeout;
        uint32 tcpFastTimeout;
        uint32 tcpFinTimeout;
        uint16 l4PortRangeStart, l4PortRangeEnd;
        uint16 l4NaptFindEmptyAsicRetry;
} rtl8651_tblDrv_global_t;

typedef struct rtl8651_tblDrv_naptServerPortEntry_s {
        ipaddr_t localIp;
        ipaddr_t globalIp;
        uint16 localPort, globalPort;
        uint16 endLocalPort, endGlobalPort;
        uint32 asicTablePos;
        uint32 tcp:1,
                        udp:1,
                        toAsic:1;
        struct { struct rtl8651_tblDrv_naptServerPortEntry_s *sle_next; } nextServerPort;
} rtl8651_tblDrv_naptServerPortEntry_t;



typedef struct rtl8651DmzHostStruct_s {





        ipaddr_t naptIp[6];
        ipaddr_t dmzHost[6];
} rtl8651DmzHostStruct_t;


typedef int32 (*alg_funcptr_t)(struct rtl_pktHdr * , struct ip*, struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
typedef struct rtl8651_tblDrv_algEntry_s {
        uint16 startPort, endPort;
        uint32 tcpServer:1,
                        tcpClient:1,
                        udpServer:1,
                        udpClient:1,

                        toAsic:1,

                        fwEngAdd:1;



        alg_funcptr_t alg_outboundClientcb;
        alg_funcptr_t alg_outboundServercb;
        alg_funcptr_t alg_inboundClientcb;
        alg_funcptr_t alg_inboundServercb;


        struct { struct rtl8651_tblDrv_algEntry_s *sle_next; } nextAlgEntry;
} rtl8651_tblDrv_algEntry_t;



struct l4ack_data_record
{
        uint32 ack_old;
        uint32 ack_new;
        int32 delta;
        int32 active;
};
# 113 "rtl8651_layer4local.h"
typedef struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s {
        ipaddr_t insideLocalIpAddr;
        ipaddr_t insideGlobalIpAddr;
        ipaddr_t dstIpAddr;
        uint16 insideLocalPort;
        uint16 insideGlobalPort;
        uint16 dstPort;

        uint16 alive:1;
        uint16 tcp:1;
        uint16 hashing:2;
        uint16 tcpFlag:3;
        uint16 quiet:1;
        uint16 fromDrv:1;

        uint16 col1:1;
        uint16 col2:1;
        uint16 isStatic:1;
        uint16 asicSnapshot:1;



        uint16 pureSoftware:1;
        uint16 interfaceRoute:1;
        uint16 newlyAddedHash2Udp:1;
        uint16 holdForCdrouter:1;

        uint16 urlFiltered:1;

        uint16 connectionType:2;
        uint16 toProtocolStack:1;
        uint16 dosEnCount:1;
        uint16 dosFromInternal:1;




        uint32 age;
        int16 outboundTblIdx;
        int16 inboundTblIdx;
        uint32 pps;
        uint16 createTimeStamp;
        uint8 outListType:4;
        uint8 inListType:4;
        uint16 selEIdx;

        int8 inExtIpIdx;
        int8 outExtIpIdx;


        uint8 tcpStateINdex:4;
        uint8 tcpAckModified:1;
        uint8 tcpFtpLastLineCRLFTermed:1;
        uint8 natlink:1;
        uint8 h245tunnel:1;

        int32 (*alg_client_in)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
        int32 (*alg_client_out)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
        int32 (*alg_server_in)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);
        int32 (*alg_server_out)(struct rtl_pktHdr *, struct ip *,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *);

        struct l4ack_data_record ack[2];



        void *out_rt_t;
        void *in_rt_t;
        void *out_macInfo_t;
        void *in_macInfo_t;
        uint8 dsid;


        struct { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *sle_next; } nextOut;
        struct { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *sle_next; } nextIn;
        struct { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tqe_next; struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **tqe_prev; } next;
} rtl8651_tblDrv_naptTcpUdpFlowEntry_t;
# 215 "rtl8651_layer4local.h"
struct naptEntryListHead {
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *slh_first;
};


typedef struct rtl8651DrvNaptLine_s {
        uint8 forcedCollision1:1;
        uint8 forcedCollision2:1;
        struct naptEntryListHead list[8];
} rtl8651DrvNaptLine_t;
# 234 "rtl8651_layer4local.h"
typedef struct rtl8651_tblDrv_naptIcmpFlowEntry_s {
        ipaddr_t insideLocalIpAddr;
        ipaddr_t insideGlobalIpAddr;
        ipaddr_t dstIpAddr;
        uint16 insideLocalId;
        uint16 insideGlobalId;
        uint32 age;
        uint16 count;


        uint32 staticEntry:1,
                        protoDel:1,
                        alive:1,
                        toAsic:1,
                        fromAsic:1,
                        fromDrv:1,
                        canAsic:1;


        uint8 dsid;



        struct rtl8651_tblDrv_naptIcmpFlowEntry_s * next;
} rtl8651_tblDrv_naptIcmpFlowEntry_t;

typedef struct rtl8651_tblDrv_serverPortAsicArrangementEntry_s {
        uint16 valid:1;
        rtl8651_tblDrv_naptServerPortEntry_t *servPort_t;
} rtl8651_tblDrv_serverPortAsicArrangementEntry_t;

typedef struct rtl8651_tblDrv_algAsicArrangementEntry_s {
        uint16 port;
        uint16 valid:1;
} rtl8651_tblDrv_algAsicArrangementEntry_t;
# 277 "rtl8651_layer4local.h"
typedef struct urlPktFiltering_s {

        uint32 rule_type;


        ipaddr_t sip_start;
        ipaddr_t sip_end;


        ether_addr_t smac;


        struct { struct urlPktFiltering_s *sle_next; } nextUse;
        struct { struct urlPktFiltering_s *sle_next; } next;
} urlPktFiltering_t;

typedef void (*urlFiltering_CallBackFunc_t)(uint32 sessionId, struct rtl_pktHdr *pkt, struct ip *iphdr, const char *urlFiltered, const char *pathFiltered);


typedef struct urlFiltering_s {

        int32 urlFilterCount;
        uint16 urlHdrJmpTbl[256];
        uint16 urlHostJmpTbl[256];
        uint16 urlGetJmpTbl[256];
        uint16 urlGet1JmpTbl[256];
        uint16 urlhttpJmpTbl[256];
        uint16 pathGetJmpTbl[256];

        int8 **urlFilterDB;
        int8 **pathFilterDB;
        uint16 **urlFilterJmpTbl;
        uint16 **pathFilterJmpTbl;
        int32 *urlFilterStrLen;
        int32 *pathFilterStrLen;
        uint32 *sessionId;
        uint8 *urlExactlyMatch;
        uint8 *pathExactlyMatch;
        int8 urlString[128];

        int8 log_pathString[128];
        int8 log_urlFilterString[128];
        int8 log_pathFilterString[128];



        uint8 *ruleType;


        urlFiltering_CallBackFunc_t callBackFunc;

        struct { struct urlPktFiltering_s *slh_first; } pktFilter[256];
} urlFiltering_t;


typedef struct _rtl8651_sessionHangUp_s {
        uint32 last_received;
        uint32 last_transmit;
        uint32 idletime_limit;




        int32 (*p_callBack)(uint32);





        uint32 sessionID;


} _rtl8651_sessionHangUp_t;
# 35 "rtl8651_tblDrvLocal.h" 2
# 44 "rtl8651_tblDrvLocal.h"
struct rtl8651_driverTables {


        rtl8651_tblDrv_ethernet_t *phyPort;
        rtl8651_tblDrv_linkAggregation_t *aggregator;
        rtl8651_tblDrv_filterDbTable_t *filterDB;
        rtl8651_tblDrv_spanningTreeTable_t *spanningTree;

        rtl8651_tblDrv_vlanTable_t *vlan;



        rtl8651_tblDrv_networkIntfTable_t *netIface;
        rtl8651_tblDrv_routeTable_t *route;
        rtl8651_tblDrv_ipEntry_t *iptbl;

        rtl8651_tblDrv_naptIcmpFlowEntry_t **icmp;
        rtl8651DrvNaptLine_t * tcpudp;

        _rtl8651_tblDrvDynamicPolicy_t dynamicPolicy;
        rtl8651_tblDrv_pppTable_t *pppoe;
        rtl8651_tblDrv_pppTable_t *pptp;
        rtl8651_tblDrv_pppTable_t *l2tp;

        rtl8651_tblDrv_macContrl_t *macACInfo;
        rtl8651_tblDrv_rateLimit_t *rateLimit;
        rtl8651_tblDrv_nextHopEntry_t *nhtbl;



        struct freeEntryList_s {

                struct _FreeFDBEntry { struct rtl8651_tblDrv_filterDbTableEntry_s *slh_first; } filterDBentry;
                struct _FreeAclEntry_t { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} aclRule;
                struct _FreeMACAccessEntry { struct rtl8651_tblDrv_macACEntry_s *tqh_first; struct rtl8651_tblDrv_macACEntry_s **tqh_last; int tqh_count;} freeMacAccessControl;
                struct _FreeArpEntry { struct rtl8651_tblDrv_arpEntry_s *slh_first; int slh_count;} arp;
                struct _FreeIpIfaceEntry { struct rtl8651_tblDrv_ipIntfEntry_s *slh_first; } ipIface;
                struct _FreeIpAddrEntry { struct rtl8651_tblDrv_ipIntfIpAddrEntry_s *slh_first; } ipAddr;
                struct _FreeNatEntry { struct rtl8651_tblDrv_natEntry_s *slh_first; } natMapping;

                struct _FreeAlgEntry { struct rtl8651_tblDrv_algEntry_s *slh_first; } alg;
                struct _FreeAlgSlot { struct rtl8651_tblDrv_algSlot_t *slh_first; int slh_count;} asicAlgSlot;
                struct _FreeServerPortEntry { struct rtl8651_tblDrv_naptServerPortEntry_s *slh_first; } serverPort;
                rtl8651_tblDrv_naptIcmpFlowEntry_t *icmp;
                struct _FreeNaptEntry { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tqh_first; struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **tqh_last; int tqh_count;} tcpudp;

                struct _FreeSessionEntry { struct rtl8651_tblDrvSession_s *tqh_first; struct rtl8651_tblDrvSession_s **tqh_last; } freeSession;

                struct _FreePolicyEntry { struct _rtl8651_tblDrvPolicy_s *tqh_first; struct _rtl8651_tblDrvPolicy_s **tqh_last; } freePolicy;
                struct _FreeMultiCastEntry { struct rtl8651_tblDrv_mCast_s *tqh_first; struct rtl8651_tblDrv_mCast_s **tqh_last; } freeMultiCast;

                struct _FreeProtocolBasedNat { struct rtl8651_tblDrv_protocolBasedNat_s *slh_first; } protocolBasedNat;
                struct _FreeNextHopEntry { struct rtl8651_tblDrv_nextHopEntry_s *slh_first; } nexthop;

                struct _FreeIpUnnumberEntry { struct rtl8651_tblDrv_ipUnnumbered_s *slh_first; } freeIpUnnumber;

                struct _FreeUrlPktFilterEntry { struct urlPktFiltering_s *slh_first; } freeUrlPktFilter;
        } freeList;

        struct inuseEntryList_s {
                struct _InuseAlgEntry { struct rtl8651_tblDrv_algEntry_s *slh_first; } alg;
                struct _InuseNaptEntry { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tqh_first; struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **tqh_last; int tqh_count;} tcpudp;


                struct _InusePolicyEntry { struct _rtl8651_tblDrvPolicy_s *tqh_first; struct _rtl8651_tblDrvPolicy_s **tqh_last; } policyRoute;


                struct _InuseMCast { struct rtl8651_tblDrv_mCast_s *tqh_first; struct rtl8651_tblDrv_mCast_s **tqh_last; } *mCastTbl;
                struct _InuseProtocolBasedNat { struct rtl8651_tblDrv_protocolBasedNat_s *slh_first; } protocolBasedNat;
                struct _InuseNextHopEntry { struct rtl8651_tblDrv_nextHopEntry_s *slh_first; } nexthop;

                struct _InuseIpUnnumberEntry { struct rtl8651_tblDrv_ipUnnumbered_s *slh_first; } ipUnnumber;

                struct _InuseUrlPktFilterEntry { struct urlPktFiltering_s *slh_first; } urlPktFilter;
        } inuseList;

};

struct AsicTableUsage_S{
        rtl8651_tblDrv_macAddressEntry_t * mac;

        rtl8651_tblDrv_arpAsicArrangementEntry_t * arp;

        rtl8651_tblDrv_serverPortAsicArrangementEntry_t *serverPort;
        rtl8651_tblDrv_algAsicArrangementEntry_t *alg;


};






extern rtl8651_tblDrv_global_t rtl8651GlobalControl;
extern void (*rtl8651_linkStatusNotifier)(uint32 port, int8 linkUp);
extern struct AsicTableUsage_S AsicTableUsage;
extern uint32 linkChangePendingCount;
extern int32 miiPhyAddress;
extern rtl8651_tblAsic_ethernet_t rtl8651AsicEthernetTable[9];
extern rtl8651_tblDrvInitPara_t rtl8651_tblDrvPara;
extern uint32 arpAgingTime;
extern struct rtl8651_driverTables DrvTbl;
extern uint32 *_loggingModule;
extern int8 pureSoftFwd;
extern void (* rtl8651_tblDrvFwdSend)(void * data);
extern ether_addr_t cachedDA;
extern uint32 phyPortLinkStatus;
extern struct rtl8651_driverTables DrvTbl;
extern uint32 _sysUpSeconds;

extern int32 (*p_mtuHandler)(struct rtl_pktHdr *);
extern int32 rtl8651_mss;
extern uint16 pppoe_mss[];

extern int32 _urlFilterAclRuleNum;

extern uint32 rtl8651_externalMulticastPortMask;


extern uint32 rtl8651_tblDrvSpanningTreeEnable;
extern uint32 rtl8651_tblDrvSpanningTreePortFwdStatus;


extern _rtl8651_sessionHangUp_t rtl8651_sessionHangUp[2];


extern urlFiltering_t _urlFilter;
# 212 "rtl8651_tblDrvLocal.h"
int32 _rtl8651_findUrlFiltering(rtl8651_tblDrv_urlFilter_t *urlFilter);

int32 rtl8651_fwdEngineL2Input(struct rtl_pktHdr *pkthdrPtr,rtl8651_tblDrv_vlanTable_t *local_vlanp, uint8 *m_data, uint16 ethtype);
int32 _rtl8651_delVlanRefFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr);
int8 * _strncpy(int8 *dst0, const int8 *src0, int32 count);
int32 _strncmp(const int8 *s1, const int8 *s2, int32 n);


rtl8651_tblDrv_ipEntry_t *_rtl8651_getIPTableEntry(ipaddr_t extip, ipaddr_t intip, uint8 attr);
rtl8651_tblDrv_arpEntry_t * _rtl8651_getArpEntry(rtl8651_tblDrv_networkIntfTable_t *netif_t, ipaddr_t ipAddr, int8 isRefresh);
rtl8651_tblDrv_networkIntfTable_t * _rtl8651_getNetworkIntfEntryByAddr(ipaddr_t ipAddr);
rtl8651_tblDrv_networkIntfTable_t * _rtl8651_getNetworkIntfEntryByVid(uint16 vid);
rtl8651_tblDrv_ipIntfEntry_t * _rtl8651_getIpIntfEntryByAddr(ipaddr_t ipAddr);
int32 _rtl8651_addLocalArp(int8 fromDrv, ipaddr_t ipAddr, ether_addr_t * macAddr, rtl8651_tblDrv_networkIntfTable_t *netIfPtr, uint32 port);
int8 _rtl8651_addLocalArpSpecifyNetworkInterface(int8 fromDrv, ipaddr_t ipAddr, ether_addr_t * macAddr, rtl8651_tblDrv_networkIntfTable_t * netIntfPtr, uint32 port);
int8 _rtl8651_getNetworkIntfLinkLayerType(int8 *ifName, uint32 *llType, uint32 *llIndex);
int8 _rtl8651_extIpAddr(ipaddr_t ipAddr, uint32 *netIdx);
int8 _rtl8651_extNetIpAddr(ipaddr_t ipAddr, uint32 *netIdx);
int8 _rtl8651_localServerIpAddr(ipaddr_t ipAddr);
int8 _rtl8651_intIpAddr(ipaddr_t ipAddr);
int8 _rtl8651_intNetIpAddr(ipaddr_t ipAddr);
int8 _rtl8651_isInternal(uint16 vid);
int32 _rtl8651_queryProtoTrap(uint8 protoType, uint16 protoContent);
int8 _rtl8651_getUsableExtIpAndPort(int8 , ipaddr_t , uint16 , ipaddr_t , uint16 , ipaddr_t *, uint16 *);
int8 _rtl8651_getIcmpUsableExtIpAndID(ipaddr_t sip, uint16 sID, ipaddr_t dip, ipaddr_t *gip, uint16 *gID);
int8 _rtl8651_getAllNatMapping(int32 *entry, rtl8651_tblDrv_natEntry_t *natMap);
int8 _rtl8651_getAllServerPort(int32 *entry, rtl8651_tblDrv_naptServerPortEntry_t *serverPort);
int8 _rtl8651_getUsableExtIpAndPort(int8 isTcp, ipaddr_t sip, uint16 sport, ipaddr_t dip, uint16 dport, ipaddr_t *extip, uint16 *extport);
int8 _rtl8651_getVIDByGWIpAddr(ipaddr_t gwIpAddr, uint32 *vid);
rtl8651_tblDrv_naptTcpUdpFlowEntry_t * _rtl8651_addNaptAlgConnection(int8 force, int8 flowType, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort, ipaddr_t dstIpAddr, uint16 dstPort);
int32 _rtl8651_addNaptConnection(int8 fromDrv, int16 assigned, int8 flowType, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                        ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort, ipaddr_t dstIpAddr, uint16 dstPort);
inline int32 _rtl8651_addAndGetNaptConnection(int8 fromDrv, int16 assigned, int8 flowType, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                        ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort, ipaddr_t dstIpAddr, uint16 dstPort,
                        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **ppe );
inline int32 _rtl8651_delNaptConnection( rtl8651_tblDrv_naptTcpUdpFlowEntry_t *delConn);
int32 _rtl8651_removeNaptConnectionByIP( ipaddr_t ip );
int32 _rtl8651_countNaptConnectionByIP( ipaddr_t ip, uint32 *tcpCnt, uint32 *udpCnt );
rtl8651_tblDrv_naptTcpUdpFlowEntry_t * _rtl8651_findNaptConnectionByExtIpPort( int8 isTcp, ipaddr_t ExtIp, uint16 ExtPort,
                                        ipaddr_t remoteIp, uint16 remotePort );
rtl8651_tblDrv_naptTcpUdpFlowEntry_t * _rtl8651_findNaptConnection( uint32 tblIndex, int8 isTcp, ipaddr_t intIp, uint16 intPort,
                                                          ipaddr_t remoteIp, uint16 remotePort );
int8 _rtl8651_addNaptIcmpCandidateFlow(int8 fromDrv, ipaddr_t insideLocalIpAddr, uint16 insideLocalId,
                        ipaddr_t insideGlobalIpAddr, uint16 insideGlobalId, ipaddr_t dstIpAddr);






        rtl8651_tblDrv_natEntry_t * _rtl8651_getNatExternalMappingEntry(ipaddr_t extIpAddr,struct rtl_pktHdr *phdr);
        rtl8651_tblDrv_natEntry_t * _rtl8651_getNatInternalMappingEntry(ipaddr_t intIpAddr,struct rtl_pktHdr *phdr);


rtl8651_tblDrv_naptServerPortEntry_t * _rtl8651_getOutsideNaptServerPortMapping(int8 isTcp, ipaddr_t extIpAddr, uint16 extPort);
rtl8651_tblDrv_naptServerPortEntry_t * _rtl8651_getInsideNaptServerPortMapping(int8 isTcp, ipaddr_t intIpAddr, uint16 intPort);
rtl8651_tblDrv_algEntry_t *_rtl8651_getAlgEntry(int8 isTcp, int8 *isServer, int8 *isClient, uint16 sport, uint16 eport);
rtl8651_tblDrv_routeTable_t * _rtl8651_getRoutingEntry(ipaddr_t dstIpAddr);
rtl8651_tblDrv_routeTable_t * _rtl8651_getSoftRoutingEntry(uint32,uint32,uint8,int);
int32 _rtl8651_getOutboundNaptFlow(int8 isTcp, ipaddr_t sip, uint16 sport, ipaddr_t dip, uint16 dport, struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **ppEntry);
int32 _rtl8651_getInboundNaptFlow(int8 isTcp, ipaddr_t gip, uint16 gport, ipaddr_t dip, uint16 dport, struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **ppEntry);
rtl8651_tblDrv_naptIcmpFlowEntry_t * _rtl8651_getInsideNaptIcmpEntry(ipaddr_t sip, uint16 sID, ipaddr_t dip, int8 isRefresh, int8 needFastFin);
rtl8651_tblDrv_naptIcmpFlowEntry_t * _rtl8651_getOutsideNaptIcmpEntry(ipaddr_t gip, uint16 gID, ipaddr_t dip, int8 isRefresh, int8 needFastFin);
void _rtl8651_collideNaptEntry(rtl8651DrvNaptLine_t *line,int32 *c1, int32 *c2);
_rtl8651_tblDrvAclRule_t * _rtl8651_aclLookUp(uint32 dsid,rtl8651_tblDrv_networkIntfTable_t *, int8 , uint32, int8 *, int8 *, int8 *, uint32, uint32);
int32 _rtl8651_getDefaultAcl(int8 *ifName, int8 *defAction);
rtl8651_tblDrv_pppTable_t *_rtl8651_getPppoeSessionByIpAddr(ipaddr_t ipaddr);
rtl8651_tblDrv_pppTable_t * _rtl8651_getPppoeSessionByPppoeSessionId(uint16 pppoeSessionId);
rtl8651_tblDrv_pppTable_t *_rtl8651_getPppoeSessionByDsid(uint32 dsid);
int32 _rtl8651_getDmzHost(uint32 dsid,ipaddr_t naptIp, ipaddr_t *dmzHostIp);
int32 _rtl8651_fromDmzHost(uint32 dsid, ipaddr_t dmzHostIp, ipaddr_t *naptIp);
int32 _rtl8651_isLocalBcastAddr(uint32 vid, ipaddr_t ipAddr);
int32 _rtl8651_enableDoS(uint32 dostype, int8 enable, uint32 vlanMask);
uint32 _rtl8651_SessionIDToDSID(uint32 SessionID);
int32 _rtl8651_urlFilter(uint32 dsid,struct rtl_pktHdr * phdr,struct ip * pip,uint8 dir, int8 * string,int32 * strlen);
 void _rtl8651_refillOrClearAsicNaptEntry(uint32 tblIdx,struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * selectedRefillFlow);
 int32 _rtl8651_addVlanRefFilterDatabaseEntry(uint16 l2Type, uint16 fid, uint16 vid, ether_addr_t * macAddr, uint32 type, uint32 portMask);
 int32 _rtl8651_modifyVlanRefFilterDatabaseEntry(uint32 fid, ether_addr_t *mac, uint32 *memberPortMask, uint16 *process, uint32 *linkId, uint32 attr);
int32 _rtl8651_addVlanRefFilterDatabaseEntry(uint16 l2Type, uint16 fid, uint16 vid, ether_addr_t * macAddr, uint32 type, uint32 portMask) ;
 rtl8651_tblDrv_filterDbTableEntry_t * _rtl8651_getVlanFilterDatabaseEntry(uint16 vid, ether_addr_t * macAddr);
void _rtl8651_removeArpAndNaptFlowWhenLinkDown(int32 port, uint32 *linkId) ;
void _rtl8651_removeArpByL2Entry(rtl8651_tblDrv_filterDbTableEntry_t *l2entry_t);


int32 _rtl8651_delVlanRefFilterDatabaseEntry(uint16 l2Type, uint16 fid, ether_addr_t * macAddr);

rtl8651_tblDrv_algEntry_t*_rtl8651_l4FindLinkAlg(uint16 , uint16 );

int32 _rtl8651_updateNaptConnection(struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *, int8 , uint32 );
int32 _rtl8651_getOutboundAlgConnection(int8 , ipaddr_t , uint16 , ipaddr_t , uint16 , struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **);

int32 _rtl8651_getPppoeTblPtr(uint32 pppoeId,rtl8651_tblDrv_pppTable_t ** pppoePtr_P);
void _rtl8651_naptTimerAdaptiveAdjust(int8 enabled, uint32 threshold, uint32 secPassed);
void _rtl8651_naptSmartFlowSwapByPPS(int8 enabled, uint32 threshold);
int32 _rtl8651_isMacAccessControlPermit(ether_addr_t *sMac);


int32 _rtl8651_setLanSideExternalIpInterface(rtl8651_tblDrv_networkIntfTable_t *netif_t, ipaddr_t ipAddr, ipaddr_t ipMask, int8 isExternal);
void _rtl8651_reArrangeLanSideExternalIpInterfacePatch(void);


void _rtl8651_arrangeMulticastPortStatus(void);

void _rtl8651_arrangeAllMulticast(void);
# 345 "rtl8651_tblDrvLocal.h"
extern uint32 _rtl8651_DefaultDialSessionId;






int32 _rtl8651_removeNaptConnectionByIntIPandPort( int8 isTcp, ipaddr_t intIp, uint16 intPort );


extern uint32 tuRemind;
extern uint32 accJiffies;
extern uint32 timer1Sec;
# 371 "rtl8651_tblDrvLocal.h"
typedef int32 (*acldb_callback_t) (int32 , struct rtl_pktHdr *, struct ip *, void *);

struct rtl8651_ACLDB_s
{
        acldb_callback_t func;
        void *userDefined;
        uint32 count;
};
typedef struct rtl8651_ACLDB_s rtl8651_ACLDB_t;

extern rtl8651_ACLDB_t acldb[];

int32 _rtl8651_resetACLDB(void);
int32 _rtl8651_registerACLDB( int32 ruleNo,
                              acldb_callback_t func,
                              void *userDefined );
int32 _rtl8651_jumptoACLDB( int32 ruleNo, struct rtl_pktHdr *pkthdr, struct ip *pip );




int32 _rtl8651_addRateLimitCounter(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType);
int32 _rtl8651_delRateLimitCounter(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType);
int32 _rtl8651_getRateLimitCounter(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType, uint8 refill);
int32 _rtl8651_addRateLimitCounterRule(rtl8651_tblDrvAclRule_t *rule, rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType);
int32 _rtl8651_delRateLimitCounterRule(rtl8651_tblDrvAclRule_t *rule, rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType);
void _rtl8651_rateLimitCounterTimeUpdate(uint32 secpassed);
void _rtl8651_flushRateLimitCounter(void);

int32 _rtl8651_changeNaptIpAndPort( struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * thisFlow,
                                    ipaddr_t newIntIp, uint16 newIntPort,
                                    ipaddr_t newExtIp, uint16 newExtPort,
                                    ipaddr_t newRemIp, uint16 newRemPort
                                    );


rtl8651_tblDrv_networkIntfTable_t *_rtl8651_getIpInfo(ipaddr_t ipaddr, rtl8651_tblDrv_ipIntfEntry_t **ipintf_t, int8 *is_gip, int8 *is_gwip);


void _rtl8651_recordTraffic(int32 dsid, int32 isXmit);
int32 _rtl8651_setSessionHangUp(rtl8651_sessionHangUp_t *param);
# 183 "rtl8651_tblDrvFwdLocal.h" 2
# 1 "rtl8651_tblDrvFwd.h" 1
# 790 "rtl8651_tblDrvFwd.h"
typedef struct rtl8651_fwdEngineInitPara_s {

        uint32 MaxFragPktCnt;
        uint32 MaxFragSubPktCnt;
        uint32 MaxNegativeListEntryCnt;
        uint32 MaxPositiveListEntryCnt;
        uint32 MaxFragPoolCnt;
        uint32 MaxFragTimeOut;
        uint32 MaxNegativeListTimeOut;

        uint32 MCastDefaultVersion;
        uint32 MCastProcessOption;
        uint32 MaxMCastCnt;
        uint32 MaxMCastMemberCnt;
        uint32 MaxMCastTotalMemberCnt;
        uint32 MaxMCastTotalSourceCnt;
        uint32 MCastMember_ExpireTime;
        uint32 MCastUpstream_Timeout;
        uint32 MCastFilterEntryCnt;
        uint32 igmp_qi;
        uint32 igmp_qri;
        uint32 igmp_oqpi;
        uint32 igmp_sqc;
        uint32 igmp_sqi;
        uint32 igmp_lmqc;
        uint32 igmp_lmqi;
        uint32 igmp_gmi;
        uint32 igmp_group_query_interval;
        uint32 igmp_response_tolerance_delay;


        uint32 dos_SynFlood_trackCnt;
        uint32 dos_StealthFin_trackCnt;
        uint32 dos_UdpFlood_trackCnt;
        uint32 dos_IcmpFlood_trackCnt;
        uint32 dos_total_trackCnt;

        uint32 dos_total_portScan_trackCnt;

        uint32 dos_TcpConn_trackCnt;
        uint32 dos_UdpConn_trackCnt;
        uint32 dos_TcpUdpConn_trackCnt;
        uint32 dos_totalConn_trackCnt;

        uint32 dosProc_sipblock_count;

        uint32 pppoeActiveSessionTrackingNumber;
        uint32 mbufHeadroom;


        uint32 redirectTblSize;
        uint32 redirectFlowCacheSize;


        uint32 pptpHdrCacheSize;


        uint32 protoStackMaxActions;


        uint32 trappingPktDispatchTblSize;


        uint32 dns_dnsDB_processCnt;
        uint32 dns_dnsDB_tblSize;
        uint32 dns_dnsDB_cnameMapTblSize;
        uint32 dns_dnsDB_cnameMapTimeout;

        uint32 domainBlock_tblSize;
        uint32 domainBlock_maxBlockEntryCnt;
        uint32 domainBlock_blockEntryTimeout;



        uint32 triggerPortEntryCnt;
        uint32 triggerPortCacheSize;


} rtl8651_fwdEngineInitPara_t;




int32 rtl8651_fwdEngineInit(struct rtl8651_fwdEngineInitPara_s *);
int32 rtl8651_fwdEngineReinit(void);




int32 rtl8651_fwdEngineInput(void * pkthdr);
int32 rtl8651_fwdEngineExtPortRecv(void *id, uint8 *data, uint32 len, uint16 myvid, uint32 myportmask, uint32 linkId);




int32 rtl8651_fwdEngineDropPktCase(uint32 fwdengDropCase, int32 *flag);
int32 rtl8651_fwdEngineSend(void * pkthdr, int16 dvid, int32 iphdrOffset);
int32 rtl8651_fwdEngineQosSend(void *pkthdr, int16 dvid, int32 iphdrOffset, int32 qualityId);
int32 rtl8651_fwdEngineArp(int8 enable);
int32 rtl8651_fwdEngineIcmp(int8 enable);
int32 rtl8651_fwdEngineIcmpRoutingMsg(int8 enable);
int32 rtl8651_fwdEngineAlwaysReplyICMPErrForFragment(int8 enable);
int32 rtl8651_fwdEngineDMZHostIcmpPassThrough(int8 enable);
int32 rtl8651_fwdEngineArpProxy(int8 enable);
int32 rtl8651_fwdEngineProcessL34(int8 routingEnable);
int32 rtl8651_fwdEngineProcessIPFragment(int8 enable);
int32 rtl8651_fwdEngineProcessIPMulticast(int8 enable);
int32 rtl8651_fwdEnginePppoeNotExistedSessionTermination(int8 enable);
int32 rtl8651_fwdEngineProcessPortBouncing(int8 enable);
int32 rtl8651_fwdEngineProcessUpnpPortBouncing(int8 enable);
int32 rtl8651_fwdEngineEnableWDS(int32 flag);
int32 rtl8651_fwdEngineRemoveHostsOnExtLinkID(uint32 linkID);
int32 rtl8651_fwdEngineEnableWanRouting(int8 enable);
int32 rtl8651_fwdEngineFwdGeneralL4ToDMZ(int8 enable);
int32 rtl8651_fwdEngineFwdUnicastIGMPPkt(int8 enable);
int32 rtl8651_fwdEnginePortBouncingDoProtocolStackAction(int8 enable);
int32 rtl8651_fwdEngineTrapPktDemandRouteTrigger(int8 enable);


int32 rtl8651_fwdEngineInexactUdpFlow(int8 enable);

int32 rtl8651_fwdEngineUdpStaticNaptPortTranslation(int8 enable);
int32 rtl8651_fwdEngineTcpStaticNaptPortTranslation(int8 enable);



int32 rtl8651_fwdEngineWeakTcpNaptProcess(int8 enable);


int32 rtl8651_fwdEnginePsDontTimeout(int enable);
int32 rtl8651_fwdEnginePsToWanErrMsgDontTimeout(int enable);

int32 rtl8651_fwdEngineDynamicRemoteHostPolicyRT(int enable);




typedef int32 (*alg_funcptr)(struct rtl_pktHdr *pkthdr , void *ipheader, void *);
int32 rtl8651_fwdEngineRegisterAlgModule(uint16 , uint16 ,
        int32 (*alg_init)(void *),
        alg_funcptr alg_outboundClientcb,
        alg_funcptr alg_inboundClientcb,
        alg_funcptr alg_outboundServercb,
        alg_funcptr alg_inboundServercb
);
int32 rtl8651_fwdEngineRemoveAlgModule(uint16 , uint16 );


int32 rtl8651_fwdEngineAddWlanSTA(uint8 *smac,uint16 myvid, uint32 myportmask, uint32 linkId);
int32 rtl8651_fwdEngineDelWlanSTA(uint8 *mac,uint16 myvid);
int32 rtl8651_fwdEngineExtPortUcastFastRecv(struct rtl_pktHdr *pkt,uint16 myvid, uint32 myportmask);



typedef struct rtl8651_tblDrvFwdEngineCounts_s {
        uint32 arpReceive, arpAddSuccess, arpAddFail, arpDelete, arpReply, arpGenerate;
        uint32 ipReceive, ipErrorReceive;
        uint32 icmpReceive, icmpErrorReceive, icmpReply, icmpReplyFailed, icmpDrop, icmpSend;
        uint32 igmpReceive, igmpErrorReceive;
        uint32 udpReceive, udpErrorReceive,udpSend;
        uint32 tcpReceive, tcpErrorReceive,tcpSend;
        uint32 l34actionLookupFailed, l34actionFailed;
        uint32 pppoeDiscoveryReceive, pppoeDiscoveryProcessed;
        uint32 pppoeSessionReceive, pppoeSessionProcessed;
        uint32 inAclDrop, inAclPermit,inAclCpu;
        uint32 outAclDrop, outAclPermit, outAclCpu;
        uint32 dmzDrop;
        uint32 natdrop, wlan2lanRelay, lan2wlanRelay;
        uint32 dosDrop;
        uint32 fastFragUdpMeetCount, fastFragUdpMissCount;
} rtl8651_tblDrvFwdEngineCounts_t;
int32 rtl8651_getFwdEngineCounter(rtl8651_tblDrvFwdEngineCounts_t * counter);
# 975 "rtl8651_tblDrvFwd.h"
void rtl8651_addUpnpMap(uint32 ,ipaddr_t , uint16 , ipaddr_t , uint16 , ipaddr_t , uint16 );
void rtl8651_addUpnpMapLeaseTime(uint32, ipaddr_t, uint16, ipaddr_t, uint16, ipaddr_t, uint16,uint32);
void rtl8651_delUpnpMap(uint32 ,ipaddr_t , uint16 , ipaddr_t , uint16 , ipaddr_t , uint16 );
uint32 rtl8651_queryUpnpMapTimeAge(uint32, ipaddr_t, uint16 , ipaddr_t, uint16);







typedef struct _rtl8651_triggerPort_param_s
{
        uint8 isStaticMapping;
        uint32 age;

        union {
                struct {
                        uint8 __outType;
                        ipaddr_t __triggeringInsideLocalIpAddrStart;
                        ipaddr_t __triggeringInsideLocalIpAddrEnd;
                        uint16 __outPortStart;
                        uint16 __outPortEnd;
                } DYNAMIC_MAPPING;
                struct {
                        ipaddr_t __mappedInsideLocalIpAddr;
                        uint8 __isStatic;
                } STATIC_MAPPING;
        } UN_MAPPING;
# 1014 "rtl8651_tblDrvFwd.h"
}_rtl8651_triggerPort_param_t;



void rtl8651a_flushTriggerPortRules(uint32 netIntfId);
void rtl8651_flushTriggerPortRules(void);
int32 rtl8651a_addTriggerPortRule(uint32 netIntfId, uint8 inType, uint16 inPortStart, uint16 inPortEnd, uint8 outType,uint16 outPortStart,uint16 outPortEnd, ipaddr_t localIpAddr);
int32 rtl8651_addTriggerPortRule(uint8 inType, uint16 inPortStart, uint16 inPortEnd, uint8 outType,uint16 outPortStart,uint16 outPortEnd, ipaddr_t localIpAddr);



void rtl8651a_setUdpSizeThreshValue(uint32 dsid, uint32 value);
# 1036 "rtl8651_tblDrvFwd.h"
void rtl8651_flushProtoStackActions(void);
int32 rtl8651_addProtoStackActions(ipaddr_t ip,ipaddr_t mask,uint8 action,uint8 role,uint8 protocol,uint16 orgPort,uint16 fwdPort);
# 1050 "rtl8651_tblDrvFwd.h"
void rtl8651a_setUdpSizeThreshValue(uint32 SessionID, uint32 value);
# 1059 "rtl8651_tblDrvFwd.h"
int32 rtl8651_registerTrappingDispatchEntry(uint8 l4Proto, ipaddr_t srcIp, ipaddr_t dstIp, int32 srcPort, int32 dstPort, uint16 category);
int32 rtl8651_unregisterTrappingDispatchEntry(uint8 l4Proto, ipaddr_t srcIp, ipaddr_t dstIp, int32 srcPort, int32 dstPort);





int32 rtl8651_registerRedirectOutboundNaptFlow(
                uint8 isTcp,
                ipaddr_t sip,
                uint16 sport,
                ipaddr_t originalDip,
                uint16 originalDport,
                ipaddr_t newDip,
                int32 newDport
);
int32 rtl8651_unregisterRedirectOutboundNaptFlow(
                uint8 isTcp,
                ipaddr_t sip,
                uint16 sport,
                ipaddr_t originalDip,
                uint16 originalDport,
                ipaddr_t newDip,
                int32 newDport
);
int32 rtl8651_queryRedirectOutboundNaptFlow(
                uint8 isTcp,
                ipaddr_t sip,
                uint16 sport,
                ipaddr_t *pOriginalDip,
                uint16 *pOriginalDport,
                ipaddr_t newDip,
                uint16 newDport
);
int32 rtl8651_registerRedirectOutboundNaptExceptionList(
                uint8 isTcp,
                ipaddr_t sip,
                uint16 sport,
                ipaddr_t dip,
                uint16 dport
);
int32 rtl8651_unregisterRedirectOutboundNaptExceptionList(
                uint8 isTcp,
                ipaddr_t sip,
                uint16 sport,
                ipaddr_t dip,
                uint16 dport
);





int32 rtl8651_updateCounter1( void );






int32 rtl8651_offloadEngineL3Send(void * pPkt, uint32 L3PktLength, uint32 l34CkumOffload, int32 highPriority);
# 184 "rtl8651_tblDrvFwdLocal.h" 2
# 1 "rtl8651_ipQueue_local.h" 1
# 14 "rtl8651_ipQueue_local.h"
# 1 "rtl8651_tblDrvFwdLocal.h" 1
# 15 "rtl8651_ipQueue_local.h" 2
# 32 "rtl8651_ipQueue_local.h"
int32 _rtl8651_IpFragQueueInit(rtl8651_fwdEngineInitPara_t *para);



inline int32 _rtl8651_frag_NeedFragmentProcess(uint16 id, ipaddr_t sip, ipaddr_t dip, uint8 l4proto);
# 185 "rtl8651_tblDrvFwdLocal.h" 2
# 1 "rtl8651_multicast_local.h" 1
# 14 "rtl8651_multicast_local.h"
# 1 "assert.h" 1
# 15 "rtl8651_multicast_local.h" 2
# 24 "rtl8651_multicast_local.h"
# 1 "rtl8651_timer.h" 1





extern uint32 _sysUpSeconds;
# 246 "rtl8651_timer.h"
struct rtl8651_timer_list {
        struct list_head list;
        uint32 expires;
        uint32 data;
        void (*function)(uint32);
};

int _rtl8651_del_timer(struct rtl8651_timer_list * timer);
int _rtl8651_mod_timer(struct rtl8651_timer_list *timer, uint32 expires);
void _rtl8651_init_timer(struct rtl8651_timer_list * timer);
# 25 "rtl8651_multicast_local.h" 2


# 1 "rtl8651_multicast.h" 1
# 17 "rtl8651_multicast.h"
struct ip;
struct igmp;
# 58 "rtl8651_multicast.h"
typedef struct rtl8651_tblDrvMCastPara_s {
        uint32 MCastMember_ExpireTime;
        uint32 MCastUpstream_Timeout;
        uint32 igmp_qi;
        uint32 igmp_qri;
        uint32 igmp_oqpi;
        uint32 igmp_sqc;
        uint32 igmp_sqi;
        uint32 igmp_lmqc;
        uint32 igmp_lmqi;
        uint32 igmp_gmi;
        uint32 igmp_group_query_interval;
        uint32 igmp_response_tolerance_delay;
} rtl8651_tblDrvMCastPara_t;
# 91 "rtl8651_multicast.h"
void MCast_DumpMCast(void);

int32 rtl8651_multicast_AddFilter(ipaddr_t gip, uint32 action);
int32 rtl8651_multicast_RemoveFilter(ipaddr_t gip, uint32 action);



void rtl8651_multicastReinit(void);
void rtl8651_multicast_FilterReinit(void);
int32 rtl8651_multicastSetPara(rtl8651_tblDrvMCastPara_t *);
int32 rtl8651_multicastSetUpStream(int8*, uint32);
int32 rtl8651_multicastPeriodicQuery(int8 enable);
# 28 "rtl8651_multicast_local.h" 2
# 129 "rtl8651_multicast_local.h"
struct rtl8651_tblDrvMCastMember_s;
struct rtl8651_tblDrvMCast_s;
struct rtl8651_tblDrvMCastMember_s;


typedef struct rtl8651_tblDrvMCastSource_s {
        uint8 _type;

        ipaddr_t source;
        struct rtl8651_timer_list timer;

        struct rtl8651_tblDrvMCastMember_s * mbr;
        struct rtl8651_tblDrvMCastSource_s * prev;
        struct rtl8651_tblDrvMCastSource_s * next;
} rtl8651_tblDrvMCastSource_t;


typedef struct rtl8651_tblDrvMCastMember_s {
        uint8 _type;


        rtl8651_tblDrv_vlanTable_t * vlan;
        uint16 portMask;


        uint8 MulticastRouterVersion;
        struct rtl8651_timer_list timer_filterMode;
        struct rtl8651_timer_list timer_state;
        struct rtl8651_timer_list timer_query;
        struct rtl8651_timer_list timer_query_expire;
        uint8 state;
        uint8 remainingQuery;
        uint8 isForwarder;
        uint8 FilterMode;


        struct rtl8651_tblDrvMCast_s * m_entry;
        struct rtl8651_tblDrvMCastMember_s * prev;
        struct rtl8651_tblDrvMCastMember_s * next;
        struct rtl8651_tblDrvMCastSource_s * slist;
} rtl8651_tblDrvMCastMember_t;






typedef struct rtl8651_tblDrvMCast_s {
        uint8 _type;

        ipaddr_t mcast_addr;


        struct rtl8651_timer_list timer_upstream;
        rtl8651_tblDrv_vlanTable_t * up_vlan;
        uint16 up_portMask;
        uint8 MulticastRouterVersion;

        uint8 FilterMode;
        rtl8651_tblDrvMCastSource_t * slist;


        rtl8651_tblDrvMCastMember_t * member;
        uint32 memberCnt;


        struct rtl8651_tblDrvMCast_s * prev;
        struct rtl8651_tblDrvMCast_s * next;
} rtl8651_tblDrvMCast_t;





typedef struct rtl8651_tblDrvMCastRouteInfo_s {
        ipaddr_t m_addr;
        rtl8651_tblDrv_vlanTable_t *vlan;
        uint8 isPortMask;
        uint16 port;
        rtl8651_tblDrv_networkIntfTable_t *netif;
        uint32 ifInfo;
} rtl8651_tblDrvMCastRouteInfo_t;




typedef struct rtl8651_tblDrvMCastUpStreamInfo_s {
        uint8 isSet;
        rtl8651_tblDrv_networkIntfTable_t *netif;
        rtl8651_tblDrv_vlanTable_t *vlan;
        uint16 portMask;
        union {
                ipaddr_t intfIp;
                rtl8651_tblDrvSession_t *pppoesessionPtr;
                rtl8651_tblDrvSession_t *sessionPtr;
        } MUpStreamInfo_un;





} rtl8651_tblDrvMCastUpStreamInfo_t;




typedef struct rtl8651_tblDrvMCastGlobal_s {
        struct rtl8651_timer_list query_timer;
        uint8 remainingQuery;
        rtl8651_tblDrvMCastUpStreamInfo_t MCastUpStream;
} rtl8651_tblDrvMCastGlobal_t;





typedef struct rtl8651_tblDrvMCastFilter_s {
        ipaddr_t gip;
        uint32 action;

        struct rtl8651_tblDrvMCastFilter_s *next;
} rtl8651_tblDrvMCastFilter_t;
# 265 "rtl8651_multicast_local.h"
int32 _rtl8651_multicastInit(rtl8651_fwdEngineInitPara_t *);
int32 _rtl8651_multicast_FilterInit(rtl8651_fwdEngineInitPara_t *);



int32 _rtl8651_igmp_process(struct rtl_pktHdr *, struct ip *, struct igmp *);
int32 _rtl8651_multicast_process(struct rtl_pktHdr *, struct ip *);
int32 _rtl8651_multicast_Fastfwd(struct rtl_pktHdr *, struct ip *, rtl8651_tblDrv_vlanTable_t *);
# 186 "rtl8651_tblDrvFwdLocal.h" 2







enum _RTL8651_HOSTTYPE {
        _RTL8651_HOST_NPI = 0,
        _RTL8651_HOST_NI,
        _RTL8651_HOST_LP,
        _RTL8651_HOST_RP,
        _RTL8651_HOST_NPE,
        _RTL8651_HOST_NE,
        _RTL8651_HOST_MAX,
        _RTL8651_HOST_NONE,
};






enum _RTL8651_DECISIONTYPE {
        _RTL8651_DEC_NONE = 0,

        _RTL8651_DEC_RT_LR,
        _RTL8651_DEC_RT_RL,
        _RTL8651_DEC_RT_LNP,
        _RTL8651_DEC_RT_NPL,
        _RTL8651_DEC_RT_LN,
        _RTL8651_DEC_RT_NL,
        _RTL8651_DEC_RT_LL,
        _RTL8651_DEC_RT_NN,
        _RTL8651_DEC_RT_NPNP,
        _RTL8651_DEC_RT_NPN,
        _RTL8651_DEC_RT_NNP,
        _RTL8651_DEC_RT_RR,

        _RTL8651_DEC_NT,
        _RTL8651_DEC_NTR,
        _RTL8651_DEC_NTBC_NP,
        _RTL8651_DEC_NTBC_N,
        _RTL8651_DEC_NTBC_L,
        _RTL8651_DEC_NPT,
        _RTL8651_DEC_NPTR,
        _RTL8651_DEC_NPTBC_NP,
        _RTL8651_DEC_NPTBC_N,
        _RTL8651_DEC_NPTBC_L,

        _RTL8651_DEC_DP,

        _RTL8651_DEC_MAX
};
# 257 "rtl8651_tblDrvFwdLocal.h"
void _rtl8651_fwdEngineTimeUpdate(uint32 secPassed);




int32 _rtl8651_ingressAcl(uint32 dsid,uint32 startIdx, rtl8651_tblDrv_vlanTable_t *pVlan,int32 vid, uint8 *m_data, uint8 *ip, uint32 matchType, uint32 optLayer);
int32 _rtl8651_egressAcl(uint32 dsid,rtl8651_tblDrv_vlanTable_t *pVlan,int32 vid, uint8 *ethHdr, uint8 *ip);
# 273 "rtl8651_tblDrvFwdLocal.h"
int32 rtl8651_fwdEngineL2Input(struct rtl_pktHdr *pkthdrPtr,rtl8651_tblDrv_vlanTable_t *local_vlanp, uint8 *m_data, uint16 ethtype);
int32 _rtl8651_fwdEngineSend(uint32 property, void * data, int16 dvid, int32 iphdrOffset);




int32 _rtl8651_l3FastActRouting(uint32 property, struct rtl_pktHdr *pkthdrPtr, ipaddr_t dst_ip, struct ip *ip, void **);







typedef struct _rtl8651_l34AdditionalExec_s
{
        uint8 property;
} _rtl8651_l34AdditionalExec_t;


int32 _rtl8651_l34AdditionalExec_setParam(uint32 srcType, uint32 dstType, _rtl8651_l34AdditionalExec_t *para);

int32 _rtl8651_l34AdditionalExec_getParam(uint32 srcType, uint32 dstType, _rtl8651_l34AdditionalExec_t *para);
# 311 "rtl8651_tblDrvFwdLocal.h"
typedef struct _rtl8651_FragmentShortestPathFwdCache_s
{

        uint8 status;
        ipaddr_t sip;
        ipaddr_t dip;
        uint16 id;

        uint8 mode;
        ipaddr_t aliasIp;

        struct ether_addr smac;
        struct ether_addr dmac;
        uint16 vlanIdx;
        uint16 portList;
        uint8 extPortList;
        uint8 srcExtPortNum;
        uint16 pppoeIdx;
        uint16 flags;

        uint8 age;
} _rtl8651_FragmentShortestPathFwdCache_t;



inline void _rtl8651_fragmentShortestPathCacheSet_secondHalf(struct rtl_pktHdr *pkthdr, uint8 *m_data, struct ip*pip);
extern _rtl8651_FragmentShortestPathFwdCache_t fragmentShortestPathCache[32];






typedef struct _rtl8651_IcmpPktField_s{
        uint8 ic_type;
        uint8 ic_code;
        union{
                uint16 next_mtu;
        } ic_hun;

} _rtl8651_IcmpPktField_t;
int32 _rtl8651_drvIcmpErrorGeneration(struct rtl_pktHdr *, struct ip*, _rtl8651_IcmpPktField_t *, uint16);





struct _RTL8651_UPNP_ENTRY{
        ipaddr_t remote_ip;
        uint16 remote_port;
        ipaddr_t alias_ip;
        uint16 alias_port;
        ipaddr_t local_ip;
        uint16 local_port;

        uint32 flags;
        uint32 age;
        uint32 algIdx;
};
# 381 "rtl8651_tblDrvFwdLocal.h"
void _rtl8651_addAlgQosUpnpMap(uint32, ipaddr_t, uint16, ipaddr_t, uint16, ipaddr_t, uint16, uint32);
# 394 "rtl8651_tblDrvFwdLocal.h"
struct _rtl8651_triggerPort_cache_s;

typedef struct _rtl8651_triggerPort_entry_s
{
        uint32 netIntfId;

        uint8 inType;
        uint8 outType;
        uint16 inPortStart;
        uint16 inPortEnd;
        uint16 outPortStart;
        uint16 outPortEnd;
        ipaddr_t triggeringInsideLocalIpAddrStart;
        ipaddr_t triggeringInsideLocalIpAddrEnd;





        uint32 cacheAge;



        struct _rtl8651_triggerPort_entry_s **hdr;
        struct _rtl8651_triggerPort_entry_s *next;
        struct _rtl8651_triggerPort_entry_s *prev;


        struct _rtl8651_triggerPort_cache_s *normalCache;
} _rtl8651_triggerPort_entry_t;

typedef struct _rtl8651_triggerPort_cache_s
{
        uint32 netIntfId;
        ipaddr_t localIpAddr;
        ipaddr_t ExternalIpAddr;

        uint8 inType;
        uint16 inPortStart;
        uint16 inPortEnd;
# 450 "rtl8651_tblDrvFwdLocal.h"
        uint8 isStatic;
        uint32 age;
        uint32 maxAge;



        struct _rtl8651_triggerPort_cache_s **hdr;
        struct _rtl8651_triggerPort_cache_s *prev;
        struct _rtl8651_triggerPort_cache_s *next;


        struct _rtl8651_triggerPort_entry_s *entryHdr;
        struct _rtl8651_triggerPort_cache_s *entryList_prev;
        struct _rtl8651_triggerPort_cache_s *entryList_next;


        struct _rtl8651_triggerPort_cache_s *lru_prev;
        struct _rtl8651_triggerPort_cache_s *lru_next;

} _rtl8651_triggerPort_cache_t;
# 479 "rtl8651_tblDrvFwdLocal.h"
struct _RTL8651_PORT_BOUNCING_ENTRY{

        ipaddr_t clientIpAddr;
        ipaddr_t gatewayIpAddr;
        ipaddr_t serverIpAddr;
        uint16 clientPort;
        uint16 gatewayPort;
        uint16 serverPort;
        uint16 id;
        uint16 flowType;
        uint32 tcpFlag;
        uint32 age;
};
# 509 "rtl8651_tblDrvFwdLocal.h"
typedef struct _rtl8651_frag {

        ipaddr_t new_ip;
        int8 routeIdx;
        void *napt_entry_t;
        uint8 dsid;

        uint8 age;

        uint16 ip_id;
        ipaddr_t org_sip;
        ipaddr_t org_dip;
} _rtl8651_frag_t;





typedef struct _rtl8651_pppoeActiveSession_entry_s {
        uint16 sessionId;
        uint16 keepAlive;
        struct _rtl8651_pppoeActiveSession_entry_s * next;
} _rtl8651_pppoeActiveSession_entry_t;
# 545 "rtl8651_tblDrvFwdLocal.h"
extern rtl8651_fwdEngineInitPara_t rtl8651_fwdEnginePara;
# 567 "rtl8651_tblDrvFwdLocal.h"
typedef struct _rtl8651_trapping_dispatch_entry_s
{
        uint8 l4Proto;


        ipaddr_t srcIp;
        ipaddr_t dstIp;


        int32 srcPort;
        int32 dstPort;


        uint16 category;


        struct _rtl8651_trapping_dispatch_entry_s *prev;
        struct _rtl8651_trapping_dispatch_entry_s *next;
} _rtl8651_trapping_dispatch_entry_t;

typedef struct _rtl8651_trapping_dispatch_cache_s
{
        uint8 l4Proto;
        ipaddr_t srcIp;
        ipaddr_t dstIp;
        uint16 srcPort;
        uint16 dstPort;

        _rtl8651_trapping_dispatch_entry_t *ptr;

} _rtl8651_trapping_dispatch_cache_t;
# 610 "rtl8651_tblDrvFwdLocal.h"
struct _RTL8651_QUEUE_PACKET_ENTRY
{
        uint8 q_type;
        uint8 q_time;
        uint16 q_id;
        uint32 q_waitIp;
        struct rtl_pktHdr * q_pkthdrPtr;
        struct ip * q_ip;
};





uint16 _rtl8651_ipChecksum(struct ip * pip);
uint16 _rtl8651_icmpChecksum(struct ip * pip);
uint16 _rtl8651_tcpChecksum(struct ip * pip);
# 699 "rtl8651_tblDrvFwdLocal.h"
struct wan_gre_header {
  uint8 flags;
  uint8 ver;
  uint16 protocol;
  uint16 payload_len;
  uint16 call_id;
  uint32 seq;
  uint32 ack;

};
# 731 "rtl8651_tblDrvFwdLocal.h"
struct wan_l2tp_header {

  uint16 flags_type:1;
  uint16 flags_length:1;
  uint16 flags_rsv1:2;
  uint16 flags_sequence:1;
  uint16 flags_rsv2:1;
  uint16 flags_offset:1;
  uint16 flags_priority:1;
  uint16 flags_rsv3:4;
  uint16 flags_version:4;

  uint16 length;
  uint16 tunnel_id;
  uint16 session_id;
};
# 803 "rtl8651_tblDrvFwdLocal.h"
typedef struct _rtl8651_naptRedirectEntry_s
{
        uint8 isExceptionList;
        uint8 isTcp;
        ipaddr_t sip;
        uint16 sport;
        ipaddr_t dip;
        uint16 dport;
        ipaddr_t newDip;
        int32 newDport;

        struct _rtl8651_naptRedirectEntry_s *next;
} _rtl8651_naptRedirectEntry_t;


typedef struct _rtl8651_naptRedirectFlow_s
{
        uint8 isTcp;
        ipaddr_t sip;
        uint16 sport;
        ipaddr_t dip;
        uint16 dport;
        ipaddr_t newDip;
        uint16 newDport;
        uint32 age;
        uint32 queryCnt;

        struct _rtl8651_naptRedirectFlow_s *next;
} _rtl8651_naptRedirectFlow_t;






typedef struct _rtl8651_pptpHdrCacheEntry_s
{

        uint8 type;
        uint32 seq;
        uint32 ack;

        uint16 id;
        uint16 offset;

        struct _rtl8651_pptpHdrCacheEntry_s **hdr;
        struct _rtl8651_pptpHdrCacheEntry_s *prev;
        struct _rtl8651_pptpHdrCacheEntry_s *next;
        struct _rtl8651_pptpHdrCacheEntry_s *lru_prev;
        struct _rtl8651_pptpHdrCacheEntry_s *lru_next;
} _rtl8651_pptpHdrCacheEntry_t;
# 863 "rtl8651_tblDrvFwdLocal.h"
void _rtl8651_pptpHdrCache_Add(uint16 ip_id, uint16 ip_off, uint32 seq, uint32 ack, uint8 type);




int32 _rtl8651_mtuFragment(uint32 property, struct rtl_pktHdr *pkthdrPtr, uint32 mtu, uint16 dvid, int8 isNapt, uint16 srcPortList);
# 901 "rtl8651_tblDrvFwdLocal.h"
extern int8 rtl8651_drvMulticastProcessEnable;
extern int8 rtl8651_drvPacketFastSend;
extern int8 rtl8651_drvIcmpRoutingMsgEnable;
extern int8 rtl8651_drvSoftwareBroadcastEnable[8];
extern rtl8651_tblDrvFwdEngineCounts_t rtl8651_fwdEngineCounter;




inline void _rtl8651_l4TcpAdjustMss(struct ip *ip, struct tcphdr *tc, ipaddr_t intfIp, int32 delta);
int32 _rtl8651_isdigit(int32);
int32 _rtl8651_isspace(int32);
void _rtl8651_l4AddSeq(struct ip *pip, rtl8651_tblDrv_naptTcpUdpFlowEntry_t *tb, int32 delta);
int32 _rtl8651_l4GetDeltaSeqOut(struct ip * pip, struct tcphdr *tc, rtl8651_tblDrv_naptTcpUdpFlowEntry_t *tb);




int _rtl8651_markDiffserv( int32, struct rtl_pktHdr *, struct ip *, void * );
# 37 "rtl8651_tblDrv.c" 2


# 1 "rtl8651_tblDrvPatch.h" 1
# 66 "rtl8651_tblDrvPatch.h"
inline int32 RTL8651_SETASICVLAN( rtl8651_tblDrv_vlanTable_t *vt );
inline int32 convert_getAsicVlan( uint16 vid, ether_addr_t * mac, uint32 * mbr,
                                      uint32 * inAclStart, uint32 * inAclEnd, uint32 * outAclStart,
                                      uint32 * outAclEnd, int8 * internalIntf, int8 * enableRoute,
                                      int8 *portState, int8 * broadcastToCpu, int8 * promiscuous,
                                      uint32 * untagPortMask, uint32 * macNumber, uint32 * mtu );

inline int32 convert_setAsicPppoe( uint32 index, uint16 sid );
inline int32 convert_getAsicPppoe( uint32 index, uint16 *sid );

inline int32 convert_setAsicExtIntIpTable( uint32 ipIdx, ipaddr_t ExtIp, ipaddr_t IntIp,
                                   uint32 localPublic, uint32 nat);
inline int32 convert_getAsicExtIntIpTable( uint32 index, ipaddr_t *ExtIp, ipaddr_t *IntIp,
                                               int8 *localPublic, int8 *nat );

inline int32 convert_setAsicArp( uint32 ArpPos, uint32 ArpIdx, uint32 asicPos );
inline int32 convert_getAsicArp( uint32 index, uint32 *nextHopRow, uint32 *nextHopColumn );

inline int32 convert_setAsicRouting( uint32 idx, ipaddr_t ipAddr, ipaddr_t ipMask,
                                         uint32 process, uint32 vidx, uint32 arpStart, uint32 arpEnd,
                                         uint32 nextHopRow, uint32 nextHopColumn, uint32 pppoeIdx );
inline int32 convert_getAsicRouting( uint32 index, ipaddr_t * ipAddr, ipaddr_t * ipMask, uint32 * process,
                                         uint32 * vidx, uint32 * arpStart, uint32 * arpEnd,
                                         uint32 * nextHopRow, uint32 * nextHopColumn, uint32 * pppoeIdx) ;

inline int32 convert_setAsicServerPortTable( uint32 index, ipaddr_t ExtIp, uint16 ExtPort,
                                                 ipaddr_t IntIp, uint16 IntPort );
inline int32 convert_getAsicServerPortTable( uint32 index, ipaddr_t *ExtIp, uint16 *ExtPort,
                                                 ipaddr_t *IntIp, uint16 *IntPort );

inline int32 convert_setAsicNaptTcpUdpTable( int8 forced,
                                                 ipaddr_t IntIp, uint16 IntPort, uint16 ExtPort,
                                                 uint32 ageSec, int8 entryType, int8 isTcp, int8 tcpFlag,
                                                 int8 isCollision, int8 isCollision2, int8 isValid );
inline int32 convert_getAsicNaptTcpUdpTable( uint8 *extIpIdx, uint16 index,
                                                 ipaddr_t *intIPAddr, uint16 *intPort, uint16 *extPort,
                                                 uint32 *ageSec, int8 * entryType, int8 *isTcp, int8 *flags,
                                                 int8 *isCollision, int8 *isValid,int8 *isCollision2,
                                                 int8 *isDedicated, uint16 *selEIdx, uint8 *selExtIpIdx );

inline int32 convert_setAsicNaptIcmpTable(int8 forced,
                ipaddr_t IntIp, uint16 IntId, uint16 ExtId,
                uint32 ageSec, int8 entryType, int16 count, int8 isCollision, int8 isValid );
inline int32 convert_getAsicNaptIcmpTable( int8 precisePort, uint16 tarId,
                                               ipaddr_t *IntIp, uint16 *IntId,
                                               uint16 *ExtId, uint32 *ageSec, int8 *entryType,
                                               uint16 *count, int8 *isCollision, int8 *isValid );

inline int32 convert_setAsicAlg( uint32 index, uint16 port );
inline int32 convert_getAsicAlg( uint32 index, uint16 *port );

inline int32 convertt_setAsicProtoTrap( uint32 index, uint8 type, uint16 content );
inline int32 convert_getAsicProtoTrap( uint32 index, uint8 *type, uint16 *content);

inline int32 convert_setAsicL2Table(uint32 row, uint32 column, ether_addr_t * mac, int8 cpu,
                int8 srcBlk, uint32 mbr, uint32 ageSec, int8 isStatic, int8 nhFlag);



int32 rtl8651_setAsicL2Table_Patch(uint32 row, uint32 column, ether_addr_t * mac, int8 cpu,
                int8 srcBlk, uint32 mbr, uint32 ageSec, int8 isStatic, int8 nhFlag);


int32 rtl8651_getAsicL2Table_Patch(uint32 row, uint32 column, rtl865x_tblAsicDrv_l2Param_t *asic_l2_t);
# 40 "rtl8651_tblDrv.c" 2
# 1 "rtl8651_tblDrvStatistic.h" 1
# 14 "rtl8651_tblDrvStatistic.h"
typedef struct rtl8651_tblDrvNaptCounter_s {
        uint32 protoAddCount,
                   protoDelCount,
                   drvAddCount,
                   drvAgeoutCount,
                   addAttempts, addSucceeded,
                   threadWriteBackCount,
                   naptUnitAddCnt,
                   maxNaptUnitAddCnt,
                   dosCountedTcpCnt, dosCountedUdpCnt,
                   dosCountedFromInternalTcpCnt, dosCountedFromInternalUdpCnt;
} rtl8651_tblDrvNaptCounter_t;


typedef struct rtl8651_tblDrvIcmpCounter_s {
        uint32 protoAddCount,
                   protoDelCount,
                   drvAddCount,
                   learntFromAsic,
                   drvDelCount,
                   diffHashCount,
                   threadWriteBackCount,
                   syncFailure,
                   addFailure;

        uint16 curActiveCount,
                   curInactiveCount,
                   curInDriverCount,
                   curInAsicCount,
                   curDiffHashCount,
                   curFromAsicCount;

} rtl8651_tblDrvIcmpCounter_t;

extern rtl8651_tblDrvNaptCounter_t rtl8651_tblDrvNaptCounter;
extern rtl8651_tblDrvIcmpCounter_t rtl8651_tblDrvIcmpCounter;


int32 _rtl8651_dumpAsicNaptTableEntry(uint32 index, uint32 findport);
int32 _rtl8651_dumpNaptTableEntry(uint32 index, uint32 findport);
int32 _rtl8651_dumpAlgCtrlConnections(uint32 index);
int32 _rtl8651_dumpNaptIcmpTable(void);
int32 rtl8651_getTblDrvNaptIcmpCounter(rtl8651_tblDrvIcmpCounter_t *counter);
int32 _rtl8651_tblDrvStatisticReset(void);
void rtl8651_getTblDrvNaptInfo( int32 TopN, int32 listN );
# 41 "rtl8651_tblDrv.c" 2
# 1 "rtl8651_dos_local.h" 1
# 76 "rtl8651_dos_local.h"
extern uint32 _rtl8651_dos_enable;
extern uint32 _rtl8651_dos_sw[2];



void _rtl8651_dos_init(rtl8651_fwdEngineInitPara_t *);
void _rtl8651_dos_Reinit(void);







int32 _rtl8651_procDoSPkt_init(rtl8651_fwdEngineInitPara_t *);
void _rtl8651_procDosPkt_reinit(void);
void _rtl8651_procDoSPkt(uint32 item, uint32 dsid, uint16 vid, struct ip*ip, uint8 direction, struct rtl_pktHdr *);
void _rtl8651_procDoSIP(uint32 item, uint32 dsid, uint16 vid, ipaddr_t ip);



int32 _rtl8651_dosProc_blockSip_check(uint16 vid, ipaddr_t sip);

void _rtl8651_dosScanTracking(struct rtl_pktHdr*pkt, struct ip *ip, uint8 l4Type, void*l4hdr);
int32 _rtl8651_dosScanCheckComplain(uint16 dsid, struct ip *ip);
int32 _rtl8651_dosScanCheckTcpOutboundFailUnusual(uint16 dsid, struct ip *ip, struct tcphdr *tc);

inline uint8 _rtl8651_dosIgnoreTypeCheck(uint8 direction);




uint32 _rtl8651_addAclRuleForSipBlock(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 *enoughFlag);

void _rtl8651_dosProc_blockSip_discharge(uint32);


int32 _rtl8651_dosNaptConnCheck(uint8 isTcp, ipaddr_t ip, uint8 direction);
inline void _rtl8651_dosSrcConnCtrlUpdateConnection(uint8 isDecrease, uint8 isTcp, ipaddr_t ip);

int32 _rtl8651_connSrcTrackingRemoveByFlowtypeIp(uint8, ipaddr_t);
int32 _rtl8651_connSrcTrackingRemoveByIp(ipaddr_t);
# 42 "rtl8651_tblDrv.c" 2
# 1 "rtl8651_alg_init.h" 1
# 172 "rtl8651_alg_init.h"
extern uint32 alg_supports[2];
extern uint32 alg_serverips[2][32];
extern uint32 alg_qosqid[2][32];
extern uint32 alg_qoshl[2][32];
extern uint32 _rtl8651_DefaultDialSessionId;

struct rtl8651_algMaxSession
{
        uint8 l2tpMaxSession;
        uint8 pptpMaxSession;
        uint8 ipsecMaxSession;
};

extern struct rtl8651_algMaxSession algMaxSession;


void rtl8651_setAlgStatus(uint32 alg_support,ipaddr_t *alg_serverip);
uint32 rtl8651a_setAlgStatus(uint32 SessionID,uint32 alg_support,ipaddr_t *alg_serverip);
void rtl8651_setAlgConfig(uint32 alg_support,ipaddr_t *alg_serverip,struct rtl8651_algMaxSession maxSession);
uint32 rtl8651a_setAlgConfig(uint32 SessionID,uint32 alg_support,ipaddr_t *alg_serverip,struct rtl8651_algMaxSession maxSession);
int32 rtl8651_algOneSecondTimer(void);
uint32 rtl8651_getAlgStatus(void);
uint32 rtl8651a_getAlgStatus(uint32 SessionID);
uint32 rtl8651_flushAlgServerIn(void);
uint32 rtl8651a_flushAlgServerIn(uint32 SessionID);
void rtl8651_algReInit(void);
int32 rtl8651_setAlgQosQueueId(uint32 alg_idx,uint32 queueID,uint32 isHigh, uint32 ratio);
int32 rtl8651a_setAlgQosQueueId(uint32 SessionID,uint32 alg_idx,uint32 queueID,uint32 isHigh, uint32 ratio);
int32 _rtl8651_addAlgQosNaptConnection(int8 fromDrv, int16 assigned, int8 flowType, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                        ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort, ipaddr_t dstIpAddr, uint16 dstPort,uint32 AlgIdx);
# 43 "rtl8651_tblDrv.c" 2
# 1 "assert.h" 1
# 44 "rtl8651_tblDrv.c" 2
# 1 "asicRegs.h" 1
# 39 "asicRegs.h"
# 1 "rtl865xb_asicregs.h" 1
# 40 "asicRegs.h" 2
# 45 "rtl8651_tblDrv.c" 2
# 1 "asicTabs.h" 1
# 46 "rtl8651_tblDrv.c" 2

# 1 "rtl_utils.h" 1






void __strlowerncpy(char *dst, const char *src, int32 len);
int8 *_strncpy(int8 *dst0, const int8 *src0, int32 count);
int _strncasecmp(const char *s1, const char *s2, unsigned int n);
int32 _strncmp(const int8 *s1, const int8 *s2, int32 n);
void rtl8651_memcpy(void *dst,void*src,int32 len);
int32 isPowerOf2(uint32 number, uint32 *exponent);
int32 IpStrToAscii(const int8 *cp, uint32 *addr);
void IntToAscii(int32 n, int8 s[]);
int AsciiToInt( char **s);
int32 ether_ntoa_r(ether_addr_t *n, uint8 *a);
int8 *inet_ntoa_r(ipaddr_t ipaddr, int8 *p);
void memDump (void *start, uint32 size, int8 * strHeader);
# 48 "rtl8651_tblDrv.c" 2
# 87 "rtl8651_tblDrv.c"
int8 rtl8651_drvProtocolBasedNatEnable = 0;







const static uint32 *tcpAgeTimer[8 +1]={
        ((void *)0),
        ((void *)0),
        &rtl8651GlobalControl.tcpFastTimeout,
        &rtl8651GlobalControl.tcpFastTimeout,
        ((void *)0),
         &rtl8651GlobalControl.tcpLongTimeout,
         &rtl8651GlobalControl.tcpMediumTimeout,
         &rtl8651GlobalControl.tcpMediumTimeout,
         &rtl8651GlobalControl.tcpFastTimeout
};
# 146 "rtl8651_tblDrv.c"
struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *candidateToBeFreed;




int8 rtl8651_tblDrv_Id[] = "$Id: rtl8651_tblDrv.c,v 1.453 2005/12/06 06:58:05 shliu Exp $";


int8 aclMode;

int pppoeDefaultGlobalIpAddr;



rtl8651_tblDrv_global_t rtl8651GlobalControl;
rtl8651_tblDrv_global_t rtl8651AsicAge;
static int32 _gidxRegister[16];

uint16 * rtl8651NaptIcmpBackwardCollisionCountTable;
uint16 * rtl8651NaptIcmpFlowNumberTable, *rtl8651NaptIcmpFlowNonAsicNumberTable;
uint32 rtl8651ExistedNaptIcmpFlows;

_rtl8651_sessionHangUp_t rtl8651_sessionHangUp[2];

rtl8651_tblDrvNaptCounter_t rtl8651_tblDrvNaptCounter;
rtl8651_tblDrvIcmpCounter_t rtl8651_tblDrvIcmpCounter;
static uint32 naptIpCount, natIpCount, localServerCount;



static uint32 rtEntry;
static int8 naptAutoLearn;


int32 *rtl8651_wanStatus;
int16 _rtl8651_dsid;





urlFiltering_t _urlFilter;

int32 _urlFilterAclRuleNum;







static int8 rtl8651_urlStringUnknownType_caseSensitive = 0;


uint16 rtl8651_gVlanIDforPassthru = (4096+1);
int32 rtl8651_gRefCountofVlanforPassthru = 0;


uint8 rtl8651_gPPPoEExternalVlanIndex = 8;
ether_addr_t rtl8651_gPPPoEExternalGatewayMAC;
uint16 rtl8651_gPPPoEPassthruVlanID = (4096+1);



uint8 rtl8651_gIPv6ExternalVlanIndex = 8;
ether_addr_t rtl8651_gIPv6ExternalGatewayMAC;
uint16 rtl8651_gIPv6PassthruVlanID = (4096+1);
uint32 rtl8651_pbv_ipv6passthru = 7;



uint8 rtl8651_gIPXExternalVlanIndex = 8;
ether_addr_t rtl8651_gIPXExternalGatewayMAC;
uint16 rtl8651_gIPXPassthruVlanID = (4096+1);
uint32 rtl8651_pbv_ipxpassthru = 7;



uint8 rtl8651_gNetbiosExternalVlanIndex = 8;
ether_addr_t rtl8651_gNetbiosExternalGatewayMAC;
uint16 rtl8651_gNetbiosPassthruVlanID = (4096+1);
uint32 rtl8651_pbv_netbiospassthru = 7;






static uint16 global_port=3200;
static uint16 icmp_global_port=3200;
uint32 _rtl8651_DefaultDialSessionId=0;
_rtl8651_tblDrvPolicyRoute_t rtStaticPolicy[32];
_rtl8651_tblDrvPolicyRoute_t rtDynamicPolicy[32];
static _rtl8651_tblDrvPolicyRoute_t *rtHashTable[32];
static _rtl8651_tblDrvPolicyRoute_t *rtDynamicPolicyHeadPtr;



static rtl8651_tblDrvDemandRoute_t rtDemandRouteTable[32];


static int8 extIfName[8]="\0";



rtl8651_loggingFuncPtr_t _pUserLoggingFunc = ((void *)0);
uint32 *_loggingModule;


static uint32 _userConfigFastTimeoutValue, _adaptiveTimeoutThreshold;
static int8 _enableAdaptiveNAPTfastTimeout;
static int8 _enableSmartNaptSwappingByLoad;
static uint32 _smartNaptSwappingThresholdTcp;
static uint32 _smartNaptSwappingThresholdUdp;
static uint32 _smartNaptSwappingThresholdCdrouter;







static rtl8651_tblDrv_routeTable_t *multiNxtHop;
static rtl8651_tblDrv_networkIntfTable_t *lanSideIpUnnumberedWan;
static rtl8651_tblDrv_networkIntfTable_t *lanSideIpUnnumberedLan;
static rtl8651_ipUnnumbered_ctrlBlock_t rtl8651_ipUnnumberGlobalCtrlBlock;
static rtl8651_tblDrv_natEntry_t lanSideNatMapping;
rtl8651DmzHostStruct_t *rtl8651DmzHost;
extern uint16 *_rtl8651_udpSizeThreshValue;

uint8 *_rtl8651_acl_drop_nolog=((void *)0);
static uint32 _rtl8651_pppoe_count=0;
static uint32 _rtl8651_multiple_dsid=0;



uint32 rtl8651_externalMulticastPortMask = 0;

static uint32 enable4WayHash;
static rtl8651_tblDrv_natEntry_t unnumNatEntry;


rtl8651_tblDrv_mnqueue_sys_t mnqueue_ctrl;
static uint8 mnQ_enable;

static uint32 ipClassCount;
static rtl8651_tblDrv_routeTable_t *cur_rt_t;
ipClassABMonitorTable_t ipClassABMonitorTable[10];


static rtl8651_tblDrv_rateLimitCounter_t rateLimitCounterRegisterTable[10];

rtl8651_tblDrv_miiTunneling_t tunnel;
ipaddr_t softNaptIp;
int32 (*p_mtuHandler) (struct rtl_pktHdr *);
rtl8651_tblDrv_ipEntry_t *def_napt_t;
int32 _rtl8651_createProtocolBasedVLANforIPv6Passthru(void);
int32 _rtl8651_createProtocolBasedVLANforPPPoEPassthru(void);
int32 _rtl8651_destroyProtocolBasedVLANforPPPoEPassthru(void);
int32 _rtl8651_destroyProtocolBasedVLANforIPv6Passthru(void);
# 316 "rtl8651_tblDrv.c"
 void _rtl8651_syncL2Entrychange(void *l2entry_t, void *arg);

rtl8651_tblDrv_filterDbTableEntry_t * _rtl8651_getVlanFilterDatabaseEntry(uint16 vid, ether_addr_t * macAddr);

static void _rtl8651_setAsicAclDefaultRule(uint32 aclIdx, int8 actionType);
static uint32 _rtl8651_tryAddAlgToAcl(uint16 vid, uint32 aclStart, uint32 aclEnd);

static int8 _rtl8651_sameAclRule(_rtl8651_tblDrvAclRule_t *rule1, rtl8651_tblDrvAclRule_t *rule2);



static void _rtl8651_timeUpdateSessionHangUp(uint32 secPassed);





static void _rtl8651_updateGidxRegister(void);

static void _rtl8651_arrangeAsicArpEntry(rtl8651_tblDrv_ipIntfEntry_t *ipIntf, rtl8651_tblDrv_arpEntry_t *arp_t);
int32 _rtl8651_delLocalArp(int8 fromDrv, ipaddr_t ipAddr, rtl8651_tblDrv_networkIntfTable_t *netIfPtr);
static void _rtl8651_timeUpdateArp(uint32 secPassed);


static void _rtl8651_updateDefaultRoute(void);


static int32 _rtl8651_selectNaptPortOffset(uint32 tblIdx, uint32 isTcp, ipaddr_t wantedIp, uint16 *offset);

int32 _rtl8651_delNaptConnection( rtl8651_tblDrv_naptTcpUdpFlowEntry_t *delConn);
static void _rtl8651_removeNaptConnectionBySrcIP(ipaddr_t sip);
static void _rtl8651_removeNaptConnectionByExtIP(ipaddr_t);
static int32 _rtl8651_flushNaptConnection(void);
static void _rtl8651_removeNaptConnectionBySrcIP(ipaddr_t sip);
static void _rtl8651_softwareNaptAging(uint32 secPassed);
static int32 _rtl8651_selectNaptIcmpFlowOffset(uint32 flowTblIdx, uint32 HashIdx, ipaddr_t ExtIp, uint16 *offset);
static void _rtl8651_removeIcmpFlowBySrcIP(ipaddr_t sip);
static rtl8651_tblDrv_naptIcmpFlowEntry_t * _rtl8651_getNaptIcmpFlowEntry(uint32 flowTblIdx, ipaddr_t insideLocalIpAddr, uint16 insideLocalId);
static int32 _rtl8651_delNaptIcmpFlowEntry(uint32 flowTblIdx, rtl8651_tblDrv_naptIcmpFlowEntry_t * deletedEntry);

int32 _rtl8651_addNaptIcmpNonCandidateFlow(int8 fromDrv, ipaddr_t insideLocalIpAddr, uint16 insideLocalId,
                        ipaddr_t insideGlobalIpAddr, uint16 insideGlobalId, ipaddr_t dstIpAddr);

static int32 _rtl8651_delNaptIcmpFlow(uint32 flowTblIdx, rtl8651_tblDrv_naptIcmpFlowEntry_t *delEntry);
static void _rtl8651_timeUpdateNaptIcmpTable(uint32 secPassed);







int32 _rtl8651_changeNaptFlowListType( struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * thisFlow,
                                              uint8 inListType, uint8 outListType );
static int32 _rtl8651_NaptEntryIsEmpty( uint16 tblIndex );
static void _rtl8651_setNaptAsicAge( void );







static int8 _rtl8651_isNaptMapping(ipaddr_t extip);
static int8 _rtl8651_isNatMapping(ipaddr_t *extip, ipaddr_t *intip);
static int32 _rtl8651_delNaptMapping(ipaddr_t extIpAddr);

static uint32 _rtl8651_algToAclCount(void);
static int32 _rtl8651_delAlgEntryFromAsic(rtl8651_tblDrv_algEntry_t *algPtr);
static int32 _rtl8651_addAlgEntryToAsic(rtl8651_tblDrv_algEntry_t *algPtr);
static void _rtl8651_arrangeAsicAlg(void);





 int8 _rtl8651_isLanSideIpUnnumberedIpAddr(ipaddr_t ipAddr);

static int32 _rtl8651_DoS_tcpSynFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_tcpFinFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_icmpFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_udpFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_ipSpoofing(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_udpEchoChargen(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_fullXmasScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_fullSapuScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_finScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_synFinScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_nullScan(uint16 vid, uint32 inAclStart, uint32 inAclEnd, int8 wr);
static int32 _rtl8651_DoS_nmapXmasScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_vecnaScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_DoS_portScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);
static int32 _rtl8651_addAclRuleForDoS(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr);




static uint32 _rtl8651_tryAddAclForWanSynTrap(uint32 aclStart, uint32 aclEnd);

static uint32 _rtl8651_tryAddAclForMultipleNextHop(int8 wrt, uint16 vid, uint32 aclStart, uint32 aclEnd);

static int32 _rtl8651_delDmzHost(uint32 dsid,ipaddr_t dmzHostIp);
static int32 _rtl8651_initURLfilter(void);


static uint32 *urlFilterTrustedUsers = ((void *)0);
static int _rtl8651_initUrlFilterTrustedUserDb(void);
static void _rtl8651_ReinitUrlFilterTrustedUserDb(void);
static int _rtl8651_isUrlFilterTrustedUser(uint32 ipaddr);


static uint32 _rtl8651_tryAddAclForPolicyBasedQos(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint32 aclStart, uint32 aclEnd);

static int32 _rtl8651_addInterfaceRoute(rtl8651_tblDrv_networkIntfTable_t *netif_t, rtl8651_tblDrv_ipIntfEntry_t *ipintf_t, uint32 arpsta, uint32 arpend);
static int32 _rtl8651_delInterfaceRoute(ipaddr_t ipAddr, ipaddr_t ipMask);
static void _rtl8651_updateL3Entry(rtl8651_tblDrv_routeTable_t *rt_t);
static void _rtl8651_unbindSession(rtl8651_tblDrv_ipIntfIpAddrEntry_t *ipAddr, rtl8651_tblDrv_pppTable_t *pppEntry_t) ;

void _rtl8651_ipClassTimeUpdate(void);
void _rtl8651_arrangeNATbyMacAccessControl(void);
void _rtl8651_arrangeSPbyMacAccessControl(void);
uint32 _rtl8651_acl_PPPoE_Passthru( uint32 aclStart, uint32 aclEnd, rtl8651_tblDrv_networkIntfTable_t *netIfPtr );
uint32 _rtl8651_acl_IPv6_Passthru( uint32 aclStart, uint32 aclEnd, rtl8651_tblDrv_networkIntfTable_t *netIfPtr );

rtl8651_tblDrv_ipEntry_t *_rtl8651_addIpEntry(ipaddr_t extip, ipaddr_t intip, int8 attr, rtl8651_tblDrv_networkIntfTable_t *netif_t);
static int32 _rtl8651_delIpEntry(int8 attr, ipaddr_t extip, ipaddr_t intip) ;
int32 _rtl8651_setExternalInterfaceforPPPoEPassthru( ether_addr_t* gmac, uint16 ExtVid );
int32 _rtl8651_setExternalInterfaceforIPv6Passthru( ether_addr_t* gmac, uint16 ExtVid );
int32 _rtl8651_setExternalInterfaceforIPXPassthru( ether_addr_t* gmac, uint16 ExtVid );
int32 _rtl8651_setExternalInterfaceforNetbiosPassthru( ether_addr_t* gmac, uint16 ExtVid );

rtl8651_tblDrv_pppTable_t *_rtl8651_getPPPInfo(uint32 sessionId, ipaddr_t ipaddr);


static void _rtl8651_dynamicPolicyRouteTimeupdate(uint32 secpassed);


static int32 _rtl8651_init_nexthopEntry(uint32 entryIndex);
static void _rtl8651_updateNextHopEntry(ipaddr_t nexthop, rtl8651_tblDrv_nextHopEntry_t *entry_t);
static void _rtl8651_arrangeNextHopTable(ipaddr_t nexthop, rtl8651_tblDrv_filterDbTableEntry_t *macInfo);
static int32 _rtl8651_addNextHopEntry(int8 attr, void *ptr_t, rtl8651_tblDrv_networkIntfTable_t *netif_t, ipaddr_t nexthop, ipaddr_t naptip, rtl8651_tblDrv_pppTable_t *session_t);
static int32 _rtl8651_delNextHopEntry(int8 attr, void *ptr_t);
static void _rtl8651_updateNextHop_NHIDX(rtl8651_tblDrv_arpEntry_t *arp_t, rtl8651_tblDrv_pppTable_t *session_t);
static void _rtl8651_ipTbl_setDefNexthop(rtl8651_tblDrv_routeTable_t *rt_t);
int32 _rtl8651_addHash2ToNexthop(ipaddr_t nexthop, ipaddr_t naptip);
int32 _rtl8651_delHash2FromNexthop(ipaddr_t nexthop, ipaddr_t naptip);
# 487 "rtl8651_tblDrv.c"
rtl8651_tblDrv_networkIntfTable_t *GET_NETWORK_INTERFACE(int8 *ifname, uint32 *ifIdx) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t=&DrvTbl.netIface[0];
        uint32 netIdx;

        for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netif_t++)
                if((netif_t->valid==1)&&(_strncmp(netif_t->ifName, ifname, 16)==0)) {
                        if (ifIdx != (uint32 *)((void *)0))
                                *ifIdx = netIdx;
                        return (rtl8651_tblDrv_networkIntfTable_t *)netif_t;
                }
        return (rtl8651_tblDrv_networkIntfTable_t *) ((void *)0);
}






int32 rtl8651_enableNaptAutoAdd(int8 enable){
        naptAutoLearn=enable;
        rtl8651_setAsicNaptAutoAddDelete(enable,1);
        return 0;
}







void _rtl8651_syncL2Entrychange( void *arg1, void *arg2) {
        rtl8651_tblDrv_filterDbTableEntry_t *l2entry_t=(rtl8651_tblDrv_filterDbTableEntry_t *)arg1;
        if(l2entry_t){
                rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
                rtl8651_tblDrv_ipIntfEntry_t *ipIf_t;
                rtl8651_tblDrv_arpEntry_t *arp_t;
                uint32 i;

                for(i=0,netIfPtr=&DrvTbl.netIface[0]; i<rtl8651_tblDrvPara.networkIntfTableSize; i++,netIfPtr++) {
                        if (netIfPtr->valid == 0)
                                continue;
                        if (netIfPtr->linkLayerType == 0x02)
                                continue;
                        for((ipIf_t) = (&(netIfPtr->IpHead))->slh_first; (ipIf_t); (ipIf_t) = (ipIf_t)->nextIp.sle_next) {
                                for((arp_t) = (&(ipIf_t->nextArp))->slh_first; (arp_t); (arp_t) = (arp_t)->next.sle_next){
                                        if (arp_t->macInfo == l2entry_t)
                                                _rtl8651_arrangeAsicArpEntry(ipIf_t, arp_t);
                                }
                        }
                }
        }
}
# 755 "rtl8651_tblDrv.c"
static uint32 _rtl8651_tryAddAclForWanSynTrap(uint32 aclStart, uint32 aclEnd){
        _rtl8651_tblDrvAclRule_t rule;

        if (aclStart > aclEnd)
                return 0;
        memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
        rule.ruleType_ = 0x04;
        rule.actionType_ = 0x03;
        rule.un_ty.L3L4.is.tcp.un.s._syn = 0x01;
        rule.un_ty.L3L4.is.tcp._flagMask = rule.un_ty.L3L4.is.tcp.un._flag;
        rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
        rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
        rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
        rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
        rule.pktOpApp = 4;
        rtl8651_setAsicAclRule(aclStart, &rule);
        return 1;
}



static uint32 _rtl8651_tryAddAclForMultipleNextHop(int8 wrt, uint16 vid, uint32 aclStart, uint32 aclEnd) {
# 923 "rtl8651_tblDrv.c"
        return 0;

}
# 940 "rtl8651_tblDrv.c"
static void _rtl8651_timeUpdateSessionHangUp(uint32 secPassed)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t = ((void *)0);
        _rtl8651_sessionHangUp_t *hangUp_p;
        uint32 idx, syncSetting = 0;







        for ( idx = 0, netif_t = DrvTbl.netIface ; idx < rtl8651_tblDrvPara.networkIntfTableSize ; idx ++, netif_t++ )
        {
                if ( (netif_t->valid) &&
                        _rtl8651_getRateLimitCounter( netif_t,
                                                                                        0x01,
                                                                                        1 ) > 0)
                {
                        if (netif_t->linkLayerType == 0x01)
                        {




                                ;




                                _rtl8651_recordTraffic( 0 , 1 );
                        } else
                        {

                                rtl8651_tblDrvSession_t *psession_t;

                                for (psession_t = ((&netif_t->sessionHead)->tqh_first); psession_t; psession_t = ((psession_t)->nextSession.tqe_next))
                                {
                                        if ( (psession_t) &&
                                                (psession_t->session_t) &&
                                                (psession_t->session_t->valid == 1))
                                        {
                                                uint32 updateTraffic = 0;

                                                if (netif_t->linkLayerType == 0x04)
                                                {

                                                        updateTraffic = 1;
                                                } else
                                                {
                                                        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;






                                                        ip_t = psession_t->ip_t;
                                                        while (ip_t)
                                                        {
                                                                if (_rtl8651_getIPTableEntry(ip_t->ipAddr, 0, 0x03))
                                                                        break;
                                                                ip_t = ((ip_t)->nextIpAddr.sle_next);
                                                        }
                                                        if (ip_t)
                                                        {
                                                                updateTraffic = 1;
                                                        }
                                                }

                                                if (updateTraffic == 1)
                                                {

                                                        ;




                                                        _rtl8651_recordTraffic(_rtl8651_SessionIDToDSID(psession_t->session_t->sessionId), 1 );
                                                }
                                        }
                                }
                        }
                }
        }






        for ( idx = 0, hangUp_p = rtl8651_sessionHangUp ;
                        idx < 2 ;
                        idx ++, hangUp_p ++)
        {

                if (hangUp_p->p_callBack == ((void *)0)) continue;


                if ( ((_sysUpSeconds - hangUp_p->last_received) > hangUp_p->idletime_limit) &&
                        ((_sysUpSeconds - hangUp_p->last_transmit) > hangUp_p->idletime_limit))
                {
                        ;




                        hangUp_p->p_callBack(hangUp_p->sessionID);
                        memset(hangUp_p, 0, sizeof(_rtl8651_sessionHangUp_t));
                        syncSetting = 1;
                }
        }

        if ( syncSetting == 1 )
        {
                _rtl8651_RearrangeHWTrafficCounter();
        }

}
# 1067 "rtl8651_tblDrv.c"
int32 rtl8651_setSessionHangUp(rtl8651_sessionHangUp_t *param)
{
        int32 retval = -1;

        if ((param == ((void *)0))) return -6;;

        rtlglue_drvMutexLock();
        retval = _rtl8651_setSessionHangUp(param);
        rtlglue_drvMutexUnlock();

        return retval;
}




int32 _rtl8651_setSessionHangUp(rtl8651_sessionHangUp_t *param)
{
        uint32 dsid;
        do {} while (0);

        if (((param == ((void *)0)) || ((param->enable == 1) && (param->idleTimeout_callBack == ((void *)0))))) return -6;;



        ;
# 1104 "rtl8651_tblDrv.c"
        dsid = _rtl8651_SessionIDToDSID(param->sessionID);

        if ((dsid >= 2)) return -2807;;

        if (param->enable == 1)
        {
                        ;





                rtl8651_sessionHangUp[dsid].p_callBack = param->idleTimeout_callBack;
                rtl8651_sessionHangUp[dsid].sessionID = param->sessionID;
                rtl8651_sessionHangUp[dsid].idletime_limit = param->idleTimeout_sec;
                rtl8651_sessionHangUp[dsid].last_received = _sysUpSeconds;
                rtl8651_sessionHangUp[dsid].last_transmit = _sysUpSeconds;
        } else
        {
                ;



                memset( &(rtl8651_sessionHangUp[dsid]),
                                        0,
                                        sizeof(_rtl8651_sessionHangUp_t));
        }

        _rtl8651_RearrangeHWTrafficCounter();
        _rtl8651_reArrangeLanSideExternalIpInterfacePatch();

        return 0;
}




void _rtl8651_recordTraffic(int32 dsid, int32 isXmit)
{
        do {} while (0);


        if (rtl8651_sessionHangUp[dsid].p_callBack)
        {
                if (isXmit == 1)
                {
                        rtl8651_sessionHangUp[dsid].last_transmit = _sysUpSeconds;
                } else
                {
                        rtl8651_sessionHangUp[dsid].last_received = _sysUpSeconds;
                }
        }
}

int32 _rtl8651_RearrangeHWTrafficCounter(void)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t = ((void *)0);
        rtl8651_tblDrv_ipEntry_t *track_t = ((void *)0);
        int32 idx, retval = 0;

        ;



        ;


        for ( idx = 0, netif_t = DrvTbl.netIface ; idx < rtl8651_tblDrvPara.networkIntfTableSize ; idx ++, netif_t++ )
        {
                if (netif_t->valid == 1)
                {
                        ;



                        _rtl8651_delRateLimitCounter(netif_t, 0x01);
                }
        }


        for ( idx = 0 ; idx < 2 ; idx ++ )
        {
                if (rtl8651_sessionHangUp[idx].p_callBack)
                {
                        break;
                }
        }
        if ( idx == 2)
        {
                goto out;
        }

        ;



        for( idx = 0, track_t = DrvTbl.iptbl ; idx < 16 ; idx ++, track_t ++ )
        {
                if ( track_t->valid == 0 )
                {
                        continue;
                }

                do {} while (0);

                switch (track_t->type)
                {
                        case 0x00:
                        case 0x01:
                        {


                                if ((netif_t = _rtl8651_getIpInfo( track_t->extip,
                                                                                                ((void *)0),
                                                                                                ((void *)0),
                                                                                                ((void *)0))) != ((void *)0) )
                                {
                                        rtl8651_tblDrv_vlanTable_t *vlan_t;

                                        if ( (netif_t->linkLayerType == 0x04) &&
                                                (netif_t == lanSideIpUnnumberedLan) &&
                                                (lanSideIpUnnumberedWan) &&
                                                (lanSideIpUnnumberedWan->valid))
                                        {
                                                if ( (DrvTbl.vlan[(lanSideIpUnnumberedWan->vid& (8 -1))].valid) &&
                                                        (DrvTbl.vlan[(lanSideIpUnnumberedWan->vid& (8 -1))].internal == 0))
                                                {
                                                        netif_t = lanSideIpUnnumberedWan;
                                                }
                                        }

                                        do {} while (0);
                                        vlan_t = &DrvTbl.vlan[(netif_t->vid& (8 -1))];
                                        do {} while (0);

                                        if (vlan_t->internal == 0)
                                        {
                                                ;



                                                if ((retval = _rtl8651_addRateLimitCounter(netif_t, 0x01)) != 0)
                                                {
                                                        do {if ((1<<0) & 0xffffffff) printk("[=!!Error !!=] =>\n\t(%x)[%s-%d]: " "Rate Limit Counter addition FAILED (retval %d)" "\n", (1<<0), __FUNCTION__, 1249, retval);} while (0);;


                                                } else
                                                {

                                                        rtl8651_tblDrvAclRule_t rl_rule;
                                                        memset(&rl_rule, 0, sizeof(rtl8651_tblDrvAclRule_t));
                                                        rl_rule.ruleType_ = 0x01;
                                                        rl_rule.actionType_ = 0x04;
                                                        rl_rule.un_ty.L3L4._srcIpAddr = track_t->extip;
                                                        rl_rule.un_ty.L3L4._srcIpAddrMask = 0xffffffff;

                                                        ;




                                                        if (( retval = _rtl8651_addRateLimitCounterRule(&rl_rule,
                                                                                netif_t,
                                                                                0x01))
                                                                != 0)
                                                        {
                                                                do {if ((1<<0) & 0xffffffff) printk("[=!!Error !!=] =>\n\t(%x)[%s-%d]: " "Add Rate Limit Rule at (%s) for IP (%u.%u.%u.%u) FAILED (return %d)" "\n", (1<<0), __FUNCTION__, 1274, netif_t->ifName, ((unsigned char *)&track_t->extip)[0], ((unsigned char *)&track_t->extip)[1], ((unsigned char *)&track_t->extip)[2], ((unsigned char *)&track_t->extip)[3], retval);} while (0);;




                                                        }
                                                }
                                        }
                                }
                                break;
                        }
                        case 0x02:
                        {

                                for (idx = 0, netif_t = DrvTbl.netIface ; idx < rtl8651_tblDrvPara.networkIntfTableSize ; idx ++, netif_t++)
                                {
                                        if (netif_t->valid == 1)
                                        {
                                                rtl8651_tblDrv_vlanTable_t *vlan_t;
                                                vlan_t = &DrvTbl.vlan[(netif_t->vid& (8 -1))];
                                                do {} while (0);

                                                if (vlan_t->internal == 0)
                                                {
                                                        if ((retval = _rtl8651_addRateLimitCounter(netif_t, 0x01)) != 0)
                                                        {
                                                                do {if ((1<<0) & 0xffffffff) printk("[=!!Error !!=] =>\n\t(%x)[%s-%d]: " "Rate Limit Counter addition FAILED (retval %d)" "\n", (1<<0), __FUNCTION__, 1298, retval);} while (0);;


                                                        } else
                                                        {

                                                                rtl8651_tblDrvAclRule_t rl_rule;
                                                                memset(&rl_rule, 0, sizeof(rtl8651_tblDrvAclRule_t));
                                                                rl_rule.ruleType_ = 0x01;
                                                                rl_rule.actionType_ = 0x04;
                                                                rl_rule.un_ty.L3L4._srcIpAddr = track_t->extip;
                                                                rl_rule.un_ty.L3L4._srcIpAddrMask = 0xffffffff;

                                                                ;




                                                                if (( retval = _rtl8651_addRateLimitCounterRule(&rl_rule,
                                                                                        netif_t,
                                                                                        0x01))
                                                                        != 0)
                                                                {
                                                                        do {if ((1<<0) & 0xffffffff) printk("[=!!Error !!=] =>\n\t(%x)[%s-%d]: " "Add Rate Limit Rule at (%s) for IP (%u.%u.%u.%u) FAILED (return %d)" "\n", (1<<0), __FUNCTION__, 1323, netif_t->ifName, ((unsigned char *)&track_t->extip)[0], ((unsigned char *)&track_t->extip)[1], ((unsigned char *)&track_t->extip)[2], ((unsigned char *)&track_t->extip)[3], retval);} while (0);;




                                                                }
                                                        }
                                                }
                                        }
                                }
                                break;
                        }
                }
        }

out:

        ;


        return retval;
}
# 1396 "rtl8651_tblDrv.c"
static rtl8651_tblDrv_pppTable_t *
_rtl8651_getPppoeBySessionId(uint32 sessionId)
{
        rtl8651_tblDrv_pppTable_t *pppoe_t = DrvTbl.pppoe;
        uint32 tblidx;

        for(tblidx=0; tblidx<8; tblidx++, pppoe_t++) {
                if (pppoe_t->valid && pppoe_t->sessionId==sessionId)
                        return pppoe_t;
        }
        return (rtl8651_tblDrv_pppTable_t *)((void *)0);
}
# 1421 "rtl8651_tblDrv.c"
int32 _rtl8651_getPppoeTblPtr(uint32 pppoeId,rtl8651_tblDrv_pppTable_t **pppoePtr_P){
        uint32 tblIdx;
        rtl8651_tblDrv_pppTable_t *pppoePtr;

        for(tblIdx=0, pppoePtr=&DrvTbl.pppoe[0]; tblIdx<8; (tblIdx)++, pppoePtr++)
                if (pppoePtr->valid == 1 && pppoePtr->sessionId == pppoeId){
                        *pppoePtr_P=pppoePtr;
                        return 0;
                }
        return -1;
}

rtl8651_tblDrv_pppTable_t *
_rtl8651_getPppoeSessionByIpAddr(ipaddr_t ipaddr) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrvSession_t *psession_t;
        rtl8651_tblDrv_pppTable_t *useSession_t = ((void *)0);
        uint32 i;

        if (ipaddr == 0){

                return ((void *)0);
        }
        netif_t = &DrvTbl.netIface[0];
# 1466 "rtl8651_tblDrv.c"
        for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netif_t++) {
                if (netif_t->valid == 0 ||netif_t->linkLayerType == 0x01)
                        continue;
                for (psession_t = ((&netif_t->sessionHead)->tqh_first); psession_t; psession_t = ((psession_t)->nextSession.tqe_next)){
                        do {} while (0);
                        if (psession_t->ip_t&&_rtl8651_isNaptMapping(psession_t->ip_t->ipAddr) == 1){
                                useSession_t = psession_t->session_t;
                                if (useSession_t && _rtl8651_isLanSideIpUnnumberedIpAddr(ipaddr) == 1){


                                        return useSession_t;
                                }
                        }else if (psession_t->ip_t&&_rtl8651_isLanSideIpUnnumberedIpAddr(psession_t->ip_t->ipAddr) == 1){
                                useSession_t = psession_t->session_t;
                                if (useSession_t){


                                        return useSession_t;
                                }
                        }
                        if (psession_t->ip_t && psession_t->ip_t->ipAddr == ipaddr){


                                do {} while (0);
                                return psession_t->session_t;
                        }
                }
        }

        return (rtl8651_tblDrv_pppTable_t *)((void *)0);

}
# 1512 "rtl8651_tblDrv.c"
uint32 * rtl8651_getNextPppoeSession(uint32 * curSessionId, uint32 *retSessionId) {
        uint32 tblIdx, returnThis;
        rtl8651_tblDrv_pppTable_t *pppoePtr;

        returnThis = 0;
        if(retSessionId == ((void *)0))
                return ((void *)0);
        for(tblIdx=0, pppoePtr=&DrvTbl.pppoe[0]; tblIdx<8; (tblIdx)++, pppoePtr++)
                if (pppoePtr->valid == 1){
                        if(curSessionId == ((void *)0) || returnThis) {
                                *retSessionId = pppoePtr->sessionId;
                                return retSessionId;
                        }
                        else if(*curSessionId == pppoePtr->sessionId)
                                returnThis = 1;
                }
        return ((void *)0);
}
# 1545 "rtl8651_tblDrv.c"
int32 rtl8651_getPppoeCounter(uint32 curSessionId, rtl865x_tblDrv_basicCounterParam_t * counter) {
        uint32 tblIdx;
        rtl8651_tblDrv_pppTable_t *pppoePtr;

        if(counter == ((void *)0))
                return -1;
        for(tblIdx=0, pppoePtr=&DrvTbl.pppoe[0]; tblIdx<8; (tblIdx)++, pppoePtr++)
                if (pppoePtr->valid == 1 && curSessionId == pppoePtr->sessionId) {
                        counter->rxBytes = pppoePtr->rxBytes;
                        counter->rxPackets = pppoePtr->rxPackets;
                        counter->rxErrors = pppoePtr->rxErrors;
                        counter->txBytes = pppoePtr->txBytes;
                        counter->txPackets = pppoePtr->txPackets;
                        counter->drops = pppoePtr->drops;
                        return 0;
                }
        return 0;
}
# 1571 "rtl8651_tblDrv.c"
rtl8651_tblDrv_pppTable_t * _rtl8651_getPppoeSessionByPppoeSessionId(uint16 pppoeSessionId) {
        uint32 tblIdx;
        rtl8651_tblDrv_pppTable_t *pppoePtr;

        for(tblIdx=0, pppoePtr=&DrvTbl.pppoe[0]; tblIdx<8; (tblIdx)++, pppoePtr++)
                if (pppoePtr->valid == 1 && pppoePtr->initiated ==1 && pppoeSessionId == pppoePtr->un.pppoe.pppoeSessionId__)
                        return pppoePtr;
        return ((void *)0);
}

ipaddr_t _rtl8651_getExtIpAddrByDsid(uint32 dsid) {

        if(_rtl8651_multiple_dsid==1)
        {
                uint32 i;
                rtl8651_tblDrvSession_t *psession_t;
                rtl8651_tblDrv_networkIntfTable_t *netif_t;

                netif_t = &DrvTbl.netIface[0];

                for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netif_t++) {
                        if (netif_t->valid == 0 ||netif_t->linkLayerType == 0x01)
                                continue;
                        for (psession_t = ((&netif_t->sessionHead)->tqh_first); psession_t; psession_t = ((psession_t)->nextSession.tqe_next)){
                                if(psession_t->ip_t==((void *)0)) continue;
                                do {} while (0);
                                if(psession_t->session_t->dsid == dsid) return psession_t->ip_t->ipAddr;
                        }
                }
        }
        else
        {
                rtl8651_tblDrv_ipEntry_t *ipEntry_t = DrvTbl.iptbl;
                ipaddr_t tempip=0;
                int32 ipIdx;

                for(ipIdx = 0; ipIdx<16; ipIdx++, ipEntry_t++) {
                        if (ipEntry_t->valid == 0)
                                break;
                        else if (ipEntry_t->extip&& ipEntry_t->type==0x00)
                        {
                                tempip=ipEntry_t->extip;
                                return tempip;
                        }
                }
        }
        return 0;
}


int32 _rtl8651_isExtIpAddr(ipaddr_t extip) {

        if(_rtl8651_multiple_dsid==1)
        {
                uint32 i;
                rtl8651_tblDrvSession_t *psession_t;
                rtl8651_tblDrv_networkIntfTable_t *netif_t;
                netif_t = &DrvTbl.netIface[0];

                for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netif_t++) {
                        if (netif_t->valid == 0 ||netif_t->linkLayerType == 0x01)
                                continue;
                        for (psession_t = ((&netif_t->sessionHead)->tqh_first); psession_t; psession_t = ((psession_t)->nextSession.tqe_next)){
                                if(psession_t->ip_t==((void *)0)) continue;
                                do {} while (0);
                                if(psession_t->ip_t->ipAddr == extip) return 1;
                        }
                }
        }
        else
        {
                rtl8651_tblDrv_ipEntry_t *ipEntry_t=DrvTbl.iptbl;
                int32 ipIdx;

                for(ipIdx = 0; ipIdx<16; ipIdx++, ipEntry_t++)
                {
                        if (ipEntry_t->valid == 0)
                                break;
                        else if (ipEntry_t->extip==extip && ipEntry_t->type==0x00)
                        {
                                return 1;
                        }
                }
        }
        return 0;

}

int32 rtl8651_setSoftPppoeSessionHangUp(uint32 SessionID, int32 enable, uint32 sec, int32 (*p_callBack)(uint32)) {
        rtl8651_sessionHangUp_t param;
        int32 retval = -1;

        param.enable = enable;
        param.sessionID = SessionID;
        param.idleTimeout_sec = sec;
        param.idleTimeout_callBack = p_callBack;

        rtlglue_drvMutexLock();
        retval = _rtl8651_setSessionHangUp(&param);
        rtlglue_drvMutexUnlock();

        return retval;
}
# 1683 "rtl8651_tblDrv.c"
int32 rtl8651_setPppoeSessionHangUp(uint32 SessionID, int32 enable, uint32 sec, int32 (*p_callBack)(uint32)) {
        rtl8651_sessionHangUp_t param;
        int32 retval = -1;

        param.enable = enable;
        param.sessionID = SessionID;
        param.idleTimeout_sec = sec;
        param.idleTimeout_callBack = p_callBack;

        rtlglue_drvMutexLock();
        retval = _rtl8651_setSessionHangUp(&param);
        rtlglue_drvMutexUnlock();

        return retval;
}
# 1713 "rtl8651_tblDrv.c"
rtl8651_tblDrv_networkIntfTable_t * _rtl8651_getNetworkIntfEntryByAddr(ipaddr_t ipAddr) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_ipIntfEntry_t * ipIfPtr;
        uint32 ifIndex;


        for(ifIndex=0,netIfPtr=&DrvTbl.netIface[0]; ifIndex< rtl8651_tblDrvPara.networkIntfTableSize; ifIndex++, netIfPtr++){

                if(netIfPtr->valid == 1) {
                        for((ipIfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIfPtr); (ipIfPtr) = (ipIfPtr)->nextIp.sle_next) {
                                do {} while (0);

                                if((ipIfPtr->ipAddr.slh_first->ipAddr & ipIfPtr->ipMask) == (ipAddr & ipIfPtr->ipMask))
                                        {
                                                return netIfPtr;
                                        }
                        }
                }
        }
        return ((void *)0);
}

rtl8651_tblDrv_networkIntfTable_t * _rtl8651_getNetworkIntfEntryByVid(uint16 vid) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 ifIndex;


        {
                rtl8651_tblDrv_vlanTable_t *vlan_t = &DrvTbl.vlan[(vid& (8 -1))];
                if (vlan_t->valid && vlan_t->fvlan_t)
                        vid = vlan_t->fvlan_t->vid;
        }


        for(ifIndex=0, netIfPtr=&DrvTbl.netIface[0];ifIndex< rtl8651_tblDrvPara.networkIntfTableSize; ifIndex++,netIfPtr++) {

                if (netIfPtr->valid == 1 && netIfPtr->vid == vid)
                        return netIfPtr;
        }
        return ((void *)0);
}


int8 _rtl8651_getNetworkIntfLinkLayerType(int8 *ifName, uint32 *llType, uint32 *llIndex) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 netIdx;

        for(netIdx=0, netIfPtr=&DrvTbl.netIface[0]; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++,netIfPtr++) {
                if (netIfPtr->valid == 1 && _strncmp(netIfPtr->ifName, ifName, 16) == 0) {
                        if (llType != ((void *)0))
                                *llType = netIfPtr->linkLayerType;
                        if (llIndex != ((void *)0))
                                *llIndex = netIfPtr->vid;
                        return 0;
                }
        }
        return -1;
}




static rtl8651_tblDrv_networkIntfTable_t * _rtl8651_addNetworkInterface(int8 *ifName)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        uint32 netIdx;

        if (GET_NETWORK_INTERFACE(ifName, ((void *)0)) != ((void *)0))
                return (rtl8651_tblDrv_networkIntfTable_t *)((void *)0);
        for(netIdx=0,netif_t=DrvTbl.netIface; netIdx< rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netif_t++)
                if(netif_t->valid == 0) {
                        _strncpy(netif_t->ifName, ifName, 16);
                        netif_t->linkLayerType = 0;
                        netif_t->valid = 1;
                        netif_t->vid = 0;
                        netif_t->netMask = 0;
                        netif_t->pppoeAge = 0;
                        netif_t->defAclAction = 0x01;
                        netif_t->mtu = 1500;
                        { (&(netif_t->IpHead))->slh_first = ((void *)0); };
                        { (&(netif_t->nextNat))->slh_first = ((void *)0); };
                        { (&(netif_t->nextNaptServerPort))->slh_first = ((void *)0); };
                        do { (&netif_t->sessionHead)->tqh_count=0; (&netif_t->sessionHead)->tqh_first = ((void *)0); (&netif_t->sessionHead)->tqh_last = &(&netif_t->sessionHead)->tqh_first; } while (0);
                        do { (&netif_t->inAclHead)->tqh_count=0; (&netif_t->inAclHead)->tqh_first = ((void *)0); (&netif_t->inAclHead)->tqh_last = &(&netif_t->inAclHead)->tqh_first; } while (0);
                        do { (&netif_t->outAclHead)->tqh_count=0; (&netif_t->outAclHead)->tqh_first = ((void *)0); (&netif_t->outAclHead)->tqh_last = &(&netif_t->outAclHead)->tqh_first; } while (0);
                        do { (&netif_t->policyQosHead)->tqh_count=0; (&netif_t->policyQosHead)->tqh_first = ((void *)0); (&netif_t->policyQosHead)->tqh_last = &(&netif_t->policyQosHead)->tqh_first; } while (0);
                        do { (&netif_t->inRateLimitHead)->tqh_count=0; (&netif_t->inRateLimitHead)->tqh_first = ((void *)0); (&netif_t->inRateLimitHead)->tqh_last = &(&netif_t->inRateLimitHead)->tqh_first; } while (0);
                        do { (&netif_t->outRateLimitHead)->tqh_count=0; (&netif_t->outRateLimitHead)->tqh_first = ((void *)0); (&netif_t->outRateLimitHead)->tqh_last = &(&netif_t->outRateLimitHead)->tqh_first; } while (0);
                        do { (&netif_t->mnqHead)->tqh_count=0; (&netif_t->mnqHead)->tqh_first = ((void *)0); (&netif_t->mnqHead)->tqh_last = &(&netif_t->mnqHead)->tqh_first; } while (0);
                        _rtl8651_arrangeAllACL();
                        return (rtl8651_tblDrv_networkIntfTable_t *)netif_t;
                }
        return (rtl8651_tblDrv_networkIntfTable_t *)((void *)0);
}
# 1822 "rtl8651_tblDrv.c"
int32 rtl8651_addNetworkIntf(int8 *ifName) {
        int32 retval = 0;
        rtlglue_drvMutexLock();
        if (_rtl8651_addNetworkInterface(ifName) == ((void *)0))
                retval = -9;
        rtlglue_drvMutexUnlock();
        return retval;
}
# 1843 "rtl8651_tblDrv.c"
int32 rtl8651_delNetworkIntf(int8 *ifName) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_routeTable_t *rt;
        uint32 i, j;

        rtlglue_drvMutexLock();
        netIfPtr = GET_NETWORK_INTERFACE(ifName, &i);
        if ((netIfPtr==((void *)0))) { rtlglue_drvMutexUnlock(); return -7; };

        if ((netIfPtr->IpHead.slh_first)) { rtlglue_drvMutexUnlock(); return -2500; };







        for(j=0, rt=DrvTbl.route; j<rtl8651_tblDrvPara.routingTableSize; j++, rt++) {
                if (rt->valid == 1 && rt->netif_t == netIfPtr) {
                        rtlglue_drvMutexUnlock();
                        return -2501;
                }
        }



        if ((netIfPtr->linkLayerType != 0)) { rtlglue_drvMutexUnlock(); return -2502; };

        if ((((&netIfPtr->inAclHead)->tqh_first) || ((&netIfPtr->outAclHead)->tqh_first))) { rtlglue_drvMutexUnlock(); return -2503; };




        netIfPtr->valid = 0;
        _rtl8651_arrangeAllACL();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 1895 "rtl8651_tblDrv.c"
int32 rtl8651_addExtNetworkInterface(int8 *ifName) {
        rtl8651_tblDrv_ipIntfEntry_t * thisIpEntry;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *localServer;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_vlanTable_t *vlanPtr;
        uint32 netIdx, ipCount, freeIpCount;
        uint16 vid;

        rtlglue_drvMutexLock();


        if (( (((&DrvTbl.inuseList.tcpudp)->tqh_count)>0) || (rtl8651ExistedNaptIcmpFlows>0) )) { rtlglue_drvMutexUnlock(); return -2508; };





        for(netIdx=0,netIfPtr=&DrvTbl.netIface[0], ipCount=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++,netIfPtr++)
                if(netIfPtr->valid == 1 && _strncmp(netIfPtr->ifName, ifName, 16) == 0 && netIfPtr->linkLayerType != 0) {




                        for((thisIpEntry) = (&(netIfPtr->IpHead))->slh_first; (thisIpEntry); (thisIpEntry) = (thisIpEntry)->nextIp.sle_next) {
                                do {} while (0);
                                for((localServer) = (&(thisIpEntry->localServer))->slh_first; (localServer); (localServer) = (localServer)->nextIpAddr.sle_next)
                                        ipCount++;
                        }
                        break;
                        }
        if ((netIdx==rtl8651_tblDrvPara.networkIntfTableSize)) { rtlglue_drvMutexUnlock(); return -7; };
        vid = netIfPtr->vid;
        vlanPtr = &DrvTbl.vlan[(vid& (8 -1))];


        if ((vlanPtr->internal == 0)) { rtlglue_drvMutexUnlock(); return -2509; };
        if ((netIfPtr->linkLayerType == 0x04)) { rtlglue_drvMutexUnlock(); return -2512; };




        freeIpCount = 16 - (naptIpCount + natIpCount + localServerCount);

        if ((freeIpCount < ipCount)) { rtlglue_drvMutexUnlock(); return -9; };
        do {} while (0);
        vlanPtr->internal = 0;
        RTL8651_SETASICVLAN(vlanPtr);



        _rtl8651_setExternalInterfaceforPPPoEPassthru( &vlanPtr->macAddr, vid );
        if ( rtl8651_l2protoPassThrough & (1<<0) ) _rtl8651_createProtocolBasedVLANforPPPoEPassthru();





        _rtl8651_setExternalInterfaceforIPv6Passthru( &vlanPtr->macAddr, vid );
        if ( rtl8651_l2protoPassThrough & (1<<1) ) _rtl8651_createProtocolBasedVLANforIPv6Passthru();





        _rtl8651_setExternalInterfaceforIPXPassthru( &vlanPtr->macAddr, vid );
        if ( rtl8651_l2protoPassThrough & (1<<2) ) _rtl8651_createProtocolBasedVLANforIPXPassthru();





        _rtl8651_setExternalInterfaceforNetbiosPassthru( &vlanPtr->macAddr, vid );
        if ( rtl8651_l2protoPassThrough & (1<<3) ) _rtl8651_createProtocolBasedVLANforNetbiosPassthru();




        for((thisIpEntry) = (&(netIfPtr->IpHead))->slh_first; (thisIpEntry); (thisIpEntry) = (thisIpEntry)->nextIp.sle_next) {
                for((localServer) = (&(thisIpEntry->localServer))->slh_first; (localServer); (localServer) = (localServer)->nextIpAddr.sle_next) {
                        rtl8651_tblDrv_ipEntry_t *retval;
                        retval = _rtl8651_addIpEntry(localServer->ipAddr, localServer->ipAddr, 0x02, ((void *)0));
                        do {} while (0);
                 }
        }

        if(freeIpCount == 16 && ipCount > 0)
                rtl8651_setAsicOperationLayer(4);
        rtl8651_memcpy(extIfName,ifName,8);
        _rtl8651_arrangeAllACL();


        _rtl8651_arrangeMulticastPortStatus();

        rtlglue_drvMutexUnlock();
        return 0;
}
# 2003 "rtl8651_tblDrv.c"
int32 rtl8651_delExtNetworkInterface(int8 * ifName) {
        rtl8651_tblDrv_ipIntfEntry_t * ipintf_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t * ipAddr;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t * localServer;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_vlanTable_t *vlanPtr;
        uint32 netIdx;
        uint16 vid;

        rtlglue_drvMutexLock();

        if (( (((&DrvTbl.inuseList.tcpudp)->tqh_count)>0) || (rtl8651ExistedNaptIcmpFlows>0) )) { rtlglue_drvMutexUnlock(); return -2508; };





        netIfPtr = GET_NETWORK_INTERFACE(ifName, &netIdx);
        if ((netIfPtr==((void *)0))) { rtlglue_drvMutexUnlock(); return -7; };
        vid = netIfPtr->vid;
        vlanPtr = &DrvTbl.vlan[(vid& (8 -1))];

        if ((vlanPtr->internal == 1)) { rtlglue_drvMutexUnlock(); return -2510; };

        if ((netIfPtr->linkLayerType == 0x04)) { rtlglue_drvMutexUnlock(); return -2512; }




        if (( (netIfPtr->nextNat.slh_first ) || (netIfPtr->nextNaptServerPort.slh_first) )) { rtlglue_drvMutexUnlock(); return -2513; };





        for((ipintf_t) = (&(netIfPtr->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                for((ipAddr) = (&(ipintf_t->ipAddr))->slh_first; (ipAddr); (ipAddr) = (ipAddr)->nextIpAddr.sle_next) {
                        if ((_rtl8651_isNaptMapping(ipAddr->ipAddr) == 1)) { rtlglue_drvMutexUnlock(); return -2513; };



                }
        }
        do {} while (0);
        do {} while (0);
        vlanPtr->internal = 1;
        RTL8651_SETASICVLAN(vlanPtr);

        for((ipintf_t) = (&(netIfPtr->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                for((localServer) = (&(ipintf_t->localServer))->slh_first; (localServer); (localServer) = (localServer)->nextIpAddr.sle_next) {
                        _rtl8651_delIpEntry(0x02, localServer->ipAddr, localServer->ipAddr);
                }
        }
        if(naptIpCount == 0 && natIpCount ==0 && localServerCount == 0)
                rtl8651_setAsicOperationLayer(3);
        _rtl8651_arrangeAllACL();


        _rtl8651_arrangeMulticastPortStatus();

        rtlglue_drvMutexUnlock();
        return 0;
}
# 2085 "rtl8651_tblDrv.c"
int32 rtl8651_addIpUnnumbered(int8 *wanIfName, int8 *lanIfName, ipaddr_t netMask) {
        rtl8651_tblDrv_networkIntfTable_t *wnetif_t, *lnetif_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;

        rtlglue_drvMutexLock();
        if ((!wanIfName || netMask == 0 || netMask == 0xffffffff)) { rtlglue_drvMutexUnlock(); return -6; };



        wnetif_t = GET_NETWORK_INTERFACE(wanIfName, ((void *)0));
        lnetif_t = GET_NETWORK_INTERFACE(lanIfName, ((void *)0));

        if (wnetif_t && lnetif_t) {

                if ((lanSideIpUnnumberedLan || lanSideIpUnnumberedWan)) { rtlglue_drvMutexUnlock(); return -2600; };



                if (( (wnetif_t->linkLayerType != 0x02) || (lnetif_t->linkLayerType != 0x01) )) { rtlglue_drvMutexUnlock(); return -2603; };




                vlan_t = &DrvTbl.vlan[(wnetif_t->vid& (8 -1))];
                if (( (DrvTbl.vlan[(lnetif_t->vid& (8 -1))].internal != 1) || (vlan_t->internal != 0) )) { rtlglue_drvMutexUnlock(); return -2601; };




                if ((((&wnetif_t->IpHead)->slh_first))) { rtlglue_drvMutexUnlock(); return -2602; };
                wnetif_t->linkLayerType = 0x04;
                lnetif_t->linkLayerType = 0x04;
                wnetif_t->netMask = netMask;
                lanSideIpUnnumberedWan = wnetif_t;
                lanSideIpUnnumberedLan = lnetif_t;
                vlan_t->ipAttached = 1;
                RTL8651_SETASICVLAN(vlan_t);
                rtlglue_drvMutexUnlock();
                return 0;
        } else if (wnetif_t && !lnetif_t) {

                if ((wnetif_t->linkLayerType != 0x02)) { rtlglue_drvMutexUnlock(); return -2610; };
                if ((DrvTbl.vlan[(wnetif_t->vid& (8 -1))].internal != 0)) { rtlglue_drvMutexUnlock(); return -2611; };



                wnetif_t->linkLayerType = 0x03;
                rtlglue_drvMutexUnlock();
                return 0;
        }
        rtlglue_drvMutexUnlock();
        return -7;
}
# 2148 "rtl8651_tblDrv.c"
int32 rtl8651_delIpUnnumbered(int8 *wanIfName, int8 *lanIfName) {
        rtl8651_tblDrv_networkIntfTable_t *wnetif_t, *lnetif_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;

        rtlglue_drvMutexLock();
        if ((!wanIfName)) { rtlglue_drvMutexUnlock(); return -6; };
        wnetif_t = GET_NETWORK_INTERFACE(wanIfName, ((void *)0));
        lnetif_t = GET_NETWORK_INTERFACE(lanIfName, ((void *)0));

        if (wnetif_t && lnetif_t) {

                if ((!lanSideIpUnnumberedLan || !lanSideIpUnnumberedWan)) { rtlglue_drvMutexUnlock(); return -2604; };



                if (( (wnetif_t->linkLayerType != 0x04) || (lnetif_t->linkLayerType != 0x04) )) { rtlglue_drvMutexUnlock(); return -2604; };




                vlan_t = &DrvTbl.vlan[(wnetif_t->vid& (8 -1))];
                if (( (DrvTbl.vlan[(lnetif_t->vid& (8 -1))].internal != 1) || (vlan_t->internal != 0) )) { rtlglue_drvMutexUnlock(); return -2604; };




                for((ipintf_t) = (&lnetif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                        if ((ipintf_t->lanSideExternal == 1)) { rtlglue_drvMutexUnlock(); return -2605; };
                        }
                wnetif_t->linkLayerType = 0x02;
                lnetif_t->linkLayerType = 0x01;
                wnetif_t->netMask = 0;
                lanSideIpUnnumberedWan = ((void *)0);
                lanSideIpUnnumberedLan = ((void *)0);
                vlan_t->ipAttached = 0;
                RTL8651_SETASICVLAN(vlan_t);
                rtlglue_drvMutexUnlock();
                return 0;

        } else if (wnetif_t && !lnetif_t) {

                if ((wnetif_t->linkLayerType != 0x03)) { rtlglue_drvMutexUnlock(); return -6; };



                wnetif_t->linkLayerType = 0x02;
                rtlglue_drvMutexUnlock();
                return 0;
        }
        rtlglue_drvMutexUnlock();
        return -7;
}
# 2215 "rtl8651_tblDrv.c"
int32 rtl8651_getIpUnnumbered(int8 *wanIfName, int8 *ifName, ipaddr_t *netMask) {
        rtl8651_tblDrv_networkIntfTable_t *wnetif_t;

        if ((!ifName || !netMask)) return -6;;
        rtlglue_drvMutexLock();
        wnetif_t = GET_NETWORK_INTERFACE(wanIfName, ((void *)0));
        if ((wnetif_t==((void *)0))) { rtlglue_drvMutexUnlock(); return -7; };
        if ((wnetif_t->linkLayerType < 0x03)) { rtlglue_drvMutexUnlock(); return -2606; };



        if (wnetif_t->linkLayerType == 0x03)
                _strncpy(ifName, wnetif_t->ifName, 16);
        else _strncpy(ifName, lanSideIpUnnumberedLan->ifName, 16);
        *netMask = wnetif_t->netMask;
        rtlglue_drvMutexUnlock();
        return 0;
}
# 2243 "rtl8651_tblDrv.c"
int32 rtl8651_urlUnknownTypeCaseSensitive(int8 enable)
{
        rtlglue_drvMutexLock();
        rtl8651_urlStringUnknownType_caseSensitive = enable;
        rtlglue_drvMutexUnlock();
        return 0;
}
# 2259 "rtl8651_tblDrv.c"
           int32 _rtl8651_findUrlFiltering(rtl8651_tblDrv_urlFilter_t *urlFilter)
{
        uint32 i, entry = -1;
        uint32 dsid = _rtl8651_SessionIDToDSID(urlFilter->sessionId);

        if ((urlFilter->urlFilterString == ((void *)0) || urlFilter->urlFilterStrLen == 0) && (urlFilter->pathFilterString == ((void *)0) || urlFilter->pathFilterStrLen == 0))
                return entry;

        for (i = 0; i < rtl8651_tblDrvPara.urlfilterDBSize * rtl8651_tblDrvPara.dialSessionNumber; i++)
        {
                if (_urlFilter.urlFilterStrLen[i] == 0 && _urlFilter.pathFilterStrLen[i] == 0)
                        continue;

                if (dsid != _urlFilter.sessionId[i])
                        continue;


                if (urlFilter->ruleType != _urlFilter.ruleType[i])
                        continue;



                if (urlFilter->urlFilterString && urlFilter->urlFilterStrLen != 0)
                {
                        if ((_urlFilter.urlFilterDB[i] && _urlFilter.urlFilterStrLen[i] != 0) && _urlFilter.urlFilterStrLen[i] == urlFilter->urlFilterStrLen &&
                                _urlFilter.urlExactlyMatch[i] == urlFilter->urlExactlyMatch)
                        {

                                if (urlFilter->ruleType == 0x1)
                                {
                                        if ( (rtl8651_urlStringUnknownType_caseSensitive && _strncmp(_urlFilter.urlFilterDB[i], urlFilter->urlFilterString, urlFilter->urlFilterStrLen) == 0) ||
                                                ( rtl8651_urlStringUnknownType_caseSensitive == 0 && _strncasecmp(_urlFilter.urlFilterDB[i], urlFilter->urlFilterString, urlFilter->urlFilterStrLen) == 0) )
                                                goto match_pathString;
                                        else
                                                continue;
                                }
                                else

                                {

                                        if ( _strncasecmp(_urlFilter.urlFilterDB[i], urlFilter->urlFilterString, urlFilter->urlFilterStrLen) == 0 )
                                                goto match_pathString;
                                        else
                                                continue;
                                }
                        }
                        else
                                continue;
                }
                else
                {
                        if (_urlFilter.urlFilterDB[i] && _urlFilter.urlFilterStrLen[i] != 0)
                                continue;
                        else
                                goto match_pathString;
                }

match_pathString:


                if (urlFilter->pathFilterString && urlFilter->pathFilterStrLen != 0)
                {
                        if ((_urlFilter.pathFilterDB[i] && _urlFilter.pathFilterStrLen[i] != 0) && _urlFilter.pathFilterStrLen[i] == urlFilter->pathFilterStrLen &&
                                _urlFilter.pathExactlyMatch[i] == urlFilter->pathExactlyMatch &&
                                _strncmp(_urlFilter.pathFilterDB[i], urlFilter->pathFilterString, urlFilter->pathFilterStrLen) == 0)
                        {
                                entry = i;
                                goto out;
                        }
                        else
                                continue;
                }
                else
                {
                        if (_urlFilter.pathFilterDB[i] && _urlFilter.pathFilterStrLen[i] != 0)
                                continue;
                        else
                        {
                                entry = i;
                                goto out;
                        }
                }

        }

out:
        return entry;

}
# 2402 "rtl8651_tblDrv.c"
static urlPktFiltering_t *_rtl8651_findUrlPktFiltering(int32 entry, rtl8651_tblDrv_urlPktFilter_t *filter, uint8 isExactlyMatch)
{
        urlPktFiltering_t *url_pf_t = ((void *)0);

        if ((entry < 0) || filter == ((void *)0))
                goto out;

        for((url_pf_t) = (&(_urlFilter.pktFilter[entry]))->slh_first; (url_pf_t); (url_pf_t) = (url_pf_t)->nextUse.sle_next)
        {
                if (filter->rule_type != url_pf_t->rule_type)
                        continue;

                switch (url_pf_t->rule_type)
                {
                        case 0x01:
                                if (isExactlyMatch == 1)
                                {
                                        if ((url_pf_t->sip_start==filter->sip_start) && (url_pf_t->sip_end==filter->sip_end))
                                                goto out;
                                }else
                                {
                                        if ((url_pf_t->sip_start<=filter->sip_start) && (url_pf_t->sip_end<=filter->sip_end))
                                                goto out;
                                }
                                break;
                        case 0x02:
                                if (memcmp(&(url_pf_t->smac), &(filter->smac), sizeof(ether_addr_t)) == 0)
                                        goto out;
                                break;
                }
        }


out:
        return url_pf_t;
}

static int32 _rtl8651_delUrlFiltering(rtl8651_tblDrv_urlFilter_t *urlFilter, rtl8651_tblDrv_urlPktFilter_t *pktFilter)
{
        int32 entry;
        rtl8651_tblDrv_urlPktFilter_t fake;

        if((!urlFilter->urlFilterString) && (!urlFilter->pathFilterString))
                return -6;
        if ((urlFilter->urlFilterString && urlFilter->urlFilterStrLen == 0) || (urlFilter->pathFilterString && urlFilter->pathFilterStrLen == 0))
                return -6;
        if (urlFilter->urlFilterStrLen > rtl8651_tblDrvPara.urlfilterStringLen - 1)
                return -4501;
        if (urlFilter->pathFilterStrLen > rtl8651_tblDrvPara.pathfilterStringLen - 1)
                return -4502;
        if (pktFilter && pktFilter->rule_type == 0)
                return -6;

        if (urlFilter->ruleType != 0x0 && urlFilter->ruleType != 0x1)
                return -4504;

        if (urlFilter->ruleType == 0x1 && urlFilter->pathFilterString != ((void *)0))
                return -4504;


        if ((entry = _rtl8651_findUrlFiltering(urlFilter)) >= 0)
        {
                urlPktFiltering_t *url_pf_t;

                if (pktFilter == ((void *)0))
                {


                        fake.rule_type = 0x01;
                        fake.sip_start = 0;
                        fake.sip_end = 0xffffffff;
                        pktFilter = &fake;
                }

                url_pf_t = _rtl8651_findUrlPktFiltering(entry, pktFilter, 1);

                if (url_pf_t)
                {
                        do { if ((&(_urlFilter.pktFilter[entry]))->slh_first == (url_pf_t)) { do { ((&(_urlFilter.pktFilter[entry])))->slh_first = ((&(_urlFilter.pktFilter[entry])))->slh_first->nextUse.sle_next; } while (0); } else { struct urlPktFiltering_s *curelm = (&(_urlFilter.pktFilter[entry]))->slh_first; while( curelm->nextUse.sle_next != (url_pf_t) ) curelm = curelm->nextUse.sle_next; curelm->nextUse.sle_next = curelm->nextUse.sle_next->nextUse.sle_next; } } while (0);
                        do { if ((&(DrvTbl.inuseList.urlPktFilter))->slh_first == (url_pf_t)) { do { ((&(DrvTbl.inuseList.urlPktFilter)))->slh_first = ((&(DrvTbl.inuseList.urlPktFilter)))->slh_first->next.sle_next; } while (0); } else { struct urlPktFiltering_s *curelm = (&(DrvTbl.inuseList.urlPktFilter))->slh_first; while( curelm->next.sle_next != (url_pf_t) ) curelm = curelm->next.sle_next; curelm->next.sle_next = curelm->next.sle_next->next.sle_next; } } while (0);
                        do { (url_pf_t)->next.sle_next = (&(DrvTbl.freeList.freeUrlPktFilter))->slh_first; (&(DrvTbl.freeList.freeUrlPktFilter))->slh_first = (url_pf_t); } while (0);
                } else
                {
                        goto not_found;
                }

                if (((&(_urlFilter.pktFilter[entry]))->slh_first) == ((void *)0))
                {
                        memset(_urlFilter.urlFilterDB[entry], 0, rtl8651_tblDrvPara.urlfilterStringLen);
                        memset(_urlFilter.pathFilterDB[entry], 0, rtl8651_tblDrvPara.pathfilterStringLen);
                        memset(_urlFilter.urlFilterJmpTbl[entry], 0, 256);
                        memset(_urlFilter.pathFilterJmpTbl[entry], 0, 256);
                        _urlFilter.urlFilterCount --;
                        _urlFilter.urlFilterStrLen[entry] = 0;
                        _urlFilter.pathFilterStrLen[entry] = 0;
                        _urlFilter.urlExactlyMatch[entry] = 0;
                        _urlFilter.pathExactlyMatch[entry] = 0;
                        _urlFilter.sessionId[entry] = 0;

                        _urlFilter.ruleType[entry] = 0;

                }
        }else
        {
                goto not_found;
        }

        if (_urlFilter.urlFilterCount == 0)
        {

                _rtl8651_arrangeAllACL();
# 2521 "rtl8651_tblDrv.c"
        }
        return 0;

not_found:
        return -3;

}


static int32 _rtl8651_addUrlFiltering(rtl8651_tblDrv_urlFilter_t *urlFilter, rtl8651_tblDrv_urlPktFilter_t *pktFilter)
{
        int32 entry;
        urlPktFiltering_t *url_pf_t;
        rtl8651_tblDrv_urlPktFilter_t fake;

        if((!urlFilter->urlFilterString) && (!urlFilter->pathFilterString))
                return -6;
        if ((urlFilter->urlFilterString && urlFilter->urlFilterStrLen == 0) || (urlFilter->pathFilterString && urlFilter->pathFilterStrLen == 0))
                return -6;
        if (urlFilter->urlFilterStrLen > rtl8651_tblDrvPara.urlfilterStringLen - 1)
                return -4501;
        if (urlFilter->pathFilterStrLen > rtl8651_tblDrvPara.pathfilterStringLen - 1)
                return -4502;
        if (pktFilter && pktFilter->rule_type == 0)
                return -6;

        if (urlFilter->ruleType != 0x0 && urlFilter->ruleType != 0x1)
                return -4504;

        if (urlFilter->ruleType == 0x1 && urlFilter->pathFilterString != ((void *)0))
                return -4504;



        if ((entry = _rtl8651_findUrlFiltering(urlFilter)) >= 0)
        {

                if (pktFilter && ((url_pf_t = _rtl8651_findUrlPktFiltering(entry, pktFilter, 1)) != ((void *)0)))
                {
                        return 0;
                }


                goto add_pktFilter;
        }


        for(entry = 0; entry < rtl8651_tblDrvPara.urlfilterDBSize * rtl8651_tblDrvPara.dialSessionNumber; entry++)
        {
                if (_urlFilter.urlFilterStrLen[entry] == 0 && _urlFilter.pathFilterStrLen[entry] == 0)
                {

                        if (((&(DrvTbl.freeList.freeUrlPktFilter))->slh_first) == ((void *)0))
                                return -9;

                        goto add_urlFilter_and_pktFilter;
                }
        }

        return -9;



add_urlFilter_and_pktFilter:



        if (urlFilter->urlFilterString && urlFilter->urlFilterStrLen != 0) {



                if (urlFilter->ruleType == 0x1 && rtl8651_urlStringUnknownType_caseSensitive)
                _strncpy(_urlFilter.urlFilterDB[entry], urlFilter->urlFilterString, urlFilter->urlFilterStrLen);
                else
                        __strlowerncpy(_urlFilter.urlFilterDB[entry], urlFilter->urlFilterString, urlFilter->urlFilterStrLen);





                _urlFilter.urlFilterDB[entry][urlFilter->urlFilterStrLen] = '\0';
                _urlFilter.urlFilterStrLen[entry] = urlFilter->urlFilterStrLen;
                _urlFilter.urlExactlyMatch[entry] = urlFilter->urlExactlyMatch;

                if (urlFilter->ruleType == 0x1)
                {
                        mBuf_getBMjmpTable( (uint8 *)_urlFilter.urlFilterDB[entry],
                                                                        (uint16 *)_urlFilter.urlFilterJmpTbl[entry],
                                                                        urlFilter->urlFilterStrLen,
                                                                        rtl8651_urlStringUnknownType_caseSensitive? 1: 0);
        }
                else

                {
                        mBuf_getBMjmpTable((uint8 *)_urlFilter.urlFilterDB[entry], (uint16 *)_urlFilter.urlFilterJmpTbl[entry], urlFilter->urlFilterStrLen, 0);
                }
                }

        if (urlFilter->pathFilterString && urlFilter->pathFilterStrLen != 0) {
                _strncpy(_urlFilter.pathFilterDB[entry], urlFilter->pathFilterString, urlFilter->pathFilterStrLen);
                _urlFilter.pathFilterDB[entry][urlFilter->pathFilterStrLen] = '\0';
                _urlFilter.pathFilterStrLen[entry] = urlFilter->pathFilterStrLen;
                _urlFilter.pathExactlyMatch[entry] = urlFilter->pathExactlyMatch;
                mBuf_getBMjmpTable((uint8 *)_urlFilter.pathFilterDB[entry], (uint16 *)_urlFilter.pathFilterJmpTbl[entry], urlFilter->pathFilterStrLen, 1);
        }
        _urlFilter.sessionId[entry] = _rtl8651_SessionIDToDSID(urlFilter->sessionId);
        _urlFilter.urlFilterCount++;

        _urlFilter.ruleType[entry] = urlFilter->ruleType;






        if (_urlFilter.urlFilterCount == 1)
        {

                _rtl8651_arrangeAllACL();
# 2657 "rtl8651_tblDrv.c"
        }

add_pktFilter:

        if (pktFilter == ((void *)0))
        {
                memset(&fake, 0, sizeof(rtl8651_tblDrv_urlPktFilter_t));


                fake.rule_type = 0x01;
                fake.sip_start = 0;
                fake.sip_end = 0xffffffff;
                pktFilter = &fake;
                if ((url_pf_t = _rtl8651_findUrlPktFiltering(entry, pktFilter, 1)) != ((void *)0))
                        return 0;
        }

        if ((url_pf_t = ((&(DrvTbl.freeList.freeUrlPktFilter))->slh_first)) == ((void *)0))
        {
                return -9;
        }

        do { if ((&(DrvTbl.freeList.freeUrlPktFilter))->slh_first == (url_pf_t)) { do { ((&(DrvTbl.freeList.freeUrlPktFilter)))->slh_first = ((&(DrvTbl.freeList.freeUrlPktFilter)))->slh_first->next.sle_next; } while (0); } else { struct urlPktFiltering_s *curelm = (&(DrvTbl.freeList.freeUrlPktFilter))->slh_first; while( curelm->next.sle_next != (url_pf_t) ) curelm = curelm->next.sle_next; curelm->next.sle_next = curelm->next.sle_next->next.sle_next; } } while (0);
        do { (url_pf_t)->next.sle_next = (&(DrvTbl.inuseList.urlPktFilter))->slh_first; (&(DrvTbl.inuseList.urlPktFilter))->slh_first = (url_pf_t); } while (0);
        do { (url_pf_t)->nextUse.sle_next = (&(_urlFilter.pktFilter[entry]))->slh_first; (&(_urlFilter.pktFilter[entry]))->slh_first = (url_pf_t); } while (0);


        url_pf_t->rule_type = pktFilter->rule_type;
        url_pf_t->sip_start = pktFilter->sip_start;
        url_pf_t->sip_end = pktFilter->sip_end;
        memcpy(&(url_pf_t->smac), &(pktFilter->smac) ,sizeof(ether_addr_t));

        return 0;


}
# 2702 "rtl8651_tblDrv.c"
static int32 _rtl8651_initURLfilter(void){


        _urlFilterAclRuleNum=-1;
        _rtl8651_arrangeAllACL();
# 2724 "rtl8651_tblDrv.c"
        return 0;
}
# 2740 "rtl8651_tblDrv.c"
int32 rtl8651a_addURLfilterString(uint32 sessionId, int8 *string, int32 strlen)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;

        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 0;
        urlFilter.sessionId = sessionId;

        rtlglue_drvMutexLock();
        retval = _rtl8651_addUrlFiltering(&urlFilter, ((void *)0));
        rtlglue_drvMutexUnlock();


        rtlglue_free(urlFilter.urlFilterString);

out:
        return retval;
}
# 2784 "rtl8651_tblDrv.c"
int32 rtl8651a_addURLExactlyfilterString(uint32 sessionId, int8 *string, int32 strlen)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;

        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 1;
        urlFilter.sessionId = sessionId;

        rtlglue_drvMutexLock();
        retval = _rtl8651_addUrlFiltering(&urlFilter, ((void *)0));
        rtlglue_drvMutexUnlock();


        rtlglue_free(urlFilter.urlFilterString);
out:
        return retval;
}
# 2823 "rtl8651_tblDrv.c"
int32 rtl8651a_delURLfilterString(uint32 sessionId, int8 *string, int32 strlen)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;

        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 0;
        urlFilter.sessionId = sessionId;

        rtlglue_drvMutexLock();
        retval = _rtl8651_delUrlFiltering(&urlFilter, ((void *)0));
        rtlglue_drvMutexUnlock();


        rtlglue_free(urlFilter.urlFilterString);

out:
        return retval;
}
# 2863 "rtl8651_tblDrv.c"
int32 rtl8651a_delURLExactlyfilterString(uint32 sessionId, int8 *string, int32 strlen)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;

        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 1;
        urlFilter.sessionId = sessionId;

        rtlglue_drvMutexLock();
        retval = _rtl8651_delUrlFiltering(&urlFilter, ((void *)0));
        rtlglue_drvMutexUnlock();


        rtlglue_free(urlFilter.urlFilterString);

out:
        return retval;
}
# 2906 "rtl8651_tblDrv.c"
int32 rtl8651_addURLFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;
        rtl8651_tblDrv_urlPktFilter_t pktFilter;


        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 0;
        urlFilter.sessionId = sessionId;


        if (ip_start > ip_end) {
                retval = -6;
                goto out1;
        }

        pktFilter.rule_type = 0x01;
        if (ip_start == 0 && ip_end == 0)
        {
                pktFilter.sip_start = 0;
                pktFilter.sip_end = 0xffffffff;
        }else
        {
                pktFilter.sip_start = ip_start;
                pktFilter.sip_end = ip_end;
        }

        rtlglue_drvMutexLock();
        retval = _rtl8651_addUrlFiltering(&urlFilter, &pktFilter);
        rtlglue_drvMutexUnlock();

out1:

        rtlglue_free(urlFilter.urlFilterString);
out:
        return retval;

}
# 2973 "rtl8651_tblDrv.c"
int32 rtl8651_addURLExactlyFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;
        rtl8651_tblDrv_urlPktFilter_t pktFilter;


        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 1;
        urlFilter.sessionId = sessionId;


        if (ip_start > ip_end) {
                retval = -6;
                goto out1;
        }

        pktFilter.rule_type = 0x01;
        if (ip_start == 0 && ip_end == 0)
        {
                pktFilter.sip_start = 0;
                pktFilter.sip_end = 0xffffffff;
        }else
        {
                pktFilter.sip_start = ip_start;
                pktFilter.sip_end = ip_end;
        }

        rtlglue_drvMutexLock();
        retval = _rtl8651_addUrlFiltering(&urlFilter, &pktFilter);
        rtlglue_drvMutexUnlock();

out1:

        rtlglue_free(urlFilter.urlFilterString);
out:
        return retval;
}
# 3032 "rtl8651_tblDrv.c"
int32 rtl8651_delURLFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;
        rtl8651_tblDrv_urlPktFilter_t pktFilter;


        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 0;
        urlFilter.sessionId = sessionId;


        if (ip_start > ip_end) {
                retval = -6;
                goto out1;
        }

        pktFilter.rule_type = 0x01;
        if (ip_start == 0 && ip_end == 0)
        {
                pktFilter.sip_start = 0;
                pktFilter.sip_end = 0xffffffff;
        }else
        {
                pktFilter.sip_start = ip_start;
                pktFilter.sip_end = ip_end;
        }

        rtlglue_drvMutexLock();
        retval = _rtl8651_delUrlFiltering(&urlFilter, &pktFilter);
        rtlglue_drvMutexUnlock();

out1:

        rtlglue_free(urlFilter.urlFilterString);
out:
        return retval;
}
# 3091 "rtl8651_tblDrv.c"
int32 rtl8651_delURLExactlyFilterRule(uint32 sessionId, int8 *string, int32 strlen, ipaddr_t ip_start, ipaddr_t ip_end)
{
        int32 retval;
        rtl8651_tblDrv_urlFilter_t urlFilter;
        rtl8651_tblDrv_urlPktFilter_t pktFilter;


        bzero(&urlFilter, sizeof(rtl8651_tblDrv_urlFilter_t));
        urlFilter.urlFilterString = (int8 *)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterStringLen);
        if (urlFilter.urlFilterString == ((void *)0))
        {
                retval = -4503;
                goto out;
        }
        _strncpy(urlFilter.urlFilterString, string, strlen);
        urlFilter.urlFilterStrLen = strlen;
        urlFilter.urlExactlyMatch = 1;
        urlFilter.sessionId = sessionId;


        if (ip_start > ip_end) {
                retval = -6;
                goto out1;
        }

        pktFilter.rule_type = 0x01;
        if (ip_start == 0 && ip_end == 0)
        {
                pktFilter.sip_start = 0;
                pktFilter.sip_end = 0xffffffff;
        }else
        {
                pktFilter.sip_start = ip_start;
                pktFilter.sip_end = ip_end;
        }

        rtlglue_drvMutexLock();
        retval = _rtl8651_delUrlFiltering(&urlFilter, &pktFilter);
        rtlglue_drvMutexUnlock();

out1:

        rtlglue_free(urlFilter.urlFilterString);
out:
        return retval;
}
# 3147 "rtl8651_tblDrv.c"
int32 rtl8651_registerURLFilterCallBackFunction(rtl8651_tblDrv_urlFiltering_CallBackFunc_t callBackFunc)
{
        rtlglue_drvMutexLock();
        _urlFilter.callBackFunc = (urlFiltering_CallBackFunc_t)callBackFunc;
        rtlglue_drvMutexUnlock();
        return 0;
}

static int32 _rtl8651_checkGenericPktFilterRule(rtl8651_tblDrv_urlPktFilter_t *pktFilter)
{
        int32 retval = 0;
        if (pktFilter)
        {
                switch (pktFilter->rule_type)
                {
                        case 0x01:
                                if (pktFilter->sip_start > pktFilter->sip_end)
                                        retval = -6;
                                break;
                        case 0x02:
                                break;
                        default:
                                retval = -6;
                }
        }
        return retval;
}
# 3197 "rtl8651_tblDrv.c"
int32 rtl8651_addGenericURLFilterRule(rtl8651_tblDrv_urlFilter_t *urlFilter, rtl8651_tblDrv_urlPktFilter_t *pktFilter)
{
        int32 retval;

        if (!urlFilter)
                return -6;
        if ((retval = _rtl8651_checkGenericPktFilterRule(pktFilter)) != 0)
                return retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_addUrlFiltering(urlFilter, pktFilter);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 3225 "rtl8651_tblDrv.c"
int32 rtl8651_delGenericURLFilterRule(rtl8651_tblDrv_urlFilter_t *urlFilter, rtl8651_tblDrv_urlPktFilter_t *pktFilter)
{
        int32 retval;

        if ((retval = _rtl8651_checkGenericPktFilterRule(pktFilter)) != 0)
                return retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_delUrlFiltering(urlFilter, pktFilter);
        rtlglue_drvMutexUnlock();
        return retval;
}


static int _rtl8651_initUrlFilterTrustedUserDb(void){


        if (rtl8651_tblDrvPara.urlfilterTrustedUserEntryCnt == 0)
        {
                return 0;
        }

        do { urlFilterTrustedUsers = (void*)rtlglue_malloc(rtl8651_tblDrvPara.urlfilterTrustedUserEntryCnt * sizeof(uint32)); if ( urlFilterTrustedUsers ) do { if (rtl8651_tblDrvPara.urlfilterTrustedUserEntryCnt * sizeof(uint32)) { memset(urlFilterTrustedUsers, 0, rtl8651_tblDrvPara.urlfilterTrustedUserEntryCnt * sizeof(uint32)); } } while (0);; } while (0);;

        if ( urlFilterTrustedUsers == ((void *)0) )
        {
                return -1;
        }

        _rtl8651_ReinitUrlFilterTrustedUserDb();

        return 0;

}

static void _rtl8651_ReinitUrlFilterTrustedUserDb(void){
        memset(urlFilterTrustedUsers,0,sizeof(uint32)*rtl8651_tblDrvPara.urlfilterTrustedUserEntryCnt);
}
# 3274 "rtl8651_tblDrv.c"
int rtl8651_addUrlFilterTrustedUser(uint32 ipaddr){
        int i;
        rtlglue_drvMutexLock();
        for(i=0;i<rtl8651_tblDrvPara.urlfilterTrustedUserEntryCnt;i++)
        {
                if(urlFilterTrustedUsers[i]==0)
                {
                        urlFilterTrustedUsers[i]=ipaddr;
                        rtlglue_drvMutexUnlock();
                        return 0;
                }
        }
        rtlglue_drvMutexUnlock();
        return -1;
}







void rtl8651_flushUrlFilterTrustedUser(void){
        rtlglue_drvMutexLock();
        _rtl8651_ReinitUrlFilterTrustedUserDb();
        rtlglue_drvMutexUnlock();

}

static int _rtl8651_isUrlFilterTrustedUser(uint32 ipaddr){
        int i;
        for(i=0;i<rtl8651_tblDrvPara.urlfilterTrustedUserEntryCnt;i++)
        {
                if(urlFilterTrustedUsers[i]==0) break;
                if(urlFilterTrustedUsers[i]==ipaddr)
                        return 0;
        }
        return -1;
}


int32 _rtl8651_urlFilter(uint32 dsid, struct rtl_pktHdr *phdr, struct ip *pip, uint8 dir, int8 *string, int32 *strlen)
{
        uint8 httphdrPattern[5]="\r\n\r\n";
        uint8 urlHostPattern[9] = "\r\nHost: ";
        uint8 urlGetPattern[6] = "GET \\";
        uint8 urlGet1Pattern[5] = "GET ";
        uint8 urlhttpPattern[8] = "http://";
        uint8 pathGetPattern[5] = "GET /";
        int32 pos, entry=0, dn, match=0, count=0, c=0, m_len, shift;
        int32 path_dn, path_match=0, path_c=0, path_m_len, path_shift;
        uint8 *char_t, pchar, *match_t, action;
        uint8 *path_char_t, path_pchar, *path_match_t;

        do {} while (0);

        pos = mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, phdr->ph_len, (uint8*)httphdrPattern, 4, _urlFilter.urlHdrJmpTbl, 1);
        if (pos < 1)
                return -1;






        if ((dn=mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, pos, urlHostPattern, 8, _urlFilter.urlHostJmpTbl, 1)) >= 1) {
                shift = dn + 8;
                match_t = (uint8 *)&phdr->PKTHDRNXT.mbuf_first->m_data[shift];
        }

        else if ((dn=mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, pos, urlGetPattern, 5, _urlFilter.urlGetJmpTbl, 1)) >= 1) {
                shift = dn + 5;
                match_t = (uint8 *)&phdr->PKTHDRNXT.mbuf_first->m_data[shift];
        }

        else if ((dn=mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, pos, urlGet1Pattern, 4, _urlFilter.urlGet1JmpTbl, 1)) >= 1) {
                int32 dn1;
                shift = dn + 4;

                if ((dn1 = mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, pos, urlhttpPattern, 7, _urlFilter.urlhttpJmpTbl, 0)) == shift) {
                        shift = dn1 + 7;
                match_t = (uint8 *)&phdr->PKTHDRNXT.mbuf_first->m_data[shift];
        }
        else
                return -1;
        }
        else
                return -1;


        do {} while (0);
        c = 0;
        m_len = phdr->PKTHDRNXT.mbuf_first->m_len - dn + 1;
        char_t = match_t;
        pchar = *char_t;
        while(c < m_len && pchar != ' ' && pchar != '/' && pchar != '?' && pchar != '\\' && pchar != '\r' && pchar != '\n' && c < (128 -1)) {
                c++;
                pchar = *(++char_t);
        }

        if (c == 0)
                return -1;






        if ((path_dn = mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, pos, pathGetPattern, 5, _urlFilter.pathGetJmpTbl, 1)) >= 1) {
                path_shift = path_dn + 5;
                path_match_t = (uint8 *)&phdr->PKTHDRNXT.mbuf_first->m_data[path_shift];


                path_c = 0;
                path_m_len = phdr->PKTHDRNXT.mbuf_first->m_len - path_dn + 1;
                path_char_t = path_match_t;
                path_pchar = *path_char_t;
                while(path_c < path_m_len && path_pchar != ' ') {
                        path_c++;
                        path_pchar = *(++path_char_t);
                }
        }

        else if ((path_dn=mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, pos, urlGet1Pattern, 4, _urlFilter.urlGet1JmpTbl, 1)) >= 1) {
                int32 path_dn1;
                path_shift = path_dn + 4;

                if ((path_dn1 = mBuf_BMpatternMatch(phdr->PKTHDRNXT.mbuf_first, pos, urlhttpPattern, 7, _urlFilter.urlhttpJmpTbl, 0)) == path_shift) {
                        path_shift = path_dn1 + 7;
                path_char_t = (uint8 *)&phdr->PKTHDRNXT.mbuf_first->m_data[path_shift];
                path_pchar = *path_char_t;
                while(path_pchar != '/') {
                        path_shift++;
                        path_pchar = *(++path_char_t);
                }
                path_match_t = (uint8 *)&phdr->PKTHDRNXT.mbuf_first->m_data[path_shift];


                path_c = 0;
                path_m_len = phdr->PKTHDRNXT.mbuf_first->m_len - path_shift + 1;
                path_char_t = path_match_t;
                path_pchar = *path_char_t;
                while(path_c < path_m_len && path_pchar != ' ') {
                        path_c++;
                        path_pchar = *(++path_char_t);
                }
        }
        else
                return -1;
        }
        else
                return -1;



        action = 3;

        if(dir==0)
        {
                if(_rtl8651_isUrlFilterTrustedUser(phdr->ph_sip)==0)
                {
                        goto _logging_it;
                }
        }
        else
        {
                if(_rtl8651_isUrlFilterTrustedUser(phdr->ph_dip)==0)
                {
                        goto _logging_it;
                }
        }


        for(entry = 0; entry < rtl8651_tblDrvPara.urlfilterDBSize * rtl8651_tblDrvPara.dialSessionNumber &&
              count < _urlFilter.urlFilterCount; entry++) {

                int32 stringLen, path_stringLen, compareLen, path_compareLen;

                if (_urlFilter.urlFilterStrLen[entry] == 0 && _urlFilter.pathFilterStrLen[entry] == 0)
                        continue;
                count++;
                if (_urlFilter.sessionId[entry] != dsid)
                        continue;
                if (_urlFilter.urlExactlyMatch[entry] && c != _urlFilter.urlFilterStrLen[entry])
                        continue;
                if (_urlFilter.pathExactlyMatch[entry] && path_c != _urlFilter.pathFilterStrLen[entry])
                        continue;

                        stringLen = c;
                path_stringLen = path_c;
                        compareLen = _urlFilter.urlFilterStrLen[entry];
                path_compareLen = _urlFilter.pathFilterStrLen[entry];


                if ( _urlFilter.ruleType[entry] == 0x1 )
                {

                        path_match = -1;

                        if ( compareLen <= path_stringLen )
                        {
                                phdr->PKTHDRNXT.mbuf_first->m_data += path_shift;
                                phdr->ph_len -= path_shift;
                                phdr->PKTHDRNXT.mbuf_first->m_len -= path_shift;
                                path_match = mBuf_BMpatternMatch( phdr->PKTHDRNXT.mbuf_first,
                                                                                                        path_stringLen,
                                                                                                        _urlFilter.urlFilterDB[entry] ,
                                                                                                        compareLen ,
                                                                                                        _urlFilter.urlFilterJmpTbl[entry] ,
                                                                                                        rtl8651_urlStringUnknownType_caseSensitive? 1: 0 );
                                phdr->PKTHDRNXT.mbuf_first->m_data -= path_shift;
                                phdr->ph_len += path_shift;
                                phdr->PKTHDRNXT.mbuf_first->m_len += path_shift;
                }


                        if (path_match >= 0)
                        {

                                urlPktFiltering_t *url_pf_t;
                                ipaddr_t ip_src;
                                ether_addr_t mac_src;

                                ip_src = phdr->ph_sip;
                                memcpy(&mac_src, &(phdr->PKTHDRNXT.mbuf_first->m_data[6]), sizeof(ether_addr_t));

                                for((url_pf_t) = (&(_urlFilter.pktFilter[entry]))->slh_first; (url_pf_t); (url_pf_t) = (url_pf_t)->nextUse.sle_next) {
                                        switch (url_pf_t->rule_type) {
                                                case 0x01:
                                                        if (ip_src >= url_pf_t->sip_start && ip_src <= url_pf_t->sip_end)
                                                                goto _illegal_url_;
                                                        break;
                                                case 0x02:
                                                        if (memcmp(&mac_src, &(url_pf_t->smac), sizeof(ether_addr_t)) == 0)
                                                                goto _illegal_url_;
                                                        break;
                                        }
                                }
                        }
                        else
                        {
                                int32 prefixLen = 0;
                                char_t = _urlFilter.urlFilterDB[entry];
                                pchar = *char_t;

                                while ( pchar != '/' )
                                {
                                        prefixLen++;
                                        if ( prefixLen >= compareLen )
                                                break;
                                        pchar = *(++char_t);
                                }


                                if ( prefixLen < compareLen )
                                {
                                        if ( stringLen >= prefixLen )
                                        {
                                                int32 postfixLen = 0;
                                                postfixLen = _urlFilter.urlFilterStrLen[entry] - prefixLen - 1;

                                                match = 0;

                                                if ( prefixLen != 0 )
                                                {
                                                        int32 host_shift = shift + stringLen - prefixLen;

                                                        phdr->PKTHDRNXT.mbuf_first->m_data += host_shift;

                                                        match = _strncasecmp(phdr->PKTHDRNXT.mbuf_first->m_data, _urlFilter.urlFilterDB[entry], prefixLen);
                                                        phdr->PKTHDRNXT.mbuf_first->m_data -= host_shift;
                                                }

                                                if ( match == 0 )
                                                {
                                                        path_match = 0;

                                                        phdr->PKTHDRNXT.mbuf_first->m_data += path_shift;


                                                        if (rtl8651_urlStringUnknownType_caseSensitive)
                                                                path_match = _strncmp(phdr->PKTHDRNXT.mbuf_first->m_data, ++char_t, postfixLen);
                                                        else
                                                                path_match = _strncasecmp(phdr->PKTHDRNXT.mbuf_first->m_data, ++char_t, postfixLen);

                                                        phdr->PKTHDRNXT.mbuf_first->m_data -= path_shift;
                                                        if ( path_match == 0 )
                                                        {

                                                                urlPktFiltering_t *url_pf_t;
                                                                ipaddr_t ip_src;
                                                                ether_addr_t mac_src;

                                                                ip_src = phdr->ph_sip;
                                                                memcpy(&mac_src, &(phdr->PKTHDRNXT.mbuf_first->m_data[6]), sizeof(ether_addr_t));

                                                                for((url_pf_t) = (&(_urlFilter.pktFilter[entry]))->slh_first; (url_pf_t); (url_pf_t) = (url_pf_t)->nextUse.sle_next) {
                                                                        switch (url_pf_t->rule_type) {
                                                                                case 0x01:
                                                                                        if (ip_src >= url_pf_t->sip_start && ip_src <= url_pf_t->sip_end)
                                                                                                goto _illegal_url_;
                                                                                        break;
                                                                                case 0x02:
                                                                                        if (memcmp(&mac_src, &(url_pf_t->smac), sizeof(ether_addr_t)) == 0)
                                                                                                goto _illegal_url_;
                                                                                        break;
                                                                        }
                                                                }

                                                        }
                                                }
                                        }
                                }
                                else

                                {
                                        match = -1;
                                        if ( compareLen <= stringLen )
                                        {
                                                phdr->PKTHDRNXT.mbuf_first->m_data += shift;
                                                phdr->ph_len -= shift;
                                                phdr->PKTHDRNXT.mbuf_first->m_len -= shift;
                                                match = mBuf_BMpatternMatch( phdr->PKTHDRNXT.mbuf_first,
                                                                                                                stringLen,
                                                                                                                _urlFilter.urlFilterDB[entry],
                                                                                                                compareLen,
                                                                                                                _urlFilter.urlFilterJmpTbl[entry], 0);
                                                phdr->PKTHDRNXT.mbuf_first->m_data -= shift;
                                                phdr->ph_len += shift;
                                                phdr->PKTHDRNXT.mbuf_first->m_len += shift;
                                        }
                                        if (match >= 0)
                                        {

                                                urlPktFiltering_t *url_pf_t;
                                                ipaddr_t ip_src;
                                                ether_addr_t mac_src;

                                                ip_src = phdr->ph_sip;
                                                memcpy(&mac_src, &(phdr->PKTHDRNXT.mbuf_first->m_data[6]), sizeof(ether_addr_t));

                                                for((url_pf_t) = (&(_urlFilter.pktFilter[entry]))->slh_first; (url_pf_t); (url_pf_t) = (url_pf_t)->nextUse.sle_next) {
                                                        switch (url_pf_t->rule_type) {
                                                                case 0x01:
                                                                        if (ip_src >= url_pf_t->sip_start && ip_src <= url_pf_t->sip_end)
                                                                                goto _illegal_url_;
                                                                        break;
                                                                case 0x02:
                                                                        if (memcmp(&mac_src, &(url_pf_t->smac), sizeof(ether_addr_t)) == 0)
                                                                                goto _illegal_url_;
                                                                        break;
                                                        }
                                                }
                                        }
                                }
                        }


                }
                else

                {
                        if (c < _urlFilter.urlFilterStrLen[entry] && path_c < _urlFilter.pathFilterStrLen[entry])
                                continue;


                match = 0;

                if (compareLen != 0) {
                        phdr->PKTHDRNXT.mbuf_first->m_data += shift;
                        phdr->ph_len -= shift;
                        phdr->PKTHDRNXT.mbuf_first->m_len -= shift;
                        match = mBuf_BMpatternMatch( phdr->PKTHDRNXT.mbuf_first,
                                                                                        stringLen,
                                                                                        _urlFilter.urlFilterDB[entry],
                                                                                        compareLen,
                                                                                                _urlFilter.urlFilterJmpTbl[entry], 0);
                        phdr->PKTHDRNXT.mbuf_first->m_data -= shift;
                        phdr->ph_len += shift;
                        phdr->PKTHDRNXT.mbuf_first->m_len += shift;
                }

                if (match >= 0) {

                        path_match = 0;

                        if (path_compareLen != 0) {
                                phdr->PKTHDRNXT.mbuf_first->m_data += path_shift;
                                phdr->ph_len -= path_shift;
                                phdr->PKTHDRNXT.mbuf_first->m_len -= path_shift;
                                path_match = mBuf_BMpatternMatch( phdr->PKTHDRNXT.mbuf_first,
                                                                                                        path_stringLen,
                                                                                                        _urlFilter.pathFilterDB[entry],
                                                                                                        path_compareLen,
                                                                                                                _urlFilter.pathFilterJmpTbl[entry], 1);
                                phdr->PKTHDRNXT.mbuf_first->m_data -= path_shift;
                                phdr->ph_len += path_shift;
                                phdr->PKTHDRNXT.mbuf_first->m_len += path_shift;
                        }
                        if (path_match >= 0) {

                                urlPktFiltering_t *url_pf_t;
                                ipaddr_t ip_src;
                                ether_addr_t mac_src;

                                ip_src = phdr->ph_sip;
                                memcpy(&mac_src, &(phdr->PKTHDRNXT.mbuf_first->m_data[6]), sizeof(ether_addr_t));

                                for((url_pf_t) = (&(_urlFilter.pktFilter[entry]))->slh_first; (url_pf_t); (url_pf_t) = (url_pf_t)->nextUse.sle_next) {
                                        switch (url_pf_t->rule_type) {
                                                case 0x01:
                                                        if (ip_src >= url_pf_t->sip_start && ip_src <= url_pf_t->sip_end)
                                                                goto _illegal_url_;
                                                        break;
                                                case 0x02:
                                                        if (memcmp(&mac_src, &(url_pf_t->smac), sizeof(ether_addr_t)) == 0)
                                                                goto _illegal_url_;
                                                        break;
                                        }
                                }
                        }
                }
        }
        }
        goto _logging_it;

_illegal_url_:

        {
                int32 max = _urlFilter.urlFilterStrLen[entry] > (*strlen)-1 ? (*strlen-1) : _urlFilter.urlFilterStrLen[entry];
                do {} while (0);
                _strncpy(string, _urlFilter.urlFilterDB[entry], max);

                string[max] = '\0';
                *strlen = max;
                action = 1;


                if (_urlFilter.callBackFunc)
                {
                        char url[128] = {0};
                        char path[128] = {0};
                        int32 urlMax = (c > (128 - 1)) ? (128 - 1) : c;

                        _strncpy(url, match_t, urlMax);

                        if (_urlFilter.pathFilterStrLen[entry] > 0)
                        {
                                int32 pathMax = (_urlFilter.pathFilterStrLen[entry] > (128 -1))?
                                                                (128 -1):
                                                                (_urlFilter.pathFilterStrLen[entry]);

                                _strncpy( path,
                                                        _urlFilter.pathFilterDB[entry],
                                                        pathMax);
                        }
                        _urlFilter.callBackFunc(dsid, phdr, pip, url, path);
                }
        }

_logging_it:

        do {} while (0);
# 3751 "rtl8651_tblDrv.c"
        {
                ipaddr_t sip = phdr->ph_sip;
                ipaddr_t dip = phdr->ph_dip;
                struct tcphdr *tc = ((void *)0);
                uint16 sport = 0xffff;
                uint16 dport = 0xffff;

                if (((pip->ip_off) & 0x1fff) == 0)
                {
                        tc=(struct tcphdr *) ((int8 *) pip + ((*(uint8*)pip&0xf) << 2));
                        sport = (tc->th_sport);
                        dport = (tc->th_dport);
                }

                memset(_urlFilter.urlString, 0, 128);
                rtl8651_memcpy((void*)_urlFilter.urlString, match_t, c>(128 -1)?(128 -1):c);


                if ( path_c > 0 )
                {
                        memset(_urlFilter.log_pathString, 0, 128);
                        rtl8651_memcpy((void *)_urlFilter.log_pathString, path_match_t, path_c > (128 - 1)? (128 - 1): path_c);
                }

                if ( _urlFilter.urlFilterStrLen[entry] > 0 )
                {
                        memset(_urlFilter.log_urlFilterString, 0, 128);
                        rtl8651_memcpy((void *)_urlFilter.log_urlFilterString, _urlFilter.urlFilterDB[entry], _urlFilter.urlFilterStrLen[entry] > (128 - 1)? (128 - 1): _urlFilter.urlFilterStrLen[entry]);
                }

                if ( _urlFilter.pathFilterStrLen[entry] > 0 )
                {
                        memset(_urlFilter.log_pathFilterString, 0, 128);
                        rtl8651_memcpy((void *)_urlFilter.log_pathFilterString, _urlFilter.pathFilterDB[entry], _urlFilter.pathFilterStrLen[entry] > (128 - 1)? (128 - 1): _urlFilter.pathFilterStrLen[entry]);
                }


                if ((_loggingModule[dsid]&0x00000008)&&_pUserLoggingFunc)
                {

                rtl8651_logInfo_t info;
                info.infoType = 2;
                info.un.url.dsid = dsid;
                info.un.url.sip = sip;
                info.un.url.dip = dip;
                info.un.url.protocol = pip->ip_p;
                info.un.url.direction = dir;
                info.un.url.sport = sport;
                info.un.url.dport = dport;
                info.un.url.string = _urlFilter.urlString;

                if ( path_c > 0 )
                        info.un.url.pathString = _urlFilter.log_pathString;
                else
                        info.un.url.pathString = '\0';

                if ( _urlFilter.urlFilterStrLen[entry] > 0 )
                        info.un.url.urlFilterString = _urlFilter.log_urlFilterString;
                else
                        info.un.url.urlFilterString = '\0';

                if ( _urlFilter.pathFilterStrLen[entry] > 0 )
                        info.un.url.pathFilterString = _urlFilter.log_pathFilterString;
                else
                        info.un.url.pathFilterString = '\0';

                info.action = action;
                (* _pUserLoggingFunc)(0x00000008, 7, &info);
# 3833 "rtl8651_tblDrv.c"
                }
        }


        if (action == 1)
                return (shift+match);
        else
                return -1;
}
# 3853 "rtl8651_tblDrv.c"
int32 rtl8651_installLoggingFunction(void * pMyLoggingFunc)
{
        if (pMyLoggingFunc==((void *)0))
                return -6;
        _pUserLoggingFunc = (rtl8651_loggingFuncPtr_t)pMyLoggingFunc;
        return 0;
}
# 3868 "rtl8651_tblDrv.c"
int32 rtl8651a_enableLogging(uint32 SessionID,uint32 moduleId,int8 enable){

        uint32 dsid=_rtl8651_SessionIDToDSID(SessionID);
        if (moduleId==0||(enable!=1&&enable!=0))
                return -6;

        if (enable)
                _loggingModule[dsid] |= moduleId;
        else
                _loggingModule[dsid] &= ~moduleId;

        return 0;
}
# 3893 "rtl8651_tblDrv.c"
static void _rtl8651_updateGidxRegister(void) {
# 3914 "rtl8651_tblDrv.c"
        uint32 i, regValue, def_napt_ipidx = 0;
        if (def_napt_t)
                def_napt_ipidx = def_napt_t - DrvTbl.iptbl;
        _gidxRegister[0] = def_napt_ipidx;
        for (i = 1; i < 16; i++)
                _gidxRegister[i] = -1;
        regValue = 0;
        for (i = 0; i < 8; i++)
                regValue |= (_gidxRegister[0] << (3 * i));
# 3934 "rtl8651_tblDrv.c"
        rtl8651_setAsicGidxRegister(regValue);


        if (multiNxtHop != ((void *)0))
                _rtl8651_arrangeAllACL();
}


rtl8651_tblDrv_ipIntfEntry_t * _rtl8651_getIpIntfEntryByAddr(ipaddr_t ipAddr) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_ipIntfEntry_t * ipIfPtr;
        uint32 ifIndex;


        netIfPtr = &DrvTbl.netIface[0];
        for(ifIndex=0; ifIndex<rtl8651_tblDrvPara.networkIntfTableSize; ifIndex++,netIfPtr++) {
                if (netIfPtr->valid == 0)
                        continue;
                for((ipIfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIfPtr); (ipIfPtr) = (ipIfPtr)->nextIp.sle_next)
                        if((ipIfPtr->ipAddr.slh_first->ipAddr & ipIfPtr->ipMask) == (ipAddr & ipIfPtr->ipMask))
                                return ipIfPtr;
        }
        return ((void *)0);
}


rtl8651_tblDrv_networkIntfTable_t *
_rtl8651_getIpInfo(ipaddr_t ipaddr, rtl8651_tblDrv_ipIntfEntry_t **ipintf_t, int8 *is_gip, int8 *is_gwip)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *tmp_ipintf_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        uint32 entry;
# 3976 "rtl8651_tblDrv.c"
        netif_t = DrvTbl.netIface;
        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
# 3992 "rtl8651_tblDrv.c"
                for((tmp_ipintf_t) = (&netif_t->IpHead)->slh_first; (tmp_ipintf_t); (tmp_ipintf_t) = (tmp_ipintf_t)->nextIp.sle_next) {





                        if ((ipaddr&tmp_ipintf_t->ipMask) == (tmp_ipintf_t->ipAddr.slh_first->ipAddr&tmp_ipintf_t->ipMask)) {
                                if (ipintf_t) *ipintf_t = tmp_ipintf_t;
                                goto found;
                        }
                }
        }
        return (rtl8651_tblDrv_networkIntfTable_t *)((void *)0);

found:

        if ( ipintf_t )
        {
                *ipintf_t = _rtl8651_getIpIntfEntryByAddr( ipaddr );
        }







        if ( is_gip )
        {
                if (tmp_ipintf_t->lanSideExternal == 1)
                {

                        *is_gip = 1;
                }
                else
                {
                        if ( _rtl8651_isExtIpAddr( ipaddr ) )
                                *is_gip = 1;
                        else
                                *is_gip = 0;
                }
        }






        if (is_gwip) {
                *is_gwip = 0;
                for((ip_t) = (&tmp_ipintf_t->ipAddr)->slh_first; (ip_t); (ip_t) = (ip_t)->nextIpAddr.sle_next) {
                        if (ip_t->ipAddr == ipaddr) {
                                *is_gwip = 1;
                                break;
                        }
                }
        }

        return (rtl8651_tblDrv_networkIntfTable_t *)netif_t;
}
# 4076 "rtl8651_tblDrv.c"
static int32 _rtl8651_allocateArpEntry(rtl8651_tblDrv_networkIntfTable_t *netif_t, rtl8651_tblDrv_ipIntfEntry_t *ipintf_t)
{
        uint32 bestStartPos = 0xffffffff, bestSize=0, curStartPos, curSize, netSize = 0xffffffff;
        rtl8651_tblDrv_arpAsicArrangementEntry_t *asicArp;
        ether_addr_t mac = { {0xff, 0xff, 0xff, 0xff, 0xff, 0xff} };
        int32 entry;


        for(entry=0; entry<32; entry++) {
                if(ipintf_t->ipMask & (1<<entry))
                        break;
        }

        if ((netSize = (1<<entry)) > 1) {

                bestSize = curSize = 0;
                curStartPos = 0;
                for(entry = 0; entry <= 64; entry++) {
                        if(entry == 64 || AsicTableUsage.arp[entry].valid == 1) {
                                if(curSize > bestSize) {
                                        bestStartPos = curStartPos;
                                        bestSize = curSize;
                                }
                                curStartPos = entry+1;
                                curSize = 0;
                        } else curSize++;
                }
        } else do {} while (0);



        if (netSize>1 && (bestSize<<3) >= netSize) {
                ipintf_t->arpAllocated = 1;
                ipintf_t->arpStartPos = bestStartPos;
                ipintf_t->arpEndPos = bestStartPos + (netSize>>3) - ((netSize&0x7)==0? 1: 0);
                asicArp = &AsicTableUsage.arp[bestStartPos];
                for(entry=ipintf_t->arpStartPos ; entry<=ipintf_t->arpEndPos; entry++, asicArp++)
                        asicArp->valid = 1;
                _rtl8651_addInterfaceRoute(netif_t, ipintf_t, ipintf_t->arpStartPos, ipintf_t->arpEndPos );

                _rtl8651_addLocalArp(1, ((ipintf_t->ipAddr.slh_first->ipAddr&ipintf_t->ipMask)|~ipintf_t->ipMask), &mac, netif_t, 0xffffffff);
                return 0;
        }
        else {
                ipintf_t->arpAllocated = 0;
                _rtl8651_addInterfaceRoute(netif_t, ipintf_t, 0xffffffff, 0xffffffff);
                return 0;
        }
}



static int32 _rtl8651_addIpInterface(rtl8651_tblDrv_networkIntfTable_t *netif_t, ipaddr_t ipAddr, ipaddr_t ipMask)
{
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ipPtr;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        rtl8651_tblDrv_routeTable_t *rt;
        uint32 entry, freeIpCount, ipIntfCount;
        int8 extIf=0;


        do {} while (0);







        if (ipMask == 0 && netif_t->linkLayerType != 0x01)
                return -2701;


        if (netif_t->linkLayerType == 0)
                return -2504;


        if (((&DrvTbl.freeList.ipAddr)->slh_first) == ((void *)0))
                return -9;


        vlan_t = &DrvTbl.vlan[(netif_t->vid& (8 -1))];
        if (vlan_t->internal == 0)
                extIf = 1;




        if ( (vlan_t->internal == 0) && (netif_t->linkLayerType == 0x04))
                return -2702;


        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                if(((ipintf_t->ipAddr.slh_first->ipAddr & ipintf_t->ipMask)==(ipAddr & ipMask)) && (ipintf_t->ipMask==ipMask)) {

                        for((ipPtr) = (&(ipintf_t->ipAddr))->slh_first; (ipPtr); (ipPtr) = (ipPtr)->nextIpAddr.sle_next)
                                if ((ipPtr->ipAddr == ipAddr)) return -2703;;

                        if ((ipPtr = ((&DrvTbl.freeList.ipAddr)->slh_first)) == ((void *)0))
                                return -9;
                        do { (&DrvTbl.freeList.ipAddr)->slh_first = (&DrvTbl.freeList.ipAddr)->slh_first->nextIpAddr.sle_next; } while (0);
                        do { (ipPtr)->nextIpAddr.sle_next = (&ipintf_t->ipAddr)->slh_first; (&ipintf_t->ipAddr)->slh_first = (ipPtr); } while (0);
                        ipPtr->ipAddr = ipAddr;
                        return 0;
                }
        }


        if (((&DrvTbl.freeList.ipIface)->slh_first) == ((void *)0))
                return -9;


        for(entry=0,rt=&DrvTbl.route[0]; entry<8 -1; entry++,rt++) {
                if (rt->valid == 0)
                        break;
        }

        if (entry == 8 -1 && ipMask != 0xffffffff && ipMask != 0)
                return -9;


        if ((ipintf_t=((&DrvTbl.freeList.ipIface)->slh_first))==((void *)0) ||(ipPtr=((&DrvTbl.freeList.ipAddr)->slh_first)) == ((void *)0))
                return -9;

        if (ipMask != 0xffffffff || (netif_t->linkLayerType!=0x01 && netif_t->linkLayerType!=0x04)) {

                do { (&DrvTbl.freeList.ipIface)->slh_first = (&DrvTbl.freeList.ipIface)->slh_first->nextIp.sle_next; } while (0);
                do { (ipintf_t)->nextIp.sle_next = (&(netif_t->IpHead))->slh_first; (&(netif_t->IpHead))->slh_first = (ipintf_t); } while (0);
                do { (&DrvTbl.freeList.ipAddr)->slh_first = (&DrvTbl.freeList.ipAddr)->slh_first->nextIpAddr.sle_next; } while (0);
                do { (ipPtr)->nextIpAddr.sle_next = (&(ipintf_t->ipAddr))->slh_first; (&(ipintf_t->ipAddr))->slh_first = (ipPtr); } while (0);


                ipPtr->ipAddr = ipAddr;
                ipintf_t->ipMask = ipMask;
                ipintf_t->lanSideExternal = 0;
                ipintf_t->ipUnnumber = 0;
                { (&ipintf_t->nextArp)->slh_first = ((void *)0); };
                { (&ipintf_t->localServer)->slh_first = ((void *)0); };
        } else return -2704;

        switch (netif_t->linkLayerType)
        {
        case 0x01:
        case 0x04:


                if (ipMask != 0)
                        _rtl8651_allocateArpEntry(netif_t, ipintf_t);
                break;

        case 0x02:
                if (ipMask != 0xffffffff)
                        return -2704;
                ipintf_t->arpAllocated = 0;
                break;

        case 0x06:
        case 0x05:





                if (ipMask != 0xffffffff)
                        _rtl8651_allocateArpEntry(netif_t, ipintf_t);
                else
                        ipintf_t->arpAllocated = 0;
                break;

        default: do {} while (0);
        }



        freeIpCount = 16 - naptIpCount - natIpCount - localServerCount;
        if (freeIpCount == 16) {
                if (extIf == 1) {
                        rtl8651_setAsicOperationLayer(4);
                }
                else {
                        netif_t = DrvTbl.netIface;
                        ipIntfCount = 0;
                        for(entry=0, ipIntfCount=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                                if(netif_t->valid == 1) {
                                        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
                                                ipIntfCount++;
                                }
                        }
                        if(ipIntfCount == 1) {
                                rtl8651_setAsicOperationLayer(3);
                        }
                }
        }

        if (vlan_t->ipAttached == 0) {
                vlan_t->ipAttached = 1;
                RTL8651_SETASICVLAN(vlan_t);
        }
        return 0;
}


int32 _rtl8651_delIpInterface(rtl8651_tblDrv_networkIntfTable_t * netif_t, ipaddr_t ipAddr, ipaddr_t ipMask)
{
        rtl8651_tblDrv_arpAsicArrangementEntry_t *asicArp;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *delIpPtr;
        rtl8651_tblDrv_ipIntfEntry_t * ipintf_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        rtl8651_tblDrv_routeTable_t *rt;
        int32 entry, ipIntfCount;

        do {} while (0);


        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
                if((ipintf_t->ipAddr.slh_first->ipAddr & ipintf_t->ipMask) == (ipAddr & ipMask) && ipintf_t->ipMask == ipMask)
                        break;


        if (ipintf_t == ((void *)0))
                return -2710;
        if (ipintf_t->lanSideExternal == 1)
                return -2705;
        vlan_t = &DrvTbl.vlan[(netif_t->vid& (8 -1))];




        _rtl8651_delMulticastByVid(netif_t->vid);







        if (ipintf_t->ipAddr.slh_first->nextIpAddr.sle_next == ((void *)0)) {
                if (((&ipintf_t->localServer)->slh_first))
                        return -2707;
                for(entry=0,rt=&DrvTbl.route[0]; entry<rtl8651_tblDrvPara.routingTableSize; entry++,rt++) {
                        if (rt->valid && (rt->nextHop&ipMask)==(ipAddr&ipMask))
                                return -2708;
                }
        }


        for((delIpPtr) = (&(ipintf_t->ipAddr))->slh_first; (delIpPtr); (delIpPtr) = (delIpPtr)->nextIpAddr.sle_next)
                if (delIpPtr->ipAddr == ipAddr)
                        break;

        if (delIpPtr == ((void *)0))
                return -2710;


        if (vlan_t->internal == 0) {
                if (_rtl8651_isNaptMapping(ipAddr)==1 || _rtl8651_isNatMapping(&ipAddr, ((void *)0))==1)
                        return -2709;
        }


        if (netif_t->linkLayerType != 0x01)
                _rtl8651_unbindSession(delIpPtr, ((void *)0));

        if (ipintf_t->ipAddr.slh_first->nextIpAddr.sle_next == ((void *)0)) {

                  while ((arp_t=((&ipintf_t->nextArp)->slh_first)))
                        _rtl8651_delLocalArp(0x03, arp_t->ipAddr, netif_t);
         }


        do { if ((&(ipintf_t->ipAddr))->slh_first == (delIpPtr)) { do { ((&(ipintf_t->ipAddr)))->slh_first = ((&(ipintf_t->ipAddr)))->slh_first->nextIpAddr.sle_next; } while (0); } else { struct rtl8651_tblDrv_ipIntfIpAddrEntry_s *curelm = (&(ipintf_t->ipAddr))->slh_first; while( curelm->nextIpAddr.sle_next != (delIpPtr) ) curelm = curelm->nextIpAddr.sle_next; curelm->nextIpAddr.sle_next = curelm->nextIpAddr.sle_next->nextIpAddr.sle_next; } } while (0);
        do { (delIpPtr)->nextIpAddr.sle_next = (&DrvTbl.freeList.ipAddr)->slh_first; (&DrvTbl.freeList.ipAddr)->slh_first = (delIpPtr); } while (0);


        if (ipintf_t->ipUnnumber) {
                do { if ((&DrvTbl.inuseList.ipUnnumber)->slh_first == (ipintf_t->ipUnnumber)) { do { ((&DrvTbl.inuseList.ipUnnumber))->slh_first = ((&DrvTbl.inuseList.ipUnnumber))->slh_first->nextIpUnnumberEntry.sle_next; } while (0); } else { struct rtl8651_tblDrv_ipUnnumbered_s *curelm = (&DrvTbl.inuseList.ipUnnumber)->slh_first; while( curelm->nextIpUnnumberEntry.sle_next != (ipintf_t->ipUnnumber) ) curelm = curelm->nextIpUnnumberEntry.sle_next; curelm->nextIpUnnumberEntry.sle_next = curelm->nextIpUnnumberEntry.sle_next->nextIpUnnumberEntry.sle_next; } } while (0);
                do { (ipintf_t->ipUnnumber)->nextIpUnnumberEntry.sle_next = (&DrvTbl.freeList.freeIpUnnumber)->slh_first; (&DrvTbl.freeList.freeIpUnnumber)->slh_first = (ipintf_t->ipUnnumber); } while (0);
                ipintf_t->ipUnnumber = ((void *)0);
        }


        if(((&ipintf_t->ipAddr)->slh_first) == ((void *)0)) {
                do {} while (0);

                if(ipintf_t->arpAllocated) {
                        uint32 arpPos;
                        for(arpPos=ipintf_t->arpStartPos,asicArp=&AsicTableUsage.arp[arpPos]; arpPos<=ipintf_t->arpEndPos; arpPos++,asicArp++)
                                asicArp->valid = 0;
                }


                if (ipintf_t->ipMask != 0xffffffff) {






                        _rtl8651_delInterfaceRoute(ipAddr, ipMask);

                }


                do { if ((&(netif_t->IpHead))->slh_first == (ipintf_t)) { do { ((&(netif_t->IpHead)))->slh_first = ((&(netif_t->IpHead)))->slh_first->nextIp.sle_next; } while (0); } else { struct rtl8651_tblDrv_ipIntfEntry_s *curelm = (&(netif_t->IpHead))->slh_first; while( curelm->nextIp.sle_next != (ipintf_t) ) curelm = curelm->nextIp.sle_next; curelm->nextIp.sle_next = curelm->nextIp.sle_next->nextIp.sle_next; } } while (0);
                do { (ipintf_t)->nextIp.sle_next = (&DrvTbl.freeList.ipIface)->slh_first; (&DrvTbl.freeList.ipIface)->slh_first = (ipintf_t); } while (0);

                if (((&netif_t->IpHead)->slh_first) == ((void *)0)) {
                        vlan_t->ipAttached = 0;
                        RTL8651_SETASICVLAN(vlan_t);
                }
        }



        ipIntfCount = 0;
        netif_t = DrvTbl.netIface;
        for(entry=0 ; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++)
                if(netif_t->valid == 1) {
                        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
                                ipIntfCount++;
                }
        if(ipIntfCount == 0) {
                rtl8651_setAsicOperationLayer(2);
        }
        return 0;

}
# 4425 "rtl8651_tblDrv.c"
int32 rtl8651_addIpIntf(int8 * ifName, ipaddr_t ipAddr, ipaddr_t ipMask)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;
        rtlglue_drvMutexLock();
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0))
                retval = -7;
        else retval = _rtl8651_addIpInterface(netif_t, ipAddr, ipMask);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 4454 "rtl8651_tblDrv.c"
int32 rtl8651_delIpIntf(int8 * ifName, ipaddr_t ipAddr, ipaddr_t ipMask)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;
        rtlglue_drvMutexLock();
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0))
                retval = -7;
        else retval = _rtl8651_delIpInterface(netif_t, ipAddr, ipMask);
        rtlglue_drvMutexUnlock();
        return retval;

}
# 4841 "rtl8651_tblDrv.c"
static void _rtl8651_resetLanSideExternalIpInterface( rtl8651_tblDrv_networkIntfTable_t *netif_t, rtl8651_tblDrv_ipIntfEntry_t *ipintf_t, uint8 operation)
{
        rtl8651_tblDrv_ipUnnumbered_t *ipUnnumber_t = ipintf_t->ipUnnumber;




        do {} while (0);
# 4858 "rtl8651_tblDrv.c"
        if ( operation & 0x01 )
        {
                int32 ipIdx;
                rtl8651_tblDrv_ipEntry_t *ipEntry_t;





                if (ipUnnumber_t->ip_as_LS == 0)
                        goto remove_done;





                ipEntry_t = DrvTbl.iptbl;
                for(ipIdx=0 ; ipIdx<16 ; ipIdx++, ipEntry_t++)
                {
                        if (ipEntry_t->type != 0x02)
                                continue;
                        if ( (ipEntry_t->extip&ipUnnumber_t->ipMask) ==
                              (ipUnnumber_t->ipAddr&ipUnnumber_t->ipMask))
                        {







                                if ((



                                        _rtl8651_delIpEntry(0x02, ipEntry_t->extip, 0)) == 0)
                                {

                                        rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_LS_budget ++;
                                        ipUnnumber_t->ip_as_LS --;
                                }






                        }
                }

                do {} while (0);
        }
remove_done:





        if ( operation & 0x02 )
        {
                do {} while (0);
# 4927 "rtl8651_tblDrv.c"
                if (rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_LS_budget == 0)
                {
                        goto add_done;
                }

                {
                        uint32 ipToBeAdded;
                        uint32 i, addedCount=0, subnetCount=0xffffffff & (uint32)(~((uint32)ipUnnumber_t->ipMask));

                        for ( i=1;
                                 i<subnetCount && addedCount<rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_LS_budget;
                                 i++ )
                        {
                                ipToBeAdded = (uint32)(ipUnnumber_t->ipAddr & ipUnnumber_t->ipMask) + i;

                                if (ipToBeAdded == ipUnnumber_t->ipAddr)
                                        continue;






                                if (_rtl8651_addIpEntry((ipaddr_t)ipToBeAdded, (ipaddr_t)ipToBeAdded, 0x02, ((void *)0)) == ((void *)0))
                                {




                                        break;
                                }
                                addedCount++;
                        }

                        ipUnnumber_t->ip_as_LS += addedCount;
                        rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_LS_budget -= addedCount;
                }
        }
add_done:
        _rtl8651_arrangeAllACL();

}





void _rtl8651_reArrangeLanSideExternalIpInterfacePatch(void)
{
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;

        if (!lanSideIpUnnumberedLan)
        {
                return;
        }

        for((ipintf_t) = (&lanSideIpUnnumberedLan->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
        {
                if (ipintf_t->lanSideExternal)
                {
                        _rtl8651_resetLanSideExternalIpInterface(lanSideIpUnnumberedLan, ipintf_t, 0x03);
                }
        }
}
# 5009 "rtl8651_tblDrv.c"
int32 rtl8651_setLanSideExternalIpInterface(int8 * ifName, ipaddr_t ipAddr, ipaddr_t ipMask, int8 isExternal) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval = -1;

        netif_t = GET_NETWORK_INTERFACE(ifName, ((void *)0));
        if ((netif_t==((void *)0))) return -7;;
        rtlglue_drvMutexLock();
        retval = _rtl8651_setLanSideExternalIpInterface(netif_t, ipAddr, ipMask, isExternal);
        rtlglue_drvMutexUnlock();
        return retval;
}




int32 _rtl8651_setLanSideExternalIpInterface(rtl8651_tblDrv_networkIntfTable_t *netif_t, ipaddr_t ipAddr, ipaddr_t ipMask, int8 isExternal)
{
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        rtl8651_tblDrvSession_t *psession_t;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        rtl8651_tblDrv_ipUnnumbered_t *ipUnnumber_t;
        uint32 netIdx;

        if ((netif_t->linkLayerType != 0x04)) return -2607;



        if ((DrvTbl.vlan[(netif_t->vid& (8 -1))].internal == 0)) return -2608;;



        for((ipintf_t) = (&netif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
                if (((ipintf_t->ipMask&ipintf_t->ipAddr.slh_first->ipAddr)==(ipAddr&ipMask)) &&
                        (ipintf_t->ipMask == ipMask))
                        break;
        if ((ipintf_t==((void *)0))) return -2710;;

        if (isExternal == 1)
        {
                if ( ipintf_t->ipUnnumber )
                {






                        do {} while (0);

                        if (ipintf_t->ipUnnumber->ipAddr != ipAddr)
                        {
                                printk("%s(%d) Fail: ipAddr(org:%u.%u.%u.%u new:%u.%u.%u.%u) mismatch.\n", __FUNCTION__, 5062, ((unsigned char *)&ipintf_t->ipUnnumber->ipAddr)[0], ((unsigned char *)&ipintf_t->ipUnnumber->ipAddr)[1], ((unsigned char *)&ipintf_t->ipUnnumber->ipAddr)[2], ((unsigned char *)&ipintf_t->ipUnnumber->ipAddr)[3], ((unsigned char *)&ipAddr)[0], ((unsigned char *)&ipAddr)[1], ((unsigned char *)&ipAddr)[2], ((unsigned char *)&ipAddr)[3]);
                                return -6;
                        }
                        if (ipintf_t->ipUnnumber->ipMask != ipMask)
                        {
                                printk("%s(%d) Fail: ipMask(org:%u.%u.%u.%u new:%u.%u.%u.%u) mismatch.\n", __FUNCTION__, 5067, ((unsigned char *)&ipintf_t->ipUnnumber->ipMask)[0], ((unsigned char *)&ipintf_t->ipUnnumber->ipMask)[1], ((unsigned char *)&ipintf_t->ipUnnumber->ipMask)[2], ((unsigned char *)&ipintf_t->ipUnnumber->ipMask)[3], ((unsigned char *)&ipMask)[0], ((unsigned char *)&ipMask)[1], ((unsigned char *)&ipMask)[2], ((unsigned char *)&ipMask)[3]);
                                return -6;
                        }
                        return 0;

                }else
                {




                        if (((&DrvTbl.freeList.freeIpUnnumber)->slh_first) == ((void *)0))
                                return -9;
                        ipUnnumber_t = ipintf_t->ipUnnumber = ((&DrvTbl.freeList.freeIpUnnumber)->slh_first);
                        do { (&DrvTbl.freeList.freeIpUnnumber)->slh_first = (&DrvTbl.freeList.freeIpUnnumber)->slh_first->nextIpUnnumberEntry.sle_next; } while (0);
                        do { (ipintf_t->ipUnnumber)->nextIpUnnumberEntry.sle_next = (&DrvTbl.inuseList.ipUnnumber)->slh_first; (&DrvTbl.inuseList.ipUnnumber)->slh_first = (ipintf_t->ipUnnumber); } while (0);
                        do {} while (0);


                        ipUnnumber_t->ipIntf_t = ipintf_t;
                        ipUnnumber_t->ipAddr = ipAddr;
                        ipUnnumber_t->ipMask = ipMask;
                        ipUnnumber_t->ip_as_LS = 0;
                        ipUnnumber_t->ip_as_ACL_budget = 0;
                }

                ipintf_t->lanSideExternal = 1;


                _rtl8651_resetLanSideExternalIpInterface(netif_t, ipintf_t, 0x02);

        }else
        {

                netIfPtr = &DrvTbl.netIface[0];
                for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netIfPtr++)
                        if (DrvTbl.vlan[(netIfPtr->vid& (8 -1))].internal == 0 &&
                                netIfPtr->linkLayerType == 0x04)
                                break;

                if ((netIdx == rtl8651_tblDrvPara.networkIntfTableSize)) return 0;;
                for((ip_t) = (&ipintf_t->ipAddr)->slh_first; (ip_t); (ip_t) = (ip_t)->nextIpAddr.sle_next)
                {
                        for (psession_t = ((&netIfPtr->sessionHead)->tqh_first); psession_t; psession_t = ((psession_t)->nextSession.tqe_next))
                                if ((ip_t == psession_t->ip_t)) return -2609;;
                }


                while((arp_t=((&ipintf_t->nextArp)->slh_first)))
                        _rtl8651_delLocalArp(0x03, arp_t->ipAddr, netif_t);


                _rtl8651_resetLanSideExternalIpInterface(netif_t, ipintf_t, 0x01);

                ipintf_t->lanSideExternal = 0;


                if(ipintf_t->ipUnnumber)
                {
                        do { if ((&DrvTbl.inuseList.ipUnnumber)->slh_first == (ipintf_t->ipUnnumber)) { do { ((&DrvTbl.inuseList.ipUnnumber))->slh_first = ((&DrvTbl.inuseList.ipUnnumber))->slh_first->nextIpUnnumberEntry.sle_next; } while (0); } else { struct rtl8651_tblDrv_ipUnnumbered_s *curelm = (&DrvTbl.inuseList.ipUnnumber)->slh_first; while( curelm->nextIpUnnumberEntry.sle_next != (ipintf_t->ipUnnumber) ) curelm = curelm->nextIpUnnumberEntry.sle_next; curelm->nextIpUnnumberEntry.sle_next = curelm->nextIpUnnumberEntry.sle_next->nextIpUnnumberEntry.sle_next; } } while (0);
                        do { (ipintf_t->ipUnnumber)->nextIpUnnumberEntry.sle_next = (&DrvTbl.freeList.freeIpUnnumber)->slh_first; (&DrvTbl.freeList.freeIpUnnumber)->slh_first = (ipintf_t->ipUnnumber); } while (0);
                        ipintf_t->ipUnnumber = ((void *)0);
                }

        }
        _rtl8651_arrangeAllACL();
        return 0;
}






static void _rtl8651_arrangeAsicArpEntry(rtl8651_tblDrv_ipIntfEntry_t *ipIntf, rtl8651_tblDrv_arpEntry_t *arp_t)
{
        rtl8651_tblDrv_routeTable_t *rt_t = DrvTbl.route;
        rtl8651_tblDrv_filterDbTableEntry_t *macInfo;
        rtl8651_tblDrv_networkIntfTable_t *netIntf;
        rtl8651_tblDrv_arpEntry_t *arp;
        uint32 arpPos, i;
        int8 isDelete;
# 5162 "rtl8651_tblDrv.c"
        if (ipIntf == (rtl8651_tblDrv_ipIntfEntry_t *)((void *)0)) {
                netIntf = &DrvTbl.netIface[0];
                for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netIntf++)
                        if (netIntf->valid == 1)
                                for((ipIntf) = (&(netIntf->IpHead))->slh_first; (ipIntf); (ipIntf) = (ipIntf)->nextIp.sle_next)
                                        for((arp) = (&(ipIntf->nextArp))->slh_first; (arp); (arp) = (arp)->next.sle_next) {
                                                if (arp->ipAddr == arp_t->ipAddr)
                                                        goto __ipIntf_found;
                }
        }

__ipIntf_found:

        if (!arp_t || !ipIntf)
                return;

        if (ipIntf->arpAllocated == 1) {
                arpPos = (ipIntf->arpStartPos<<3)+(arp_t->ipAddr & ~ipIntf->ipMask);
                if (arp_t->fromApp == 0 && arp_t->fromDrv == 0 && arp_t->age == 0) {
                        isDelete = 1;
                        rtl8651_delAsicArp(arpPos);
                }
                else {
                        isDelete = 0;
                        macInfo = arp_t->macInfo;
                        do {} while (0);
                        if (macInfo->configToAsic == 1 && arp_t->dmzIpPending == 0) {
                                rtl865x_tblAsicDrv_arpParam_t asic_arp;
                                asic_arp.nextHopColumn = macInfo->asicPos;
                                asic_arp.nextHopRow = rtl8651_filterDbIndex(&macInfo->macAddr);
                                rtl8651_setAsicArp(arpPos, &asic_arp);
                        } else rtl8651_delAsicArp(arpPos);
                }
                _rtl8651_arrangeNATbyMacAccessControl();
                _rtl8651_arrangeSPbyMacAccessControl();
        }
        else {
                if (arp_t->fromApp == 0 && arp_t->fromDrv == 0 && arp_t->age == 0)
                        isDelete = 1;
                else isDelete = 0;
        }


        for(i=0; i<rtl8651_tblDrvPara.routingTableSize; i++, rt_t++) {
                if (rt_t->valid == 0 || (rt_t->process!=0x01&&rt_t->process!=0x05))
                        continue;
                if (arp_t->ipAddr == rt_t->nextHop) {
                        if (isDelete == 0)
                                rt_t->un.nxthop.un1.direct.arp_t = arp_t;
                        else rt_t->un.nxthop.un1.direct.arp_t = ((void *)0);
                        _rtl8651_updateL3Entry(rt_t);
                }
        }
        _rtl8651_updateNextHop_NHIDX(arp_t, ((void *)0));

}
# 5369 "rtl8651_tblDrv.c"
void _rtl8651_removeArpByL2Entry(rtl8651_tblDrv_filterDbTableEntry_t *l2entry_t)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipEntry_t;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        int32 i;

        do {} while (0);
        netif_t = &DrvTbl.netIface[0];
        for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netif_t++) {
                for((ipEntry_t) = (&netif_t->IpHead)->slh_first; (ipEntry_t); (ipEntry_t) = (ipEntry_t)->nextIp.sle_next) {
                        for((arp_t) = (&ipEntry_t->nextArp)->slh_first; (arp_t); (arp_t) = (arp_t)->next.sle_next) {
                                if (arp_t->macInfo == l2entry_t){

                                        arp_t->fromApp = 0;
                                        arp_t->fromDrv = 0;
                                        arp_t->age = 0;
                                        _rtl8651_arrangeAsicArpEntry(ipEntry_t, arp_t);
                                        do { if ((&ipEntry_t->nextArp)->slh_first == (arp_t)) { do { ((&ipEntry_t->nextArp))->slh_first = ((&ipEntry_t->nextArp))->slh_first->next.sle_next; } while (0); } else { struct rtl8651_tblDrv_arpEntry_s *curelm = (&ipEntry_t->nextArp)->slh_first; while( curelm->next.sle_next != (arp_t) ) curelm = curelm->next.sle_next; curelm->next.sle_next = curelm->next.sle_next->next.sle_next; } } while (0);
                                        do { (arp_t)->next.sle_next = (&DrvTbl.freeList.arp)->slh_first; (&DrvTbl.freeList.arp)->slh_first = (arp_t); (&DrvTbl.freeList.arp)->slh_count++;} while (0);
                                        break;
                                }
                        }
                }
        }
}






int32 _rtl8651_addLocalArp(int8 fromDrv, ipaddr_t ipAddr, ether_addr_t * macAddr, rtl8651_tblDrv_networkIntfTable_t *netif_t, uint32 port)
{
        rtl8651_tblDrv_arpEntry_t * allocArpEntry, *trackArpEntry;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        uint32 i;

        do {} while (0);
        do {} while (0);



        for((ipintf_t) = (&netif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                for((ip_t) = (&ipintf_t->ipAddr)->slh_first; (ip_t); (ip_t) = (ip_t)->nextIpAddr.sle_next)
                        if (ip_t->ipAddr == ipAddr)
                                return -6;
        }

        if (((&DrvTbl.freeList.arp)->slh_count) == 0)
                return -9;
        if(netif_t->linkLayerType == 0x02)
                return -2400;



        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next){
                if((ipAddr & ipintf_t->ipMask) == (ipintf_t->ipAddr.slh_first->ipAddr & ipintf_t->ipMask))
                        break;
        }
        if(ipintf_t == ((void *)0))
                return -2710;







        {
                rtl8651_tblDrv_pppTable_t *pppEntry_t = &DrvTbl.pppoe[8];
                for(i=0; i<rtl8651_tblDrvPara.pptpSize+rtl8651_tblDrvPara.l2tpSize; i++, pppEntry_t++) {
                        if (pppEntry_t->valid && pppEntry_t->initiated == 0)
                                continue;
                        if ((pppEntry_t->type == 0x02 && (pppEntry_t->un.pptp.serverIp__ == ipAddr || pppEntry_t->un.pptp.defaultGwIp__ == ipAddr)) ||
                            (pppEntry_t->type == 0x03 && (pppEntry_t->un.l2tp.serverIp__ == ipAddr || pppEntry_t->un.l2tp.defaultGwIp__ == ipAddr)) ) {
                                tunnel.wanPort = port;
                                port = tunnel.loopbackPort;
                                break;
                        }
                }
        }



        for((trackArpEntry) = (&(ipintf_t->nextArp))->slh_first; (trackArpEntry); (trackArpEntry) = (trackArpEntry)->next.sle_next) {
                if (trackArpEntry->ipAddr != ipAddr)
                        continue;
                if(fromDrv == 0) {

                        if (trackArpEntry->fromApp == 0) {
                                trackArpEntry->fromApp = 1;
                                return 0;
                        } else return -2401;
                }
                else {

                        if (trackArpEntry->fromDrv == 0) {
                                trackArpEntry->fromDrv = 1;
                                return 0;
                        }
                        else {




                                        i = (trackArpEntry->vid& (8 -1));
                                        if(_rtl8651_delVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[i].fid, &trackArpEntry->macInfo->macAddr)!=0)
                                                return -2403;
                                        if(_rtl8651_addVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[i].fid, trackArpEntry->vid, macAddr, 0x00, port==0xffffffff? port: 1<<port) != 0)
                                                return -2402;
                                        trackArpEntry->macInfo = _rtl8651_getVlanFilterDatabaseEntry(netif_t->vid, macAddr);
                                        trackArpEntry->age = arpAgingTime;
                                        do {} while (0);
                                        _rtl8651_arrangeAsicArpEntry(ipintf_t, trackArpEntry);
                                        _rtl8651_arrangeAllACL();
                                        return 0;
                        }
                }
        }


        i = (netif_t->vid& (8 -1));
        if(_rtl8651_addVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[i].fid, netif_t->vid, macAddr, 0x00, port==0xffffffff? port: 1<<port) != 0)
                return -2402;

        do {} while (0);
        allocArpEntry = ((&DrvTbl.freeList.arp)->slh_first);
        do { (&DrvTbl.freeList.arp)->slh_first = (&DrvTbl.freeList.arp)->slh_first->next.sle_next; (&DrvTbl.freeList.arp)->slh_count--;} while (0);
        allocArpEntry->ipAddr = ipAddr;
        allocArpEntry->vid = netif_t->vid;
        allocArpEntry->fromDrv = (fromDrv == 1)? 1: 0;
        allocArpEntry->fromApp = (fromDrv == 1)? 0: 1;
        allocArpEntry->dmzIpPending = 0;
        allocArpEntry->age = arpAgingTime;
        allocArpEntry->macInfo = _rtl8651_getVlanFilterDatabaseEntry(netif_t->vid, macAddr);
        do {} while (0);

        if (ipAddr == ((ipintf_t->ipMask&ipAddr)|~ipintf_t->ipMask))
                allocArpEntry->isBcArp = 1;
        else allocArpEntry->isBcArp = 0;


        do { (allocArpEntry)->next.sle_next = (&(ipintf_t->nextArp))->slh_first; (&(ipintf_t->nextArp))->slh_first = (allocArpEntry); } while (0);
        _rtl8651_arrangeAsicArpEntry(ipintf_t, allocArpEntry);

        _rtl8651_arrangeAllACL();
        return 0;
}


int32 _rtl8651_delLocalArp(int8 fromDrv, ipaddr_t ipAddr, rtl8651_tblDrv_networkIntfTable_t *netif_t)
{
        rtl8651_tblDrv_ipIntfEntry_t * ipintf_t;
        rtl8651_tblDrv_arpEntry_t * delArpEntry, * trackArpEntry;

        uint32 i;

        do {} while (0);
        do {} while (0);


        if(netif_t->linkLayerType == 0x02)
                return -2400;


        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
                if((ipAddr & ipintf_t->ipMask) == (ipintf_t->ipAddr.slh_first->ipAddr & ipintf_t->ipMask))
                        break;
        if(ipintf_t == ((void *)0))
                return -3;


        for((trackArpEntry) = (&(ipintf_t->nextArp))->slh_first; (trackArpEntry); (trackArpEntry) = (trackArpEntry)->next.sle_next) {
                if(trackArpEntry->ipAddr == ipAddr) {
                        if (fromDrv == 0x03)
                                break;
                        if(fromDrv == 1 && trackArpEntry->fromDrv == 1)
                                trackArpEntry->fromDrv = 0;
                        else if(fromDrv == 0 && trackArpEntry->fromApp == 1) {
                                trackArpEntry->fromApp = 0;
                                break;





                        }
                        if (trackArpEntry->fromDrv == 1 || trackArpEntry->fromApp == 1)
                                return 0;
                        break;
                }
        }

        if(trackArpEntry == ((void *)0))
                return -3;
        if (fromDrv == 0x03) {
                trackArpEntry->fromApp = 0;
                trackArpEntry->fromDrv = 0;
                trackArpEntry->age = 0;
        }
        do {} while (0);
        delArpEntry = trackArpEntry;
        do {} while (0);

        do { if ((&(ipintf_t->nextArp))->slh_first == (delArpEntry)) { do { ((&(ipintf_t->nextArp)))->slh_first = ((&(ipintf_t->nextArp)))->slh_first->next.sle_next; } while (0); } else { struct rtl8651_tblDrv_arpEntry_s *curelm = (&(ipintf_t->nextArp))->slh_first; while( curelm->next.sle_next != (delArpEntry) ) curelm = curelm->next.sle_next; curelm->next.sle_next = curelm->next.sle_next->next.sle_next; } } while (0);
        do { (delArpEntry)->next.sle_next = (&DrvTbl.freeList.arp)->slh_first; (&DrvTbl.freeList.arp)->slh_first = (delArpEntry); (&DrvTbl.freeList.arp)->slh_count++;} while (0);
        i = (delArpEntry->vid& (8 -1));
        _rtl8651_delVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[i].fid, &delArpEntry->macInfo->macAddr);
        delArpEntry->age = 0;
        _rtl8651_arrangeAsicArpEntry(ipintf_t, delArpEntry);
        _rtl8651_arrangeAllACL();
        return 0;
}



int32 _rtl8651_isLocalBcastAddr(uint32 vid, ipaddr_t ipAddr) {
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_vlanTable_t *thisVlan;

        thisVlan=&DrvTbl.vlan[ (vid& (8 -1))];
        do {} while (0);
        netIfPtr=thisVlan->netif_t;
        if(netIfPtr&&netIfPtr->valid == 1) {
                for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                        do {} while (0);
                        if(ipAddr== ((ipIntfPtr->ipAddr.slh_first->ipAddr & ipIntfPtr->ipMask)|(~ipIntfPtr->ipMask))){
                                if (ipIntfPtr->ipMask == 0xffffffff){
                                        return 0;
                                }else{
                                        return 1;
                                }
                }
        }
        }
        return 0;
}

rtl8651_tblDrv_arpEntry_t * _rtl8651_getArpEntryByMac(rtl8651_tblDrv_networkIntfTable_t *netif_t, ether_addr_t *macAddr, int8 isRefresh)
{
        rtl8651_tblDrv_arpEntry_t * trackArpEntry;
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        uint32 index, MAX;

        if (netif_t)
                MAX = 1;
        else {
                MAX = rtl8651_tblDrvPara.networkIntfTableSize;
                netif_t = DrvTbl.netIface;
        }

        for(index = 0; index < MAX; index++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                for((ipIntfPtr) = (&(netif_t->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                        for((trackArpEntry) = (&(ipIntfPtr->nextArp))->slh_first; (trackArpEntry); (trackArpEntry) = (trackArpEntry)->next.sle_next) {
                                if (!memcmp(&trackArpEntry->macInfo->macAddr, macAddr, sizeof(ether_addr_t))) {
                                        if (isRefresh == 1)
                                                trackArpEntry->age = arpAgingTime;
                                        return trackArpEntry;
                                }
                        }
                }
        }
        return (rtl8651_tblDrv_arpEntry_t *) ((void *)0);
}

rtl8651_tblDrv_arpEntry_t * _rtl8651_getArpEntry(rtl8651_tblDrv_networkIntfTable_t *netif_t, ipaddr_t ipAddr, int8 isRefresh)
{
        rtl8651_tblDrv_arpEntry_t * trackArpEntry;
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        uint32 index, MAX;
# 5656 "rtl8651_tblDrv.c"
        if (netif_t)
                MAX = 1;
        else {
                MAX = rtl8651_tblDrvPara.networkIntfTableSize;
                netif_t = DrvTbl.netIface;
        }
        for(index=0; index< MAX; index++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                for((ipIntfPtr) = (&(netif_t->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                                do {} while (0);
                                if((ipAddr & ipIntfPtr->ipMask) == (ipIntfPtr->ipAddr.slh_first->ipAddr & ipIntfPtr->ipMask)) {
                                        for((trackArpEntry) = (&(ipIntfPtr->nextArp))->slh_first; (trackArpEntry); (trackArpEntry) = (trackArpEntry)->next.sle_next) {
                                                if (trackArpEntry->ipAddr == ipAddr) {

                                                        if (isRefresh == 1)
                                                                trackArpEntry->age = arpAgingTime;
                                                                return trackArpEntry;
                                                }
                                        }
                                }
                        }
                }

        return (rtl8651_tblDrv_arpEntry_t *)((void *)0);
}


static void _rtl8651_timeUpdateArp(uint32 secPassed) {
        rtl865x_tblAsicDrv_l2Param_t asic_l2;
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_arpEntry_t *arpEntryPtr, *delArpEntry;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 ifIndex;

        for(ifIndex=0,netIfPtr=&DrvTbl.netIface[0]; ifIndex<rtl8651_tblDrvPara.networkIntfTableSize; ifIndex++,netIfPtr++) {
                if (netIfPtr->valid == 0)
                        continue;
                for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                        arpEntryPtr=ipIntfPtr->nextArp.slh_first;
                        while (arpEntryPtr) {
                                if (arpEntryPtr->isBcArp == 1) {
                                        arpEntryPtr = arpEntryPtr->next.sle_next;
                                        continue;
                                }






                                if (arpEntryPtr->age > secPassed) {
                                        arpEntryPtr->age -= secPassed;
                                        if (arpEntryPtr->macInfo->configToAsic == 1) {
                                                if (rtl8651_getAsicL2Table(rtl8651_filterDbIndex(&(arpEntryPtr->macInfo->macAddr)), arpEntryPtr->macInfo->asicPos, &asic_l2) == 0) {

                                                        if (asic_l2.ageSec > 0) {
                                                                arpEntryPtr = arpEntryPtr->next.sle_next;
                                                                continue;
                                                        }
                                                }

                                                if (arpEntryPtr->fromApp == 1) {
                                                        arpEntryPtr->age = arpAgingTime;
                                                        asic_l2.ageSec = arpAgingTime;
                                                        rtl8651_setAsicL2Table(rtl8651_filterDbIndex(&(arpEntryPtr->macInfo->macAddr)), arpEntryPtr->macInfo->asicPos, &asic_l2);
                                                        arpEntryPtr = arpEntryPtr->next.sle_next;
                                                        continue;
                                                }

                                                else
                                                        arpEntryPtr->age = 0;

                                        }
                                        else {
                                                arpEntryPtr = arpEntryPtr->next.sle_next;
                                                continue;
                                        }
                                }





                                else {
                                        arpEntryPtr->age = 0;
                                        if (arpEntryPtr->macInfo->configToAsic == 1) {
                                                if (rtl8651_getAsicL2Table(rtl8651_filterDbIndex(&(arpEntryPtr->macInfo->macAddr)), arpEntryPtr->macInfo->asicPos, &asic_l2) == 0) {

                                                        if (asic_l2.ageSec > 0) {
                                                                arpEntryPtr->age = asic_l2.ageSec >> 2;
                                                                arpEntryPtr = arpEntryPtr->next.sle_next;
                                                                continue;
                                                        }
                                                }

                                                if (arpEntryPtr->fromApp == 1) {
                                                        arpEntryPtr->age = arpAgingTime;
                                                        asic_l2.ageSec = arpAgingTime;
                                                        rtl8651_setAsicL2Table(rtl8651_filterDbIndex(&(arpEntryPtr->macInfo->macAddr)), arpEntryPtr->macInfo->asicPos, &asic_l2);
                                                        arpEntryPtr = arpEntryPtr->next.sle_next;
                                                        continue;
                                                }

                                        }
                                }






                                delArpEntry = arpEntryPtr;
                                arpEntryPtr = arpEntryPtr->next.sle_next;
                                _rtl8651_delLocalArp(0x03, delArpEntry->ipAddr, netIfPtr);

                        }
                }
        }
}


void _rtl8651_removeArpAndNaptFlowWhenLinkDown(int32 port, uint32 *linkId)
{
                rtl8651_tblDrv_networkIntfTable_t *netif_t = DrvTbl.netIface;
                rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
                rtl8651_tblDrv_arpEntry_t *arp_t;
                uint32 entry;






                for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                        if (netif_t->valid == 0 || !(netif_t->linkLayerType==0x01||netif_t->linkLayerType==0x04))
                                continue;
                        for((ipintf_t) = (&netif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                                arp_t = ((&ipintf_t->nextArp)->slh_first);
                                while (arp_t) {
                                        if (arp_t->fromDrv==1 && ((port>=0&&(arp_t->macInfo->memberPortMask & (1<<port)))
                                                ||(linkId&&arp_t->macInfo->linkId&&*linkId))) {


                                                _rtl8651_removeNaptConnectionBySrcIP(arp_t->ipAddr);

                                                _rtl8651_removeIcmpFlowBySrcIP(arp_t->ipAddr);
                                                if (arp_t->isBcArp == 0) {
                                                        _rtl8651_delLocalArp(1, arp_t->ipAddr, netif_t);
                                                        arp_t = ((&ipintf_t->nextArp)->slh_first);
                                                } else arp_t = ((arp_t)->next.sle_next);
                                        } else arp_t = ((arp_t)->next.sle_next);
                                }
                        }
                }
}






int32 rtl8651_setArpAgingTime(uint16 agTime) {
        rtlglue_drvMutexLock();
        arpAgingTime = agTime;
        rtlglue_drvMutexUnlock();
        return 0;
}
# 5841 "rtl8651_tblDrv.c"
int32 rtl8651_addArp(ipaddr_t ipAddr, ether_addr_t * macAddr, int8 * ifName, uint32 port)
{
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        int32 retval = -7;
        uint32 index;

        rtlglue_drvMutexLock();

        netif_t = DrvTbl.netIface;
        for(index=0; index<rtl8651_tblDrvPara.networkIntfTableSize; index++, netif_t++) {
                if(netif_t->valid == 1 && _strncmp(ifName, netif_t->ifName, 16) == 0) {





                        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                                for((ip_t) = (&ipintf_t->ipAddr)->slh_first; (ip_t); (ip_t) = (ip_t)->nextIpAddr.sle_next)
                                        if (ip_t->ipAddr == ipAddr) {
                                                retval = -6;
                                                goto out;
                                        }
                        }
                        retval = _rtl8651_addLocalArp(0, ipAddr, macAddr, netif_t, port);
                        goto out;
                }
        }


out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 5884 "rtl8651_tblDrv.c"
int32 rtl8651_delArp(ipaddr_t ipAddr)
{
        rtl8651_tblDrv_ipIntfEntry_t *ipIntf_t;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval = -3;
        uint32 index;

        rtlglue_drvMutexLock();

        netif_t = DrvTbl.netIface;
        for(index=0; index< rtl8651_tblDrvPara.networkIntfTableSize; index++, netif_t++) {
                if(netif_t->valid == 1) {
                        for((ipIntf_t) = (&(netif_t->IpHead))->slh_first; (ipIntf_t); (ipIntf_t) = (ipIntf_t)->nextIp.sle_next)
                                if ((ipIntf_t->ipMask&ipIntf_t->ipAddr.slh_first->ipAddr) == (ipIntf_t->ipMask&ipAddr)) {
                                        retval = _rtl8651_delLocalArp(0, ipAddr, netif_t);
                                        goto out;
                                }
                        }
                }

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 5921 "rtl8651_tblDrv.c"
int8 _rtl8651_localServerIpAddr(ipaddr_t ipAddr) {
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t * ipAddrPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 netIdx;

        for(netIdx=0, netIfPtr=&DrvTbl.netIface[0]; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netIfPtr++)
                if(netIfPtr->valid == 1) {







                        if ( 1 ) {
                                for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                                        if (((&ipIntfPtr->localServer)->slh_first) == ((void *)0))
                                                continue;
                                        for((ipAddrPtr) = (&ipIntfPtr->localServer)->slh_first; (ipAddrPtr); (ipAddrPtr) = (ipAddrPtr)->nextIpAddr.sle_next)
                                        {
                                                do {} while (0);
                                                if(ipAddrPtr->ipAddr == ipAddr)
                                                {
                                                        return 1;
                                                }
                                        }
                                }
                        }
                }

        return 0;
}
# 5963 "rtl8651_tblDrv.c"
int32 rtl8651_addLocalServer(ipaddr_t ipAddr) {
        rtl8651_tblDrv_ipIntfEntry_t * ipintf_t;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *tempIpAddr;
        int8 lanSideExtIp, arrangeAcl = 0;
        uint32 netIdx;

        rtlglue_drvMutexLock();
        netIfPtr = &DrvTbl.netIface[0];
        for(netIdx=0; netIdx< rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netIfPtr++) {
                if (netIfPtr->valid == 0)
                        continue;
                        for((ipintf_t) = (&(netIfPtr->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                                do {} while (0);
                        if((ipAddr & ipintf_t->ipMask) == (ipintf_t->ipAddr.slh_first->ipAddr & ipintf_t->ipMask)) {
                                lanSideExtIp = (ipintf_t->lanSideExternal==1)? 1: 0;
                                        goto subnet_found;
                        }
                }
        }




        rtlglue_drvMutexUnlock();
        return -2900;

subnet_found:




        for((tempIpAddr) = (&ipintf_t->ipAddr)->slh_first; (tempIpAddr); (tempIpAddr) = (tempIpAddr)->nextIpAddr.sle_next)
                if ((tempIpAddr->ipAddr == ipAddr)) { rtlglue_drvMutexUnlock(); return -2901; };

        for((tempIpAddr) = (&(ipintf_t->localServer))->slh_first; (tempIpAddr); (tempIpAddr) = (tempIpAddr)->nextIpAddr.sle_next)
                if ((tempIpAddr->ipAddr == ipAddr)) { rtlglue_drvMutexUnlock(); return -2902; };

        if ((((&DrvTbl.freeList.ipAddr)->slh_first) == ((void *)0))) { rtlglue_drvMutexUnlock(); return -9; };
        if ((naptIpCount+natIpCount+localServerCount) == 16)
                arrangeAcl = 1;





        if (DrvTbl.vlan[(netIfPtr->vid& (8 -1))].internal == 0 || lanSideExtIp == 1) {
                if ((_rtl8651_addIpEntry(ipAddr, ipAddr, 0x02, ((void *)0)) == ((void *)0))) { rtlglue_drvMutexUnlock(); return -9; };



        }




        tempIpAddr = ((&DrvTbl.freeList.ipAddr)->slh_first);
        do { (&DrvTbl.freeList.ipAddr)->slh_first = (&DrvTbl.freeList.ipAddr)->slh_first->nextIpAddr.sle_next; } while (0);
        tempIpAddr->ipAddr = ipAddr;
        do { (tempIpAddr)->nextIpAddr.sle_next = (&(ipintf_t->localServer))->slh_first; (&(ipintf_t->localServer))->slh_first = (tempIpAddr); } while (0);
        if (arrangeAcl == 1)
                _rtl8651_arrangeAllACL();
        rtlglue_drvMutexUnlock();
        return 0;
}







int32 rtl8651_delLocalServer(ipaddr_t ipAddr) {
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *trackIpAddr;
        rtl8651_tblDrv_ipIntfEntry_t * netPtr=((void *)0);
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 netIdx;

        rtlglue_drvMutexLock();

        for(netIdx=0,netIfPtr=&DrvTbl.netIface[0]; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++,netIfPtr++)
                if(netIfPtr->valid == 1) {
                        for((netPtr) = (&(netIfPtr->IpHead))->slh_first; (netPtr); (netPtr) = (netPtr)->nextIp.sle_next) {
                                do {} while (0);
                                if((ipAddr & netPtr->ipMask) == (netPtr->ipAddr.slh_first->ipAddr & netPtr->ipMask))
                                        goto subnet_found;
                        }
                }

subnet_found:

        if (netIdx < rtl8651_tblDrvPara.networkIntfTableSize) {
                do {} while (0);
                for((trackIpAddr) = (&(netPtr->localServer))->slh_first; (trackIpAddr); (trackIpAddr) = (trackIpAddr)->nextIpAddr.sle_next) {
                        if (trackIpAddr->ipAddr == ipAddr) {
                                do { if ((&(netPtr->localServer))->slh_first == (trackIpAddr)) { do { ((&(netPtr->localServer)))->slh_first = ((&(netPtr->localServer)))->slh_first->nextIpAddr.sle_next; } while (0); } else { struct rtl8651_tblDrv_ipIntfIpAddrEntry_s *curelm = (&(netPtr->localServer))->slh_first; while( curelm->nextIpAddr.sle_next != (trackIpAddr) ) curelm = curelm->nextIpAddr.sle_next; curelm->nextIpAddr.sle_next = curelm->nextIpAddr.sle_next->nextIpAddr.sle_next; } } while (0);
                                do { (trackIpAddr)->nextIpAddr.sle_next = (&DrvTbl.freeList.ipAddr)->slh_first; (&DrvTbl.freeList.ipAddr)->slh_first = (trackIpAddr); } while (0);
                                _rtl8651_delIpEntry(0x02, ipAddr, ipAddr);
                                rtlglue_drvMutexUnlock();
                                return 0;
                        }
                }
        }
        rtlglue_drvMutexUnlock();
        return(-2900);
}
# 6077 "rtl8651_tblDrv.c"
void _rtl8651_rmPPTPL2TPInterfaceRoute(ipaddr_t s_ipaddr)
{
        rtl8651_tblDrv_routeTable_t *rt;
        ipaddr_t mask;
        int32 retval;

        rt = _rtl8651_getRoutingEntry(s_ipaddr);
        mask = rt->ipMask;





        retval = _rtl8651_delInterfaceRoute(s_ipaddr, mask);
        do {} while (0);
}

void _rtl8651_addPPTPL2TPInterfaceRoute(rtl8651_tblDrv_pppTable_t *pppEntry_t, ipaddr_t s_ipaddr)
{
        int32 retval;
        rtl8651_tblDrv_networkIntfTable_t *netif_t = pppEntry_t->netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
                if((ipintf_t->ipAddr.slh_first->ipAddr & ipintf_t->ipMask) == ( s_ipaddr & ipintf_t->ipMask))
                        break;

        if (ipintf_t) {
                retval = _rtl8651_addInterfaceRoute(netif_t, ipintf_t, ipintf_t ->arpStartPos, ipintf_t->arpEndPos);
                do {} while (0);
                return;
        }
        do {} while (0);
}

void _rtl8651_updateDefaultRoute(void)
{
        rtl8651_tblDrv_routeTable_t *default_rt;
        rtl865x_tblAsicDrv_routingParam_t asic_rt;
        int32 retval;
# 6124 "rtl8651_tblDrv.c"
        bzero(&asic_rt, sizeof(rtl865x_tblAsicDrv_routingParam_t));

        if (rtEntry > 8 -1) {
# 6136 "rtl8651_tblDrv.c"
                asic_rt.vidx = _rtl8651_getOneVidx(0);
                asic_rt.process = 0x04;
        }
        else {
                default_rt = &DrvTbl.route[rtl8651_tblDrvPara.routingTableSize-1];
                if (default_rt->valid == 1) {
                        _rtl8651_updateL3Entry(default_rt);
                        return;
                }







                asic_rt.vidx = _rtl8651_getOneVidx(1);



                asic_rt.process = 0x04;
        }
        retval = rtl8651_setAsicRouting(8 -1, &asic_rt);
        do {} while (0);
}
# 6227 "rtl8651_tblDrv.c"
static void _rtl8651_refillL3Entry(rtl8651_tblDrv_routeTable_t *rt_t)
{
        rtl8651_tblDrv_routeTable_t *entry_t;
        int32 entry, retval;
        uint8 process;


        do {} while (0);
        entry_t = &DrvTbl.route[8 -1];

        for(entry=8 -1; entry<rtl8651_tblDrvPara.routingTableSize-1; entry++, entry_t++) {
                if (entry_t->valid == 1) {
                        rtl8651_memcpy(rt_t, entry_t, sizeof(rtl8651_tblDrv_routeTable_t));
                        entry_t->valid = 0;







                        process = rt_t->process;
                        rt_t->process = 0x05;
                        rt_t->un.nxthop.nhalog = 0x02;
                        rt_t->un.nxthop.ipDomain = 0x06;
                        rt_t->un.nxthop.next_t = ((void *)0);

                        if (rt_t->nextHopType== 0x01)
                                retval = _rtl8651_addNextHopEntry(0x05, rt_t, rt_t->netif_t, rt_t->nextHop, 0, ((void *)0));
                        else retval = _rtl8651_addNextHopEntry(0x05, rt_t, rt_t->netif_t, 0, 0, rt_t->un.nxthop.un1.session.session_t);
                        if (retval == -1) {




                                rt_t->process = process;
                        }
                        else rt_t->rt_nexthop_t = rt_t->un.nxthop.start_t;
                        _rtl8651_updateL3Entry(rt_t);
                        break;
                }
        }
}


static rtl8651_tblDrv_routeTable_t *
_rtl8651_getRTentry(ipaddr_t ipAddr, ipaddr_t ipMask)
{
        rtl8651_tblDrv_routeTable_t *rt = DrvTbl.route;
        uint32 rtIdx;

        for(rtIdx=0; rtIdx<rtl8651_tblDrvPara.routingTableSize; rtIdx++, rt++)
                if ((rt->valid==1)&&((rt->ipAddr&rt->ipMask)==(ipAddr&ipMask))&&(rt->ipMask==ipMask))
                        return (rtl8651_tblDrv_routeTable_t *)rt;
        return (rtl8651_tblDrv_routeTable_t *)((void *)0);
}


rtl8651_tblDrv_routeTable_t * _rtl8651_getRoutingEntry(ipaddr_t dstIpAddr)
{
        rtl8651_tblDrv_routeTable_t *tmpRtEntry = ((void *)0);
        rtl8651_tblDrv_routeTable_t *rt=DrvTbl.route;
        uint32 rtIdx, mask;

        for(rtIdx=0, mask=0; rtIdx<rtl8651_tblDrvPara.routingTableSize; rtIdx++,rt++) {
                if (rt->valid == 1 && rt->ipAddr == (rt->ipMask & dstIpAddr) && mask <= rt->ipMask) {
                        mask = rt->ipMask;
                        tmpRtEntry = rt;
                }
        }
        return (rtl8651_tblDrv_routeTable_t *)tmpRtEntry;
}

static void _rtl8651_updateL3Entry(rtl8651_tblDrv_routeTable_t *rt_t)
{
        rtl865x_tblAsicDrv_routingParam_t asic_t;
        uint32 entry, mbrMask, entryNum;
        int32 ret;

        do {} while (0);


        if (rt_t->nextHopType == 0x05 || rt_t->nextHopType == 0x06) {
                rtl8651_tblDrv_filterDbTableEntry_t *macInfo;
                rtl865x_tblAsicDrv_l2Param_t asic_l2;
                uint32 nextHopRow, nextHopColumn;






                if (rt_t->un.nxthop.un1.session.session_t->initiated == 1) {

                        rt_t->dvid = tunnel.loopBackVid;
                        if (rt_t->process == 0x05)
                                rt_t->un.nxthop.start_t->dvid = (rt_t->dvid& (8 -1));


                        macInfo=rt_t->un.nxthop.un1.session.session_t->macInfo;
                        do {} while (0);
                        nextHopRow = rtl8651_filterDbIndex(&macInfo->macAddr);
                        nextHopColumn = macInfo->asicPos;
                        mbrMask = (1 << tunnel.loopbackPort);
                        macInfo->memberPortMask = mbrMask;
                        if (macInfo->configToAsic == 1) {
                                rtl8651_getAsicL2Table(nextHopRow, nextHopColumn, &asic_l2);
                                asic_l2.nhFlag = 0 ;
                                asic_l2.memberPortMask = mbrMask;
                                asic_l2.isStatic = 1;
                                rtl8651_setAsicL2Table(nextHopRow, nextHopColumn, &asic_l2);
                        }
                }
        }


        entry = (rt_t-DrvTbl.route);
        if (entry>=8 -1 && entry!=rtl8651_tblDrvPara.routingTableSize-1)
                return;

        if (entry == rtl8651_tblDrvPara.routingTableSize-1)
                entry = 8 -1;

        bzero(&asic_t, sizeof(rtl865x_tblAsicDrv_routingParam_t));
        asic_t.ipAddr = rt_t->ipAddr;
        asic_t.ipMask = rt_t->ipMask;
        switch (rt_t->process)
        {
        case 0x02:
                asic_t.process = 0x02;
                asic_t.vidx = (rt_t->dvid& (8 -1));
                asic_t.arpStart = rt_t->un.arp.arpsta;
                asic_t.arpEnd = rt_t->un.arp.arpend;
                break;

        case 0x01:
        case 0x08:







                asic_t.process = 0x04;
# 6383 "rtl8651_tblDrv.c"
                asic_t.vidx = (rt_t->dvid& (8 -1));
                break;

        case 0x04:


                asic_t.vidx = (rt_t->dvid& (8 -1));
                asic_t.process = rt_t->process;
                break;

        case 0x06:
# 6403 "rtl8651_tblDrv.c"
                asic_t.vidx = (rt_t->dvid& (8 -1));
                asic_t.process = rt_t->process;
                break;

        case 0x05:
                entryNum = rt_t->un.nxthop.end_t->entryIndex - rt_t->un.nxthop.start_t->entryIndex + 1;
                asic_t.process = rt_t->process;
                asic_t.nhStart = rt_t->un.nxthop.start_t->entryIndex;
                asic_t.nhNxt = asic_t.nhStart;
                asic_t.ipDomain = rt_t->un.nxthop.ipDomain;
                asic_t.nhAlgo = rt_t->un.nxthop.nhalog;
                asic_t.nhNum = entryNum;
                break;

        default: do {} while (0);

        }
        ret = rtl8651_setAsicRouting(entry, &asic_t);
        do {} while (0);
}

static
int32 _rtl8651_addInterfaceRoute(rtl8651_tblDrv_networkIntfTable_t *netif_t, rtl8651_tblDrv_ipIntfEntry_t *ipintf_t, uint32 arpsta, uint32 arpend)
{
        rtl8651_tblDrv_routeTable_t *rt_t = &DrvTbl.route[0];
        rtl865x_tblAsicDrv_routingParam_t asic_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        uint32 entry;


        rtl8651_tblDrv_networkIntfTable_t *tmp_netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *tmp_ipintf_t;
        ipaddr_t tmp_ip;
        uint32 i, insIdx = 0;
        uint32 intfRouteFound = 1;
# 6447 "rtl8651_tblDrv.c"
        for(entry = 0; entry < rtl8651_tblDrvPara.routingTableSize-1; entry++, rt_t++) {
                if(rt_t->valid == 0)
                        break;
                if(intfRouteFound == 1)
                        for(intfRouteFound = 0, tmp_netif_t = &DrvTbl.netIface[0]; tmp_netif_t->valid == 1; tmp_netif_t++) {
                                for((tmp_ipintf_t) = (&(tmp_netif_t->IpHead))->slh_first; (tmp_ipintf_t); (tmp_ipintf_t) = (tmp_ipintf_t)->nextIp.sle_next) {
                                        tmp_ip = (tmp_ipintf_t->ipAddr.slh_first->ipAddr & tmp_ipintf_t->ipMask);
                                        if(tmp_ip == rt_t->ipAddr && tmp_ipintf_t->ipMask == rt_t->ipMask) {
                                                intfRouteFound = 1;
                                                insIdx++;
                                                break;
                                        }
                                }
                                if(intfRouteFound == 1 )
                                        break;
                        }
        }

        if(insIdx >= 8 -1 || entry == rtl8651_tblDrvPara.routingTableSize-1)
                return -1;


        for(i = entry; i > insIdx; i--)
                DrvTbl.route[i] = DrvTbl.route[i-1];

        rt_t = &DrvTbl.route[insIdx];
# 6481 "rtl8651_tblDrv.c"
        ip_t = ((&ipintf_t->ipAddr)->slh_first);
        rt_t->ipAddr = ip_t->ipAddr & ipintf_t->ipMask;
        rt_t->ipMask = ipintf_t->ipMask;
        rt_t->nextHop = 0;
        if (netif_t->linkLayerType==0x04) {
                rt_t->nextHopType = 0x01;
                rt_t->process = (arpsta==0xffffffff)? 0x04: 0x02;
        }
        else {
                rt_t->nextHopType = netif_t->linkLayerType;







                if (netif_t->linkLayerType == 0x05 || netif_t->linkLayerType == 0x06)
                        rt_t->process = 0x04;
                else
                        rt_t->process = (arpsta==0xffffffff)? 0x04: 0x02;

        }
        rt_t->ipClass = (arpsta==0xffffffff)? 1: 0;
        rt_t->ifrt_flag = 1;
        rt_t->valid = 1;
        rt_t->netif_t = netif_t;
        rt_t->ipintf_t = ipintf_t;
        rt_t->dvid = netif_t->vid;
        rt_t->un.arp.arpsta = arpsta;
        rt_t->un.arp.arpend = arpend;

        asic_t.ipAddr = rt_t->ipAddr;
        asic_t.ipMask = rt_t->ipMask;
        asic_t.process = rt_t->process;


        if (rt_t->process == 0x04)
                asic_t.vidx = _rtl8651_getOneVidx(0);
        else if (rt_t->process == 0x06)
                asic_t.vidx = _rtl8651_getOneVidx(1);
        else
                asic_t.vidx = (rt_t->dvid& (8 -1));

        asic_t.arpStart = rt_t->un.arp.arpsta;
        asic_t.arpEnd = rt_t->un.arp.arpend;
# 6538 "rtl8651_tblDrv.c"
        rtl8651_setAsicRouting(insIdx, &asic_t);
        rtEntry ++;


        for(i = insIdx + 1; i < 8 -1 && i < rtEntry; i++)
                _rtl8651_updateL3Entry(&DrvTbl.route[i]);

        return 0;
}


static int32 _rtl8651_delInterfaceRoute(ipaddr_t ipAddr, ipaddr_t ipMask)
{
        rtl8651_tblDrv_arpAsicArrangementEntry_t *asic_arp_t;
        rtl8651_tblDrv_routeTable_t *rt_t=DrvTbl.route;
        uint32 entry;

        for(entry=0; entry<8 -1; entry++, rt_t++) {
                if (rt_t->valid && ((rt_t->ipAddr&rt_t->ipMask)==(ipAddr&ipMask)) && (ipMask==rt_t->ipMask)) {
                        rt_t->valid = 0;
                        rt_t->ipAddr = 0;
                        rtl8651_delAsicRouting(entry);
                        if (rt_t->un.arp.arpsta != 0xffffffff) {
                                asic_arp_t = &AsicTableUsage.arp[rt_t->un.arp.arpsta];
                                for(entry=rt_t->un.arp.arpsta; entry<=rt_t->un.arp.arpend; entry++)
                                        asic_arp_t->valid = 0;
                        }
                        rtEntry --;
                        return 0;
                }
        }
        return -1;
}



static int32 _rtl8651_addRoute(ipaddr_t ipAddr, ipaddr_t ipMask, int8 * ifName, ipaddr_t nextHop)
{

        rtl8651_tblDrvSession_t *session_t = ((void *)0);
        rtl8651_tblDrv_arpEntry_t *arpEntry_t = ((void *)0);
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_routeTable_t *rt;
        uint32 rtIdx, llType;
        int32 retval;


        rtl8651_tblDrv_networkIntfTable_t *tmp_netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *tmp_ipintf_t;
        ipaddr_t tmp_ip;
        uint32 i, insIdx = 0, zeroMask_ipintf = 0;
        uint32 intfRouteFound = 1, insIdxFixed = 0;







        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0))
                return -7;


        if (netif_t->linkLayerType == 0)
                return -2515;


        if (_rtl8651_getRTentry(ipAddr, ipMask) != ((void *)0))
                return -2300;


        for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                for((ip_t) = (&ipintf_t->ipAddr)->slh_first; (ip_t); (ip_t) = (ip_t)->nextIpAddr.sle_next) {
                        if (!(netif_t->linkLayerType == 0x01 && ipintf_t->ipMask == 0) && nextHop == ip_t->ipAddr)
                                return -2301;
                }
        }

        if ( ((llType= netif_t->linkLayerType) == 0x04) ||
                (llType == 0x03))
                llType = 0x02;


        switch(llType) {
        case 0x01:




                for((ipintf_t) = (&(netif_t->IpHead))->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)






                        if ((ipintf_t->ipAddr.slh_first->ipAddr & ipintf_t->ipMask) ==
                                (nextHop & ipintf_t->ipMask)) {
                                for((arpEntry_t) = (&(ipintf_t->nextArp))->slh_first; (arpEntry_t); (arpEntry_t) = (arpEntry_t)->next.sle_next)
                                        if (arpEntry_t->ipAddr == nextHop)
                                                break;
                                break;
                        }

                if (!ipintf_t)
                        return -2301;
                else if (ipintf_t->ipMask == 0)
                        zeroMask_ipintf = 1;

                break;

        case 0x05:
        case 0x06:
        case 0x02:





                do {} while (0);
                if(nextHop == 0) {
                        if ((session_t=((&netif_t->sessionHead)->tqh_first)) == ((void *)0))
                        {
                                printk("Get First session fail!\n");
                                return -2302;
                        }
                }
                else {
                        for (session_t = ((&netif_t->sessionHead)->tqh_first); session_t; session_t = ((session_t)->nextSession.tqe_next)) {
                                do {} while (0);



                                if (session_t->session_t->sessionId == nextHop)
                                        break;
                        }
                        if (!session_t)
                        {
                                printk("NextHop Specify fail!\n");
                                return -2302;
                        }
                }
                break;

        default: do {} while (0);
        }
# 6701 "rtl8651_tblDrv.c"
        if (ipMask != 0) {

                rt = DrvTbl.route;

                for(rtIdx=0; rtIdx<rtl8651_tblDrvPara.routingTableSize-1; rtIdx++, rt++) {
                        if(rt->valid == 0)
                                break;
                        if(intfRouteFound != 0) {
                                for(intfRouteFound = 0, tmp_netif_t = &DrvTbl.netIface[0]; tmp_netif_t->valid == 1; tmp_netif_t++) {
                                        for((tmp_ipintf_t) = (&(tmp_netif_t->IpHead))->slh_first; (tmp_ipintf_t); (tmp_ipintf_t) = (tmp_ipintf_t)->nextIp.sle_next) {
                                                tmp_ip = (tmp_ipintf_t->ipAddr.slh_first->ipAddr & tmp_ipintf_t->ipMask);





                                                if(tmp_ip == rt->ipAddr && tmp_ipintf_t->ipMask == rt->ipMask) {

                                                        intfRouteFound = 1;
                                                        insIdx++;
                                                        break;
                                                }
                                        }
                                        if(intfRouteFound == 1)
                                                break;
                                }
                        }
                        if(intfRouteFound == 0 && insIdxFixed == 0) {
                                if(rt->ipMask < ipMask) {
                                        insIdx = rtIdx;
                                        insIdxFixed = 1;
                                }
                                else
                                        insIdx++;
                        }
                }
# 6745 "rtl8651_tblDrv.c"
                if (rtIdx == rtl8651_tblDrvPara.routingTableSize-1)
                        return -9;

                for(i = rtIdx; i > insIdx; i--)
                        DrvTbl.route[i] = DrvTbl.route[i-1];

                rtEntry ++;

                rt = &DrvTbl.route[insIdx];
        }
        else {






                rt = &DrvTbl.route[rtl8651_tblDrvPara.routingTableSize-1];
                do {} while (0);
        }


        rt->valid = 1;
        rt->ipAddr = ipAddr & ipMask;
        rt->ipMask = ipMask;
        rt->nextHop = nextHop;
        rt->nextHopType = llType;
# 6782 "rtl8651_tblDrv.c"
        if (zeroMask_ipintf == 1 && ipMask == 0) {
                rt->ifrt_flag = 1;
                rt->ipClass = 1;
        }
        else {
                rt->ifrt_flag = 0;
                rt->ipClass = 0;
        }

        rt->ipintf_t = ipintf_t;
        rt->netif_t = netif_t;
        rt->dvid = netif_t->vid;

        if (llType == 0x01) {
                rt->process = 0x01;
                rt->un.nxthop.un1.direct.arp_t = arpEntry_t;
        }
        else {
                rt->process = 0x08;
                rt->un.nxthop.un1.session.session_t = session_t->session_t;
                if (llType == 0x05 || llType == 0x06)
                        rt->dvid = tunnel.loopBackVid;
        }
# 6814 "rtl8651_tblDrv.c"
        if ((!(zeroMask_ipintf == 1 && ipMask == 0)) && (((rt-DrvTbl.route)<(8 -1))||((rt-DrvTbl.route)==(rtl8651_tblDrvPara.routingTableSize-1)))) {
                uint8 process = rt->process;
                rt->process = 0x05;
                rt->un.nxthop.nhalog = 0x02;
                rt->un.nxthop.ipDomain = 0x06;
                rt->un.nxthop.next_t = ((void *)0);

                if (llType == 0x01)
                        retval = _rtl8651_addNextHopEntry(0x05, rt, netif_t, nextHop, 0, ((void *)0));
                else retval = _rtl8651_addNextHopEntry(0x05, rt, netif_t, 0, 0, session_t->session_t);
                if (retval == -1) {




                        rt->process = process;
                }
                else rt->rt_nexthop_t = rt->un.nxthop.start_t;
        }

        _rtl8651_updateL3Entry(rt);
        _rtl8651_updateDefaultRoute();

        if (ipMask == 0)
                _rtl8651_ipTbl_setDefNexthop(rt);




        if(ipMask!=0)

                for(i = insIdx + 1; i < 8 -1 && i < rtEntry; i++)
                        _rtl8651_updateL3Entry(&DrvTbl.route[i]);

        return 0;
}


static int32 _rtl8651_delRoute(ipaddr_t ipAddr, ipaddr_t ipMask)
{
        rtl8651_tblDrv_routeTable_t *rt_t;
        ether_addr_t *mac_t=((void *)0);
        uint32 entry, mbrMask;
        int32 retval;






        if ((rt_t=_rtl8651_getRTentry(ipAddr, ipMask)) == ((void *)0))
                return -3;






        if (rt_t->ifrt_flag == 1)
                return -2303;
        rt_t->valid = 0;
        rt_t->ipAddr = 0;
        if (tunnel.valid == 1)
                mac_t = &rt_t->un.nxthop.un1.session.session_t->macInfo->macAddr;
        if (rt_t->process == 0x05)
                _rtl8651_delNextHopEntry(0x05, rt_t);
        if ((entry = (rt_t-DrvTbl.route)) != rtl8651_tblDrvPara.routingTableSize-1)
                rtEntry --;
        if (entry<8 -1 || entry == rtl8651_tblDrvPara.routingTableSize-1) {
                if (entry == rtl8651_tblDrvPara.routingTableSize-1)
                        entry = 8 - 1;
                retval = rtl8651_delAsicRouting(entry);
                do {} while (0);
                _rtl8651_refillL3Entry(rt_t);
        }


        if (tunnel.valid == 1) {
                rt_t = DrvTbl.route;
                for(entry=0; entry<rtl8651_tblDrvPara.routingTableSize; entry++, rt_t++) {
                        if (rt_t->valid == 1 && rt_t->ifrt_flag == 0 &&
                           (rt_t->nextHopType==0x05 || rt_t->nextHopType==0x06))
                           break;
                }
                if (entry == rtl8651_tblDrvPara.routingTableSize) {
                        mbrMask = (1 << tunnel.wanPort);
                        _rtl8651_modifyVlanRefFilterDatabaseEntry(0, mac_t , &mbrMask, 0x00, ((void *)0), 0x01);
                }
        }

        if (ipMask == 0)
                _rtl8651_ipTbl_setDefNexthop(((void *)0));
        _rtl8651_updateDefaultRoute();

        return 0;
}
# 6932 "rtl8651_tblDrv.c"
int32 rtl8651_addRoute(ipaddr_t ipAddr, ipaddr_t ipMask, int8 * ifName, ipaddr_t nextHop) {
        int32 retval ;
        rtlglue_drvMutexLock();
        retval = _rtl8651_addRoute(ipAddr, ipMask, ifName, nextHop) ;
        rtlglue_drvMutexUnlock();
        return retval;
}
# 6951 "rtl8651_tblDrv.c"
int32 rtl8651_delRoute(ipaddr_t ipAddr, ipaddr_t ipMask) {
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_delRoute(ipAddr, ipMask);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 6968 "rtl8651_tblDrv.c"
int hashcode(int value)
{
        value ^= (value>>16);
        value ^= (value>>8);
        value^= (value>>3);
        value = value&(32 -1);
        return value;
}
uint32 _rtl8651_SessionIDToDSID(uint32 SessionID)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrvSession_t *pppoes_t = ((void *)0);
        uint32 i;
        netif_t = &DrvTbl.netIface[0];
        for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netif_t++)
                if (netif_t->valid == 1) {
                        for (pppoes_t = ((&netif_t->sessionHead)->tqh_first); pppoes_t; pppoes_t = ((pppoes_t)->nextSession.tqe_next)) {
                                do {} while (0);
                                if (pppoes_t->session_t->sessionId == SessionID)
                                        {
                                        return pppoes_t->session_t->dsid;
                                        }
                        }
                }
        return 0;
}

rtl8651_tblDrv_pppTable_t *
_rtl8651_getPppoeSessionByDsid(uint32 dsid)
{
        rtl8651_tblDrv_pppTable_t *entry_t = DrvTbl.pppoe;
        uint32 entry;

        for(entry=0; entry<8; entry++, entry_t++) {
                if (entry_t->valid && entry_t->dsid == dsid)
                        return entry_t;
        }
        return (rtl8651_tblDrv_pppTable_t *)((void *)0);
}

int32 rtl8651_setPppoeDefaultSessionId(uint32 SessionID)
{
        uint32 dsid=_rtl8651_SessionIDToDSID(SessionID);
        _rtl8651_DefaultDialSessionId=dsid;
        return 0;
}

int _rtl8651_getpppDSID(uint32 ip_alias)
{

                rtl8651_tblDrv_pppTable_t *poe_tb=((void *)0);
                int id=0;
                poe_tb = _rtl8651_getPppoeSessionByIpAddr(ip_alias);
                if (poe_tb)
                        id= poe_tb->dsid;
                return id;

}
int _rtl8651_getPolicyRoutingDSID(struct rtl_pktHdr *pktHdr,uint32 ip_d,uint32 ip_s,uint8 proto,int ip_dp)
{
        int type,hash;
        _rtl8651_tblDrvPolicyRoute_t *rtEntry=&rtStaticPolicy[0];
        switch(proto)
        {
                case 6:
                        type=0x20;
                        break;
                case 17:
                        type=0x40;
                        break;
                default:
                        type=0;

        }
        for (;rtEntry->type!=0;rtEntry++)
        {
                switch (rtEntry->type)
                {
                        case 0x10:
                                if ((rtEntry->ip_start<=ip_d)&&
                                        (rtEntry->ip_end>=ip_d))
                                        goto match;
                                break;
                        case 0x30:
                                if ((rtEntry->ip_start<=ip_s)&&
                                        (rtEntry->ip_end>=ip_s))
                                        goto match;
                                break;
                        case 0x20:
                        case 0x40:
                                if ((rtEntry->trigger.dport.start<=ip_dp)&&
                                        (rtEntry->trigger.dport.end>=ip_dp)&&
                                        (rtEntry->type==type))
                                        goto match;
                                break;
                        case 0x50:
                                if ((rtEntry->ip_start<=ip_s)&&
                                        (rtEntry->ip_end>=ip_s))

                                        {
                                                pktHdr->ph_un_sw.ROMEDRV_USG._ph_unnumber=1;
                                                goto match;
                                        }
                                break;


                }
        }

        hash = hashcode(ip_d);
        rtEntry = rtHashTable[hash];

        while (rtEntry)
        {
                if ( rtEntry->age > 0 )
                {
                        switch ( rtEntry->type )
                        {

                                case 0x10:
                                        if ( rtEntry->trigger.ip_d == ip_d )
                                        {
                                                goto match;
                                        }
                                        break;
                                case 0x60:
                                        if ( (rtEntry->trigger.sipDipPair.sip == ip_s) &&
                                                (rtEntry->trigger.sipDipPair.dip == ip_d) )
                                        {
                                                goto match;
                                        }
                                        break;
                        }
                }
                rtEntry=rtEntry->linknext;
        }
        ;

        return _rtl8651_DefaultDialSessionId;
match:

        return _rtl8651_getpppDSID(rtEntry->ip_alias);

}

static void _rtl8651_dynamicPolicyRouteTimeupdate(uint32 secpassed)
{
        _rtl8651_tblDrvPolicyRoute_t *ptr;

        ptr = rtDynamicPolicyHeadPtr;

        while ( ptr )
        {
                if ( ptr->age > secpassed )
                {
                        ptr->age -= secpassed;
                } else
                {
                        if ( ptr->age > 0 )
                        {
                                ipaddr_t dip = 0;

                                dip = ((ptr->type & ~0x0f) == 0x10)?ptr->trigger.ip_d:((ptr->type & ~0x0f) == 0x60)?ptr->trigger.sipDipPair.dip:0;

                                ;






                        }

                        ptr->age = 0;
                }


                ptr = ptr->timenext;
                if ( ptr == rtDynamicPolicyHeadPtr )
                {
                        ptr = ((void *)0);
                }
        }
}






rtl8651_tblDrv_routeTable_t * _rtl8651_getSoftRoutingEntry(uint32 ip_s, uint32 ip_d,uint8 proto,int ip_dp)
{
        int type,hash;
        _rtl8651_tblDrvPolicyRoute_t *rtEntry=&rtStaticPolicy[0];
        switch(proto)
        {
                case 6:
                        type=0x20;
                        break;
                case 17:
                        type=0x40;
                        break;
                default:
                        type=0;

        }
        for (;rtEntry->type!=0;rtEntry++)
        {
                switch (rtEntry->type)
                {
                        case 0x10:
                                if ((rtEntry->ip_start<=ip_d)&&
                                        (rtEntry->ip_end>=ip_d))
                                        goto match;
                                break;
                        case 0x30:
                                if ((rtEntry->ip_start<=ip_s)&&
                                        (rtEntry->ip_end>=ip_s))
                                        goto match;
                                break;
                        case 0x20:
                        case 0x40:
                                if ((rtEntry->trigger.dport.start<=ip_dp)&&
                                        (rtEntry->trigger.dport.end>=ip_dp)&&
                                        (rtEntry->type==type))
                                        goto match;
                                break;
                        case 0x50:
                                if ((rtEntry->ip_start<=ip_s)&&
                                        (rtEntry->ip_end>=ip_s))
                                        goto match;
                                break;

                }
        }

        hash = hashcode(ip_d);
        rtEntry = rtHashTable[hash];

        while (rtEntry)
        {
                if ( rtEntry->age > 0 )
                {
                        switch ( rtEntry->type )
                        {

                                case 0x10:
                                        if ( rtEntry->trigger.ip_d == ip_d )
                                        {
                                                goto match;
                                        }
                                        break;
                                case 0x60:
                                        if ( (rtEntry->trigger.sipDipPair.sip == ip_s) &&
                                                (rtEntry->trigger.sipDipPair.dip == ip_d) )
                                        {
                                                goto match;
                                        }
                                        break;
                        }
                }

                rtEntry=rtEntry->linknext;
        }
        ;
        return 0;
match:
        ;
        return ( rtl8651_tblDrv_routeTable_t *)rtEntry->rt;

}
# 7250 "rtl8651_tblDrv.c"
int32 rtl8651_flushPolicyRoute(uint32 ip)
{
        int rtIdx,rtNewIdx,hash;
        _rtl8651_tblDrvPolicyRoute_t *rtEntry,*rt1,*rt2;
        ;
        if (!ip) return 0;
        rtlglue_drvMutexLock();
        rtEntry=&rtStaticPolicy[0];
        for(rtIdx=0; rtIdx<32; rtIdx++,rtEntry++)
        {
                if (rtEntry->ip_alias==ip)
                        rtEntry->type=0;
        }
        for(rtIdx=0; rtIdx<32; rtIdx++)
        {
                if (rtStaticPolicy[rtIdx].type==0)
                {
                        for(rtNewIdx=rtIdx+1; rtNewIdx<32; rtNewIdx++)
                                if (rtStaticPolicy[rtNewIdx].type!=0)
                                {
                                        rtStaticPolicy[rtIdx]=rtStaticPolicy[rtNewIdx];
                                        rtStaticPolicy[rtNewIdx].type=0;
                                        break;
                                }

                }
        }
        rtEntry=rtDynamicPolicyHeadPtr;
        for (rtIdx=0;rtIdx<32;rtIdx++,rtEntry=rtEntry->timenext)
        {
                if (rtEntry->ip_alias!=ip)
                        continue;

                switch ( rtEntry->type & ~0x0f )
                {
                        case 0x10:
                                hash = hashcode (rtEntry->trigger.ip_d);
                                break;
                        case 0x60:
                                hash = hashcode (rtEntry->trigger.sipDipPair.dip);
                                break;
                        default:
                                hash = 0;
                                do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 7293, "Unsupport Dynamic entry."); while(1);} while (0);;
                                break;
                }

                rt1 = rtHashTable[hash];

                if (rt1 == rtEntry)
                {
                        rtHashTable[hash]=rt1->linknext;
                        rt1->linkprev=0;
                }
                else
                {
                        rt1=rtEntry->linkprev;
                        rt2=rtEntry->linknext;
                        rt1->linknext=rtEntry->linknext;
                        if (rt2)
                                rt2->linkprev=rt1;

                }
                rtEntry->linkprev=0;
                rtEntry->linknext=0;
                memset(&(rtEntry->trigger), 0, sizeof(rtEntry->trigger));
                rtEntry->ip_alias=0;
                rtEntry->fullAge = 0;
                rtEntry->age = 0;
        }
        rtlglue_drvMutexUnlock();
        return 0;
}
# 7332 "rtl8651_tblDrv.c"
int32 rtl8651_addPolicyRoute(rtl8651_tblDrvPolicyRoute_t *rtAdd)
{
        int32 retval = -1;

        if (rtAdd == ((void *)0)) return -6;;

        rtlglue_drvMutexLock();
        retval = _rtl8651_addPolicyRoute( rtAdd, 3600 );
        rtlglue_drvMutexUnlock();

        return retval;
}
int32 _rtl8651_addPolicyRoute(rtl8651_tblDrvPolicyRoute_t *rtAdd, uint32 dynamicPolicyRtAge)
{
        int rtIdx;
        int hash,hash_old;
        rtl8651_tblDrv_routeTable_t *rt;
        _rtl8651_tblDrvPolicyRoute_t *rtEntry=&rtStaticPolicy[0];
        _rtl8651_tblDrvPolicyRoute_t *rtTemp;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrvSession_t *session_t=((void *)0);

        if ((rtAdd->type&0x02))
        {
                goto labelDynamicAdd;
        }





        for(rtIdx=0; rtIdx<32; rtIdx++, rtEntry++)
        {
                if (rtEntry->type != (rtAdd->type&(~0x0f)))
                        continue;
                switch(rtEntry->type)
                {
                        case 0x10:
                        case 0x30:
                        case 0x50:
                                if (rtEntry->ip_start==rtAdd->ip_start && rtEntry->ip_end==rtAdd->ip_end)
                                        rtEntry->ip_alias=rtAdd->ip_alias;
                                else
                                        break;
                                return 1;

                        case 0x20:
                        case 0x40:
                                if (rtEntry->trigger.ip_d==rtAdd->trigger.ip_d)
                                        rtEntry->ip_alias=rtAdd->ip_alias;
                                else
                                        break;
                                return 1;
                }

        }

        rtEntry=&rtStaticPolicy[0];
        for(rtIdx=0; rtIdx<32; rtIdx++, rtEntry++)
                if (rtEntry->type == 0)
                        break;
        if (rtIdx==32)
        {
                return 2;
        }
        else
                goto labelStaticAdd;





labelDynamicAdd:


        if (dynamicPolicyRtAge == 0) return -6;;


        switch ( rtAdd->type & ~0x0f )
        {
                case 0x10:
                        hash = hashcode (rtAdd->trigger.ip_d);
                        break;
                case 0x60:
                        hash = hashcode (rtAdd->trigger.sipDipPair.dip);
                        break;
                default:
                        do {if ((1<<1) & 0xffffffff) printk("(%x)[%s-%d]-warning-: " "The dynamic policy entry does not support the trigger type [%d]" "\n", (1<<1), __FUNCTION__, 7421, (rtAdd->type & ~0x0f));} while (0);;


                        return -6;
        }


        rtEntry = rtHashTable[hash];
        while ( rtEntry )
        {
                if ( rtEntry->age > 0 )
                {
                        int32 isMatch = 0;

                        switch ( rtEntry->type )
                        {

                                case 0x10:
                                        if ( rtEntry->trigger.ip_d == rtAdd->trigger.ip_d )
                                        {
                                                isMatch = 1;
                                        }
                                        break;
                                case 0x60:
                                        if ( (rtEntry->trigger.sipDipPair.sip == rtAdd->trigger.sipDipPair.sip) &&
                                                (rtEntry->trigger.sipDipPair.dip == rtAdd->trigger.sipDipPair.dip) )
                                        {
                                                isMatch = 1;
                                        }
                                        break;
                                default:
                                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 7450, "Un-supported dynamic policy route type."); while(1);} while (0);;
                        }

                        if (isMatch == 1)
                        {

                                rtEntry->ip_alias = rtAdd->ip_alias;
                                rtEntry->age = rtEntry->fullAge = dynamicPolicyRtAge;

                                {
                                        ipaddr_t dip = 0;

                                        dip = ((rtAdd->type & ~0x0f) == 0x10)?rtAdd->trigger.ip_d:((rtAdd->type & ~0x0f) == 0x60)?rtAdd->trigger.sipDipPair.dip:0;

                                        ;







                                }

                                return 1;
                        }
                }
                rtEntry = rtEntry->linknext;
        }
# 7488 "rtl8651_tblDrv.c"
        {
                _rtl8651_tblDrvPolicyRoute_t *ptr, *lru = ((void *)0);

                ptr = rtDynamicPolicyHeadPtr;

                while ( ptr )
                {
                        if ( ptr->age == 0 )
                        {
                                break;
                        } else
                        {
                                if ( ( lru == ((void *)0) ) ||
                                        ( (lru->fullAge-lru->age) < (ptr->fullAge-ptr->age) ) )
                                {
                                        lru = ptr;
                                }
                        }

                        ptr = ptr->timenext;
                        if ( ptr == rtDynamicPolicyHeadPtr )
                        {
                                ptr = ((void *)0);
                        }
                }

                if ( ptr )
                {
                        rtEntry = ptr;
                } else if ( lru )
                {
                        rtEntry = lru;
                } else
                {
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 7522, "No any Dynamic Policy Route Entry!"); while(1);} while (0);;
                        return -9;
                }
        }

        rtTemp = rtHashTable[hash];

        if ( (rtEntry->linkprev == ((void *)0)) &&
                (rtEntry->fullAge ))
        {
                switch ( rtEntry->type & ~0x0f )
                {
                        case 0x10:
                                hash_old = hashcode (rtEntry->trigger.ip_d);
                                break;
                        case 0x60:
                                hash_old = hashcode (rtEntry->trigger.sipDipPair.dip);
                                break;
                        default:
                                hash_old = 0;
                                do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 7542, "un-supported dynamic routing type."); while(1);} while (0);;
                }

                if (rtHashTable[hash_old] == rtEntry)
                {
                        rtHashTable[hash_old] = ((void *)0);
                }

        }


        if (rtTemp != rtEntry)
        {
                if (rtEntry->linkprev)
                        rtEntry->linkprev->linknext=rtEntry->linknext;
                if (rtEntry->linknext)
                        rtEntry->linknext->linkprev=rtEntry->linkprev;

                rtEntry->linknext=rtTemp;
                if (rtTemp)
                        rtTemp->linkprev = rtEntry;
                rtEntry->linkprev = 0;
        }
        rtEntry->age = rtEntry->fullAge = dynamicPolicyRtAge;
        rtHashTable[hash] = rtEntry;

        {
                ipaddr_t dip = 0;

                dip = ((rtAdd->type & ~0x0f) == 0x10)?rtAdd->trigger.ip_d:((rtAdd->type & ~0x0f) == 0x60)?rtAdd->trigger.sipDipPair.dip:0;

                ;






        }



labelStaticAdd:

        {
                int32 ifIndex = 0;
                netif_t =DrvTbl.netIface;
                for( ; ifIndex < rtl8651_tblDrvPara.networkIntfTableSize; ifIndex++, netif_t++){
                        if (netif_t->valid == 0)
                                continue;
                        for (session_t = ((&netif_t->sessionHead)->tqh_first); session_t; session_t = ((session_t)->nextSession.tqe_next)) {
                                if (session_t->ip_t && session_t->ip_t->ipAddr == rtAdd->ip_alias)
                                        goto found_session;
                        }
                }
        }
found_session:
        if (session_t == ((void *)0)) {
                return 1;
        }

        if (rtEntry->type&0x50) {

                _rtl8651_addRoute(rtAdd->ip_start, 0xffffffff, netif_t->ifName, session_t->session_t->sessionId);
                rt=_rtl8651_getRoutingEntry(rtAdd->ip_start);
        }
        else {

                _rtl8651_addRoute(rtAdd->ip_alias, 0xffffffff, netif_t->ifName, session_t->session_t->sessionId);
                rt=_rtl8651_getRoutingEntry(rtAdd->ip_alias);
        }
        rtEntry->rt=(void*)rt;
        rtEntry->type=(rtAdd->type&(~0x0f));
        memcpy(&(rtEntry->trigger), &(rtAdd->trigger), sizeof(rtAdd->trigger));
        rtEntry->ip_alias=rtAdd->ip_alias;
        rtEntry->ip_start=rtAdd->ip_start;
        rtEntry->ip_end=rtAdd->ip_end;

        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;

        return 0;
}


int32 _rtl8651_softNaptPolicyRoute(int type, ipaddr_t ip_s,ipaddr_t ip_d,uint16 ip_dp,
                                int *ip_alias, uint16 *ip_aliasp)
{
        int hash;
        _rtl8651_tblDrvPolicyRoute_t *rtEntry=&rtStaticPolicy[0];
        _rtl8651_tblDrvPolicyRoute_t *rtTemp,*rtPPrev;
        for (;rtEntry->type!=0;rtEntry++)
        {
                switch (rtEntry->type)
                {
                        case 0x30:
                                if ((rtEntry->ip_start<=ip_s)&&
                                        (rtEntry->ip_end>=ip_s))
                                        goto match;
                                break;
                        case 0x10:
                                if ((rtEntry->ip_start<=ip_d)&&
                                        (rtEntry->ip_end>=ip_d))
                                        goto match;
                                break;
                        case 0x20:
                        case 0x40:
                                if ((rtEntry->trigger.dport.start<=ip_dp)&&
                                        (rtEntry->trigger.dport.end>=ip_dp)&&
                                        (rtEntry->type==type))
                                        goto match;
                                break;
                }

        }

        hash = hashcode(ip_d);
        rtEntry = rtHashTable[hash];
        while (rtEntry)
        {
                if ( rtEntry->age > 0 )
                {
                        int8 isMatch = 0;
                        switch ( rtEntry->type & ~0x0f )
                        {
                                case 0x10:
                                        if ( rtEntry->trigger.ip_d == ip_d )
                                        {
                                                isMatch = 1;
                                        }
                                        break;
                                case 0x60:
                                        if ( ( rtEntry->trigger.sipDipPair.sip == ip_s ) &&
                                                ( rtEntry->trigger.sipDipPair.dip == ip_d ))
                                        {
                                                isMatch = 1;
                                        }
                                        break;
                        }

                        if ( isMatch == 1 )
                        {

                                rtEntry->age = rtEntry->fullAge;

                                if (rtDynamicPolicyHeadPtr->timeprev!=rtEntry)
                                {
                                        if (rtDynamicPolicyHeadPtr==rtEntry)
                                        {
                                                rtDynamicPolicyHeadPtr=rtEntry;
                                                goto match;
                                        }

                                        rtPPrev=rtDynamicPolicyHeadPtr->timeprev;
                                        rtTemp=rtEntry->timenext;
                                        rtTemp->timeprev=rtEntry->timeprev;

                                        rtTemp=rtEntry->timeprev;
                                        rtTemp->timenext=rtEntry->timenext;

                                        rtDynamicPolicyHeadPtr->timeprev=rtEntry;
                                        rtEntry->timenext=rtDynamicPolicyHeadPtr;
                                        rtEntry->timeprev=rtPPrev;
                                        rtPPrev->timenext=rtEntry;
                                }

                                goto match;
                        }
                }
                rtEntry=rtEntry->linknext;
        }
        *(int*)ip_alias=0;
        return 0;
match:
        *ip_alias=rtEntry->ip_alias;
        *ip_aliasp=global_port++;
        return 1;
}
# 7752 "rtl8651_tblDrv.c"
int32 _rtl8651_softIcmpPolicyRoute(ipaddr_t sip, uint16 sID, ipaddr_t dip, ipaddr_t *gip, uint16 *gID)
{
        int hash;
        _rtl8651_tblDrvPolicyRoute_t *rtEntry = &rtStaticPolicy[0];
        _rtl8651_tblDrvPolicyRoute_t *rtTemp,*rtPPrev;


        for (;rtEntry->type!=0;rtEntry ++)
        {
                switch (rtEntry->type)
                {
                        case 0x30:
                                if ((rtEntry->ip_start <= sip)&&(rtEntry->ip_end >= sip))
                                        goto match;
                                break;
                        case 0x10:
                                if ((rtEntry->ip_start <= dip)&&(rtEntry->ip_end >= dip))
                                        goto match;
                                break;
                }
        }
        hash = hashcode(dip);
        rtEntry = rtHashTable[hash];
        while (rtEntry)
        {
                if ( rtEntry->age > 0 )
                {
                        int8 isMatch = 0;

                        switch ( rtEntry->type & ~0x0f )
                        {
                                case 0x10:
                                        if ( rtEntry->trigger.ip_d == dip )
                                        {
                                                isMatch = 1;
                                        }
                                        break;
                                case 0x60:
                                        if ( ( rtEntry->trigger.sipDipPair.sip == sip ) &&
                                                ( rtEntry->trigger.sipDipPair.dip == dip ))
                                        {
                                                isMatch = 1;
                                        }
                                        break;
                        }

                        if ( isMatch == 1 )
                        {

                                rtEntry->age = rtEntry->fullAge;

                                if (rtDynamicPolicyHeadPtr->timeprev!=rtEntry)
                                {
                                        if (rtDynamicPolicyHeadPtr==rtEntry)
                                        {
                                                rtDynamicPolicyHeadPtr=rtEntry;
                                                goto match;
                                        }
                                        rtPPrev=rtDynamicPolicyHeadPtr->timeprev;
                                        rtTemp=rtEntry->timenext;
                                        rtTemp->timeprev=rtEntry->timeprev;

                                        rtTemp=rtEntry->timeprev;
                                        rtTemp->timenext=rtEntry->timenext;

                                        rtDynamicPolicyHeadPtr->timeprev=rtEntry;
                                        rtEntry->timenext=rtDynamicPolicyHeadPtr;
                                        rtEntry->timeprev=rtPPrev;
                                        rtPPrev->timenext=rtEntry;
                                }

                                goto match;
                        }
                }
                rtEntry=rtEntry->linknext;
        }
        *gip = 0;
        *gID = 0;
        return -1;

match:

        *gip = rtEntry->ip_alias;
        *gID = icmp_global_port++;

        if (icmp_global_port >= 65500) icmp_global_port = 3200;

        return 0;
}
# 7953 "rtl8651_tblDrv.c"
uint32 _rtl8651_getDemandRoutingEntry(uint32 ip_s,uint32 ip_d,uint8 proto,uint16 ip_dp)
{
        int rtIdx,identity;
        rtl8651_tblDrvDemandRoute_t *rtEntry=&rtDemandRouteTable[0],*rtTemp=((void *)0);
        uint16 type=0;
        ;

        switch(proto)
        {
                case 6:
                        type=0x20;
                        break;
                case 17:
                        type=0x40;
                        break;
        }
        for(rtIdx=0; rtIdx<32 && rtEntry->type!=0; rtIdx++, rtEntry++)
        {
                if (rtEntry->type == 0)
                        break;
                switch (rtEntry->type)
                {
                        case 0x10:
                                if ((rtEntry->ip_start<=ip_d)&&
                                        (rtEntry->ip_end>=ip_d))
                                {
                                        if ((rtEntry->ip_start==0)&&(rtEntry->ip_end==0xffffffff))
                                        {
                                                        rtTemp=rtEntry;
                                                        continue;
                                        }
                                        goto match;
                                }
                                break;
                        case 0x30:
                                if ((rtEntry->ip_start<=ip_s)&&
                                        (rtEntry->ip_end>=ip_s))
                                {
                                        if ((rtEntry->ip_start==0)&&(rtEntry->ip_end==0xffffffff))
                                        {
                                                        rtTemp=rtEntry;
                                                        continue;
                                        }
                                        goto match;
                                }
                                break;

                        case 0x20:
                        case 0x40:
                                if ((rtEntry->trigger.dport.start<=ip_dp)&&
                                        (rtEntry->trigger.dport.end>=ip_dp)&&
                                        (rtEntry->type==type))
                                        goto match;
                                break;

                }
        }
        if (rtTemp) {rtEntry=rtTemp;goto match;}
        return 0;
match:
        identity=rtEntry->identity;
        if (rtEntry->p_handler){
                rtEntry->p_handler(identity);
                rtEntry=&rtDemandRouteTable[0];
                for(rtIdx=0; rtIdx<32; rtIdx++,rtEntry++)
                        if (rtEntry->identity==identity)
                                rtEntry->p_handler=0;
        }
        return 1;

}







int32 rtl8651_flushDemandRoute(int identity)
{
        int rtIdx,rtNewIdx;
        rtl8651_tblDrvDemandRoute_t *rtEntry;

        rtlglue_drvMutexLock();
        rtEntry=&rtDemandRouteTable[0];
        for(rtIdx=0; rtIdx<32; rtIdx++,rtEntry++)
        {
                if (rtEntry->identity==identity && rtEntry->type)
                {
                        memset(rtEntry,0,sizeof(*rtEntry));
                }
        }

        for(rtIdx=0; rtIdx<32; rtIdx++)
        {
                if (rtDemandRouteTable[rtIdx].type==0)
                {
                        for(rtNewIdx=rtIdx+1; rtNewIdx<32; rtNewIdx++)
                                if (rtDemandRouteTable[rtNewIdx].type!=0)
                                {
                                        rtDemandRouteTable[rtIdx]=rtDemandRouteTable[rtNewIdx];
                                        rtDemandRouteTable[rtNewIdx].type=0;
                                        break;
                                }
                }
        }
        ;


        rtlglue_drvMutexUnlock();
        return 0;
}
# 8076 "rtl8651_tblDrv.c"
int32 rtl8651_addDemandRoute(rtl8651_tblDrvDemandRoute_t * rtAdd, int identity,int32(*p_callBack)(uint32))
{
        int rtIdx,retVal=0;
        rtl8651_tblDrvDemandRoute_t *rtEntry;
        ;

        rtlglue_drvMutexLock();
        rtEntry=&rtDemandRouteTable[0];
        for(rtIdx=0; rtIdx<32; rtIdx++, rtEntry++)
        {
                if (!rtEntry->type)break;
                if (rtEntry->type != (rtAdd->type&(~0x0f)))
                        continue;
                switch(rtEntry->type)
                {
                        case 0x10:
                        case 0x30:
                        case 0x50:
                                if (rtEntry->ip_start==rtAdd->ip_start && rtEntry->ip_end==rtAdd->ip_end)
                                {
                                        retVal=1;
                                        goto fail;
                                }
                                break;
                        case 0x20:
                        case 0x40:
                                if (rtEntry->trigger.ip_d==rtAdd->trigger.ip_d)
                {
                                        retVal=1;
                                        goto fail;
                                }
                                break;
                }

        }

        rtEntry=&rtDemandRouteTable[0];
        for(rtIdx=0; rtIdx<32; rtIdx++, rtEntry++)
                if (rtEntry->type == 0)
                        break;
        if (rtIdx==32)
        {
                retVal=2;
                goto fail;
        }
        rtEntry->type=(rtAdd->type&(~0x0f));
        rtEntry->trigger.ip_d=rtAdd->trigger.ip_d;
        rtEntry->ip_start=rtAdd->ip_start;
        rtEntry->ip_end=rtAdd->ip_end;
        rtEntry->identity=identity;
        rtEntry->p_handler = p_callBack;

        ;


        ;


        ;



        ;



        ;


        ;



fail:
        rtlglue_drvMutexUnlock();
        return retVal;


}
# 8173 "rtl8651_tblDrv.c"
static uint32 _rtl8651_hashValue(uint32 dip)
{
        uint32 result=0;



        return result;
}



static int32 _rtl8651_delPolicy(rtl8651_tblDrvPolicy_t *spolicy_t, rtl8651_tblDrvPolicy_t *dpolicy_t)
{
        _rtl8651_tblDrvPolicy_t *delPolicy_t;

        do {} while (0);

        for (delPolicy_t = ((&DrvTbl.inuseList.policyRoute)->tqh_first); delPolicy_t; delPolicy_t = ((delPolicy_t)->nextPolicy_t.tqe_next)) {
                if ((spolicy_t && !delPolicy_t->p_handler && !memcmp(delPolicy_t, spolicy_t, sizeof( rtl8651_tblDrvPolicy_t))) ||
                    (dpolicy_t && delPolicy_t->p_handler && !memcmp(delPolicy_t, dpolicy_t, sizeof(rtl8651_tblDrvPolicy_t))) )
                {
                        do { if (((delPolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (delPolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (delPolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.inuseList.policyRoute)->tqh_last = (delPolicy_t)->nextPolicy_t.tqe_prev; *(delPolicy_t)->nextPolicy_t.tqe_prev = (delPolicy_t)->nextPolicy_t.tqe_next; } while (0);
                        do { if (((delPolicy_t)->nextPolicy_t.tqe_next = (&DrvTbl.freeList.freePolicy)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freePolicy)->tqh_first->nextPolicy_t.tqe_prev = &(delPolicy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.freeList.freePolicy)->tqh_last = &(delPolicy_t)->nextPolicy_t.tqe_next; (&DrvTbl.freeList.freePolicy)->tqh_first = (delPolicy_t); (delPolicy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
                        return 0;
                }
        }
        return -3;
}


static int32 _rtl8651_flushPolicy(ipaddr_t naptip, uint32 sessionId)
{
        _rtl8651_tblDrvPolicy_t *dpolicy_t, *temp_t;
        uint32 hash;

        do {} while (0);


        dpolicy_t = ((&DrvTbl.inuseList.policyRoute)->tqh_first);
        while (dpolicy_t) {
                if ((!naptip && dpolicy_t->pppoe_t->sessionId == sessionId && dpolicy_t->p_handler) ||
                    (naptip && !dpolicy_t->p_handler && dpolicy_t->naptip == naptip) )
                {
                        do { if (((dpolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (dpolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (dpolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.inuseList.policyRoute)->tqh_last = (dpolicy_t)->nextPolicy_t.tqe_prev; *(dpolicy_t)->nextPolicy_t.tqe_prev = (dpolicy_t)->nextPolicy_t.tqe_next; } while (0);
                        do { if (((dpolicy_t)->nextPolicy_t.tqe_next = (&DrvTbl.freeList.freePolicy)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freePolicy)->tqh_first->nextPolicy_t.tqe_prev = &(dpolicy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.freeList.freePolicy)->tqh_last = &(dpolicy_t)->nextPolicy_t.tqe_next; (&DrvTbl.freeList.freePolicy)->tqh_first = (dpolicy_t); (dpolicy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
                        dpolicy_t = ((&DrvTbl.inuseList.policyRoute)->tqh_first);
                        continue;
                }
                dpolicy_t = ((dpolicy_t)->nextPolicy_t.tqe_next);
        }

        if (naptip) {

                dpolicy_t = ((&DrvTbl.dynamicPolicy.dyHead)->cqh_first);
                while (dpolicy_t) {
                        if (dpolicy_t == (void *)&DrvTbl.dynamicPolicy.dyHead)
                                break;
                        if (dpolicy_t->naptip == naptip) {
                                temp_t = ((dpolicy_t)->nextTime_t.cqe_next);
                                hash = _rtl8651_hashValue(dpolicy_t->dip);
                                do { if (((dpolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (dpolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (dpolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.dynamicPolicy.hashTable[hash])->tqh_last = (dpolicy_t)->nextPolicy_t.tqe_prev; *(dpolicy_t)->nextPolicy_t.tqe_prev = (dpolicy_t)->nextPolicy_t.tqe_next; } while (0);
                                do { if ((dpolicy_t)->nextTime_t.cqe_next == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (dpolicy_t)->nextTime_t.cqe_prev; else (dpolicy_t)->nextTime_t.cqe_next->nextTime_t.cqe_prev = (dpolicy_t)->nextTime_t.cqe_prev; if ((dpolicy_t)->nextTime_t.cqe_prev == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (dpolicy_t)->nextTime_t.cqe_next; else (dpolicy_t)->nextTime_t.cqe_prev->nextTime_t.cqe_next = (dpolicy_t)->nextTime_t.cqe_next; } while (0);
                                do { (dpolicy_t)->nextTime_t.cqe_next = (&DrvTbl.dynamicPolicy.dyHead)->cqh_first; (dpolicy_t)->nextTime_t.cqe_prev = (void *)(&DrvTbl.dynamicPolicy.dyHead); if ((&DrvTbl.dynamicPolicy.dyHead)->cqh_last == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (dpolicy_t); else (&DrvTbl.dynamicPolicy.dyHead)->cqh_first->nextTime_t.cqe_prev = (dpolicy_t); (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (dpolicy_t); } while (0);
                                bzero(dpolicy_t, (sizeof(_rtl8651_tblDrvPolicy_t)-sizeof(dpolicy_t->nextPolicy_t)-sizeof(dpolicy_t->nextTime_t)));
                                dpolicy_t = temp_t;
                                continue;
                        }
                        dpolicy_t = ((dpolicy_t)->nextTime_t.cqe_next);
                }
        }
        return 0;
}



_rtl8651_tblDrvPolicy_t *
_rtl8651_getPolicyRoute(int8 proto, ipaddr_t sip, uint16 sport, ipaddr_t dip, ipaddr_t dport)
{
        struct protoType { struct _rtl8651_tblDrvPolicy_s *tqh_first; struct _rtl8651_tblDrvPolicy_s **tqh_last; } *policyHead_t[2];
        _rtl8651_tblDrvPolicy_t *policy_t;
        uint32 hash;

        hash = _rtl8651_hashValue(dip);

        policyHead_t[0] = (struct protoType *)&DrvTbl.inuseList.policyRoute;
        policyHead_t[1] = (struct protoType *)&DrvTbl.dynamicPolicy.hashTable[hash];

        for(hash=0; hash<2; hash++) {
                for (policy_t = ((policyHead_t[hash])->tqh_first); policy_t; policy_t = ((policy_t)->nextPolicy_t.tqe_next)) {
                        switch (policy_t->proto)
                        {
                        case 0x02:
                                if (proto != 6)
                                        continue;
                                goto comm_L4;

                        case 0x03:
                                if (proto != 17)
                                        continue;
comm_L4:
                                if (!(dport <= policy_t->dport_end && dport >= policy_t->dport_start &&
                                      sport <= policy_t->sport_end && sport >= policy_t->sport_start))
                                        continue;


                        case 0x01:
                                if (((sip&policy_t->sipMask)==policy_t->sip) && ((dip&policy_t->dipMask)==policy_t->dip)) {
                                        if (hash != 0) {

                                                do { if ((policy_t)->nextTime_t.cqe_next == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (policy_t)->nextTime_t.cqe_prev; else (policy_t)->nextTime_t.cqe_next->nextTime_t.cqe_prev = (policy_t)->nextTime_t.cqe_prev; if ((policy_t)->nextTime_t.cqe_prev == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (policy_t)->nextTime_t.cqe_next; else (policy_t)->nextTime_t.cqe_prev->nextTime_t.cqe_next = (policy_t)->nextTime_t.cqe_next; } while (0);
                                                do { (policy_t)->nextTime_t.cqe_next = (void *)(&DrvTbl.dynamicPolicy.dyHead); (policy_t)->nextTime_t.cqe_prev = (&DrvTbl.dynamicPolicy.dyHead)->cqh_last; if ((&DrvTbl.dynamicPolicy.dyHead)->cqh_first == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (policy_t); else (&DrvTbl.dynamicPolicy.dyHead)->cqh_last->nextTime_t.cqe_next = (policy_t); (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (policy_t); } while (0);
                                        }
                                        return policy_t;
                                }
                                break;

                        default: break;
                        }
                }
        }
        return ((void *)0);
}



int32 rtl8651_flushPolicyRoute_1(ipaddr_t naptip)
{
        int32 retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_flushPolicy(naptip, 0);
        rtlglue_drvMutexUnlock();
        return 0;
}



int32 rtl8651_delPolicyRoute(int8 type, rtl8651_tblDrvPolicy_t *policy_t)
{
        _rtl8651_tblDrvPolicy_t *delPolicy_t;
        uint32 hash;
        int32 retval=0;

        if (policy_t == ((void *)0))
                return -6;
        rtlglue_drvMutexLock();
        switch (type)
        {
        case 0x02:
                for((delPolicy_t) = (&DrvTbl.dynamicPolicy.dyHead)->cqh_first; (delPolicy_t) != (void *)(&DrvTbl.dynamicPolicy.dyHead); (delPolicy_t) = (delPolicy_t)->nextTime_t.cqe_next) {
                        if (!memcmp(delPolicy_t, policy_t, sizeof(rtl8651_tblDrvPolicy_t))) {
                                hash = _rtl8651_hashValue(delPolicy_t->dip);
                                do { if (((delPolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (delPolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (delPolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.dynamicPolicy.hashTable[hash])->tqh_last = (delPolicy_t)->nextPolicy_t.tqe_prev; *(delPolicy_t)->nextPolicy_t.tqe_prev = (delPolicy_t)->nextPolicy_t.tqe_next; } while (0);
                                do { if ((delPolicy_t)->nextTime_t.cqe_next == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (delPolicy_t)->nextTime_t.cqe_prev; else (delPolicy_t)->nextTime_t.cqe_next->nextTime_t.cqe_prev = (delPolicy_t)->nextTime_t.cqe_prev; if ((delPolicy_t)->nextTime_t.cqe_prev == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (delPolicy_t)->nextTime_t.cqe_next; else (delPolicy_t)->nextTime_t.cqe_prev->nextTime_t.cqe_next = (delPolicy_t)->nextTime_t.cqe_next; } while (0);
                                do { (delPolicy_t)->nextTime_t.cqe_next = (&DrvTbl.dynamicPolicy.dyHead)->cqh_first; (delPolicy_t)->nextTime_t.cqe_prev = (void *)(&DrvTbl.dynamicPolicy.dyHead); if ((&DrvTbl.dynamicPolicy.dyHead)->cqh_last == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (delPolicy_t); else (&DrvTbl.dynamicPolicy.dyHead)->cqh_first->nextTime_t.cqe_prev = (delPolicy_t); (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (delPolicy_t); } while (0);
                                bzero(delPolicy_t, sizeof(_rtl8651_tblDrvPolicy_t)-sizeof(delPolicy_t->nextTime_t)-sizeof(delPolicy_t->nextPolicy_t));
                                goto out;
                        }
                }
                break;

        case 0x04:
                retval = _rtl8651_delPolicy(policy_t, ((void *)0));
                break;

        default: retval = -6;
        }
out:
        rtlglue_drvMutexUnlock();
        return retval;
}



int32 rtl8651_addPolicyRoute_1(int8 type, rtl8651_tblDrvPolicy_t *policy_t)
{
        rtl8651_tblDrv_pppTable_t *pppoe_t;
        _rtl8651_tblDrvPolicy_t *spolicy_t;
        uint32 hash1, hash2;
        int32 retval = 0;

        if (policy_t == ((void *)0) || !(policy_t->proto == 0x01 || policy_t->proto==0x02))
                return -6;
        rtlglue_drvMutexLock();

        switch(type)
        {
        case 0x02:
                if ((pppoe_t=_rtl8651_getPPPInfo(0, policy_t->naptip)) == ((void *)0)) {
                        retval = -6;
                        goto out;
                }
                hash1 = _rtl8651_hashValue(policy_t->dip);
                spolicy_t = ((&DrvTbl.dynamicPolicy.dyHead)->cqh_first);
                if (spolicy_t->pppoe_t) {
                        hash2 = _rtl8651_hashValue(spolicy_t->dip);
                        do { if (((spolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (spolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (spolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.dynamicPolicy.hashTable[hash2])->tqh_last = (spolicy_t)->nextPolicy_t.tqe_prev; *(spolicy_t)->nextPolicy_t.tqe_prev = (spolicy_t)->nextPolicy_t.tqe_next; } while (0);
                }
                bzero(spolicy_t, sizeof(_rtl8651_tblDrvPolicy_t)-sizeof(spolicy_t->nextPolicy_t)-sizeof(spolicy_t->nextTime_t));
                rtl8651_memcpy(spolicy_t, policy_t, sizeof(rtl8651_tblDrvPolicy_t));
                do { if (((spolicy_t)->nextPolicy_t.tqe_next = (&DrvTbl.dynamicPolicy.hashTable[hash1])->tqh_first) != ((void *)0)) (&DrvTbl.dynamicPolicy.hashTable[hash1])->tqh_first->nextPolicy_t.tqe_prev = &(spolicy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.dynamicPolicy.hashTable[hash1])->tqh_last = &(spolicy_t)->nextPolicy_t.tqe_next; (&DrvTbl.dynamicPolicy.hashTable[hash1])->tqh_first = (spolicy_t); (spolicy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.dynamicPolicy.hashTable[hash1])->tqh_first; } while (0);
                do { if ((spolicy_t)->nextTime_t.cqe_next == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (spolicy_t)->nextTime_t.cqe_prev; else (spolicy_t)->nextTime_t.cqe_next->nextTime_t.cqe_prev = (spolicy_t)->nextTime_t.cqe_prev; if ((spolicy_t)->nextTime_t.cqe_prev == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (spolicy_t)->nextTime_t.cqe_next; else (spolicy_t)->nextTime_t.cqe_prev->nextTime_t.cqe_next = (spolicy_t)->nextTime_t.cqe_next; } while (0);
                do { (spolicy_t)->nextTime_t.cqe_next = (void *)(&DrvTbl.dynamicPolicy.dyHead); (spolicy_t)->nextTime_t.cqe_prev = (&DrvTbl.dynamicPolicy.dyHead)->cqh_last; if ((&DrvTbl.dynamicPolicy.dyHead)->cqh_first == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (spolicy_t); else (&DrvTbl.dynamicPolicy.dyHead)->cqh_last->nextTime_t.cqe_next = (spolicy_t); (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (spolicy_t); } while (0);
                spolicy_t->pppoe_t = pppoe_t;
                break;

        case 0x04:
                if ((spolicy_t=((&DrvTbl.freeList.freePolicy)->tqh_first)) == ((void *)0)) {
                        retval = -9;
                        goto out;
                }
                bzero(spolicy_t, sizeof(_rtl8651_tblDrvPolicy_t)-sizeof(spolicy_t->nextPolicy_t));
                rtl8651_memcpy(spolicy_t, policy_t, sizeof(rtl8651_tblDrvPolicy_t));
                if ((spolicy_t->pppoe_t = _rtl8651_getPPPInfo(0, policy_t->naptip)) == ((void *)0)) {
                        retval = -6;
                        goto out;
                }
                if (_rtl8651_addNextHopEntry(0x06, spolicy_t, spolicy_t->pppoe_t->netif_t, 0, 0, spolicy_t->pppoe_t) == -1) {
                        retval = -6;
                        goto out;
                }
                do { if (((spolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (spolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (spolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.freeList.freePolicy)->tqh_last = (spolicy_t)->nextPolicy_t.tqe_prev; *(spolicy_t)->nextPolicy_t.tqe_prev = (spolicy_t)->nextPolicy_t.tqe_next; } while (0);
                do { if (((spolicy_t)->nextPolicy_t.tqe_next = (&DrvTbl.inuseList.policyRoute)->tqh_first) != ((void *)0)) (&DrvTbl.inuseList.policyRoute)->tqh_first->nextPolicy_t.tqe_prev = &(spolicy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.inuseList.policyRoute)->tqh_last = &(spolicy_t)->nextPolicy_t.tqe_next; (&DrvTbl.inuseList.policyRoute)->tqh_first = (spolicy_t); (spolicy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.inuseList.policyRoute)->tqh_first; } while (0);
                break;

        default: retval = -6;

        }

        _rtl8651_arrangeAllACL();
out:
        rtlglue_drvMutexUnlock();
        return retval;
}


int32 rtl8651_flushDemandRoute_1(uint32 sessionId)
{
        int32 retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_flushPolicy(0, sessionId);
        rtlglue_drvMutexUnlock();
        return retval;
}



int32 rtl8651_delDemandRoute(rtl8651_tblDrvPolicy_t *policy_t)
{
        int32 retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_delPolicy(((void *)0), policy_t);
        rtlglue_drvMutexUnlock();
        return retval;
}


int32 rtl8651_addDemandRoute_1(rtl8651_tblDrvPolicy_t *policy_t, uint32 sessionId, int32(*p_callBack)(uint32))
{
        rtl8651_tblDrv_pppTable_t *pppoe_t;
        _rtl8651_tblDrvPolicy_t *dpolicy_t;
        int32 retval = 0;


        if (sessionId == 0 || !p_callBack ||!policy_t)
                return -6;
        rtlglue_drvMutexLock();


        for (dpolicy_t = ((&DrvTbl.inuseList.policyRoute)->tqh_first); dpolicy_t; dpolicy_t = ((dpolicy_t)->nextPolicy_t.tqe_next)) {
                if (!memcmp(dpolicy_t, policy_t, (sizeof(rtl8651_tblDrvPolicy_t)-sizeof(ipaddr_t)))) {
                        retval = -2;
                        goto out;
                }
        }
        if ((pppoe_t =_rtl8651_getPppoeBySessionId(sessionId)) == ((void *)0)) {
                retval = -2807;
                goto out;
        }
        if ((dpolicy_t=((&DrvTbl.freeList.freePolicy)->tqh_first)) == ((void *)0)) {
                retval = -9;
                goto out;
        }
        do { if (((dpolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (dpolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (dpolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.freeList.freePolicy)->tqh_last = (dpolicy_t)->nextPolicy_t.tqe_prev; *(dpolicy_t)->nextPolicy_t.tqe_prev = (dpolicy_t)->nextPolicy_t.tqe_next; } while (0);
        bzero(dpolicy_t, sizeof(_rtl8651_tblDrvPolicy_t)-sizeof(dpolicy_t->nextPolicy_t));
        rtl8651_memcpy(dpolicy_t, policy_t, sizeof(rtl8651_tblDrvPolicy_t)-sizeof(ipaddr_t));
        do { if (((dpolicy_t)->nextPolicy_t.tqe_next = (&DrvTbl.inuseList.policyRoute)->tqh_first) != ((void *)0)) (&DrvTbl.inuseList.policyRoute)->tqh_first->nextPolicy_t.tqe_prev = &(dpolicy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.inuseList.policyRoute)->tqh_last = &(dpolicy_t)->nextPolicy_t.tqe_next; (&DrvTbl.inuseList.policyRoute)->tqh_first = (dpolicy_t); (dpolicy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.inuseList.policyRoute)->tqh_first; } while (0);
        dpolicy_t->p_handler = p_callBack;
        dpolicy_t->pppoe_t = pppoe_t;

out:
        rtlglue_drvMutexUnlock();
        return retval;
}



static uint32 _rtl8651_addPolicyRouteToAcl(uint32 aclStart, uint32 aclEnd, int8 *enoughFlag)
{
        _rtl8651_tblDrvPolicy_t *policy_t;
        _rtl8651_tblDrvAclRule_t rule;
        uint32 count = 0;

        do {} while (0);
        if (aclStart > aclEnd) return 0;

        for (policy_t = ((&DrvTbl.inuseList.policyRoute)->tqh_first); policy_t; policy_t = ((policy_t)->nextPolicy_t.tqe_next)) {
                do {} while (0);
                if (aclStart > aclEnd) {
                        *enoughFlag = 0;
                        return count;
                }

                bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.un_ty.L3L4._srcIpAddr = policy_t->sip;
                rule.un_ty.L3L4._srcIpAddrMask = policy_t->sipMask;
                rule.un_ty.L3L4._dstIpAddr = policy_t->dip;
                rule.un_ty.L3L4._dstIpAddrMask = policy_t->dipMask;
                switch( policy_t->proto )
                {
                case 0x01:
                         rule.ruleType_ = 0x01;
                         break;
                case 0x02:
                         rule.ruleType_ = 0x04;
                         rule.un_ty.L3L4.is.tcp._srcPortUpperBound = policy_t->sport_end;
                         rule.un_ty.L3L4.is.tcp._srcPortLowerBound = policy_t->sport_start;
                         rule.un_ty.L3L4.is.tcp._dstPortUpperBound = policy_t->dport_end;
                         rule.un_ty.L3L4.is.tcp._dstPortLowerBound = policy_t->dport_start;
                         break;
                case 0x03:
                         rule.ruleType_ = 0x05;
                         rule.un_ty.L3L4.is.udp._srcPortUpperBound = policy_t->sport_end;
                         rule.un_ty.L3L4.is.udp._srcPortLowerBound = policy_t->sport_start;
                         rule.un_ty.L3L4.is.udp._dstPortUpperBound = policy_t->dport_end;
                         rule.un_ty.L3L4.is.udp._dstPortLowerBound = policy_t->dport_start;
                         break;
                default: do {} while (0);
                }

                rule.actionType_ = 0x0e;
                rule.nhIndex = policy_t->nexthop_t->entryIndex;
                rtl8651_setAsicAclRule(aclStart, &rule);
                aclStart ++; count ++;
        }
        return count;
}







static uint32
_rtl8651_addAclForLanSideIpUnnumbered(int8 isAdd, rtl8651_tblDrv_networkIntfTable_t *netif_t, uint32 aclStart, uint32 aclEnd) {
        _rtl8651_tblDrvAclRule_t aclRule;

        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        ipaddr_t sip, sipm, dip ,dipm, globalIp;
        uint32 count = 0;
        int32 ret;

        if (!lanSideIpUnnumberedLan || !lanSideIpUnnumberedWan)
                return 0;
        do {} while (0);


        {
                _rtl8651_tblDrvAclRule_t rule;



                if (isAdd == 1) {
                        if (aclStart > aclEnd)
                                return count;
                        memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                        rule.ruleType_ = 0x04;
                        rule.actionType_ = 0x03;
                        rule.un_ty.L3L4.is.tcp.un.s._syn = 0x01;
                        rule.un_ty.L3L4.is.tcp._flagMask = rule.un_ty.L3L4.is.tcp.un._flag;
                        rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                        rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                        rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                        rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                        rtl8651_setAsicAclRule(aclStart, &rule);
                        aclStart++;
                }
                count=1;
        }
# 8592 "rtl8651_tblDrv.c"
        for((ipintf_t) = (&lanSideIpUnnumberedLan->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
        {
                uint32 subnetIpToBeAddedInAclTotalCount;
                uint32 subnetIpToBeAddedInAclToEachInterface;
                uint32 subnetGlobalIpCount;
                uint8 patchWithACL;
                rtl8651_tblDrv_ipUnnumbered_t *ipUnnumber_t;
                ipaddr_t ipToBeAdded,aclStartIp;
                ipaddr_t mySubnet;
                uint32 i;
                if (ipintf_t->lanSideExternal == 0)
                {
                        continue;
                }

                do {} while (0);
                ipUnnumber_t = ipintf_t->ipUnnumber;

                globalIp = ipintf_t->ipAddr.slh_first->ipAddr;
                mySubnet = globalIp&ipintf_t->ipMask;

                subnetGlobalIpCount=0xffffffff & (uint32)(~((uint32)ipintf_t->ipMask));




                subnetIpToBeAddedInAclToEachInterface = (subnetGlobalIpCount - (ipUnnumber_t->ip_as_LS + 1 ));
                subnetIpToBeAddedInAclTotalCount = (subnetIpToBeAddedInAclToEachInterface << 1 );

                if (subnetIpToBeAddedInAclToEachInterface == 0)
                        continue;
# 8649 "rtl8651_tblDrv.c"
                patchWithACL = 1;

                if (ipUnnumber_t->ip_as_ACL_budget > 0)
                {






                        if (ipUnnumber_t->ip_as_ACL_budget < subnetIpToBeAddedInAclToEachInterface)
                        {
                                if ((rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_ACL_budget + ipUnnumber_t->ip_as_ACL_budget) >= subnetIpToBeAddedInAclToEachInterface)
                                {


                                        uint32 addedBudget = subnetIpToBeAddedInAclToEachInterface - ipUnnumber_t->ip_as_ACL_budget;
                                        ipUnnumber_t->ip_as_ACL_budget += addedBudget;
                                        rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_ACL_budget -= addedBudget;
                                }else
                                {


                                        patchWithACL = 0;
                                }
                        }
                        if (ipUnnumber_t->ip_as_ACL_budget >= (aclEnd - aclStart))
                        {
                                patchWithACL = 0;
                        }


                        if (patchWithACL == 0)
                        {
                                rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_ACL_budget += ipUnnumber_t->ip_as_ACL_budget;
                                ipUnnumber_t->ip_as_ACL_budget = 0;
                        }
                } else
                {
# 8697 "rtl8651_tblDrv.c"
                        if (subnetIpToBeAddedInAclTotalCount > rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_ACL_budget)
                        {
                                patchWithACL = 0;
                        }

                        if (subnetIpToBeAddedInAclTotalCount >= (aclEnd - aclStart) )
                        {
                                patchWithACL = 0;
                        }




                        if (patchWithACL == 1)
                        {
                                ipUnnumber_t->ip_as_ACL_budget += subnetIpToBeAddedInAclTotalCount;
                                rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_ACL_budget -= subnetIpToBeAddedInAclTotalCount;
                        }
                }

                if (patchWithACL == 0)
                {
                        if (isAdd == 1)
                        {
                                int32 idx;
                                rtl8651_tblDrv_routeTable_t *rt_t = &DrvTbl.route[0];


                                for ( idx=0 ; idx<rtl8651_tblDrvPara.routingTableSize ; idx++ )
                                {
                                        if (rt_t[idx].valid == 0)
                                                continue;
                                        if (rt_t[idx].netif_t == lanSideIpUnnumberedLan)
                                        {
                                                if (rt_t[idx].ipintf_t == ipintf_t)
                                                {
                                                        do {} while (0);

                                                        if (rt_t[idx].process != 0x04)
                                                        {
                                                                _rtl8651_delInterfaceRoute(globalIp, ipintf_t->ipMask);
                                                                _rtl8651_addInterfaceRoute(lanSideIpUnnumberedLan, ipintf_t, 0xffffffff, 0xffffffff);
                                                        }
                                                        break;
                                                }
                                        }
                                }
                                do {} while (0);
                        }


                        return count;

                } else
                {

                        if (isAdd == 1)
                        {
                                int32 idx;
                                rtl8651_tblDrv_routeTable_t *rt_t = &DrvTbl.route[0];


                                for ( idx=0 ; idx<rtl8651_tblDrvPara.routingTableSize ; idx++ )
                                {
                                        if (rt_t[idx].valid == 0)
                                                continue;
                                        if (rt_t[idx].netif_t == lanSideIpUnnumberedLan)
                                        {
                                                if (rt_t[idx].ipintf_t == ipintf_t)
                                                {

                                                        if (rt_t[idx].process==0x04 && ipintf_t->arpStartPos!=0xffffffff)
                                                        {
                                                                _rtl8651_delInterfaceRoute(globalIp, ipintf_t->ipMask);
                                                                _rtl8651_addInterfaceRoute(lanSideIpUnnumberedLan, ipintf_t, ipintf_t->arpStartPos, ipintf_t->arpEndPos);
                                                        }
                                                        break;
                                                }
                                        }
                                }
                                do {} while (0);
                        }
                }
# 8797 "rtl8651_tblDrv.c"
                do {} while (0);


                if (globalIp<=(mySubnet+ipUnnumber_t->ip_as_LS+1))
                        aclStartIp = (ipaddr_t)((uint32)mySubnet+ipUnnumber_t->ip_as_LS+2);
                else
                        aclStartIp = (ipaddr_t)((uint32)mySubnet+ipUnnumber_t->ip_as_LS+1);

                for (i=1;i<subnetGlobalIpCount;i++){
                        ipToBeAdded=(ipaddr_t)((uint32)mySubnet+i);
                        if ((uint32)ipToBeAdded==(uint32)globalIp)
                                continue;
                        if (ipToBeAdded<aclStartIp)
                                continue;

                        if (netif_t == lanSideIpUnnumberedLan){

                                sip = ipToBeAdded; sipm = 0xffffffff;
                                dip = 0x00; dipm = 0x00;
                                if (isAdd == 1){
                                        do {} while (0);

                                        if (aclStart > aclEnd)
                                                return count;
                                        ipUnnumber_t->ip_as_ACL_budget--;
                                        memset(&aclRule, 0, sizeof(aclRule));
                                        { (&aclRule)->un_ty.L3L4._srcIpAddr = sip; (&aclRule)->un_ty.L3L4._srcIpAddrMask = sipm; (&aclRule)->un_ty.L3L4._dstIpAddr = dip; (&aclRule)->un_ty.L3L4._dstIpAddrMask = dipm; (&aclRule)->un_ty.L3L4._tos = 0; (&aclRule)->un_ty.L3L4._tosMask = 0; (&aclRule)->un_ty.L3L4.is.ip._proto = 0; (&aclRule)->un_ty.L3L4.is.ip._protoMask = 0; (&aclRule)->un_ty.L3L4.is.ip.un._flag = 0; (&aclRule)->un_ty.L3L4.is.ip._flagMask = 0; (&aclRule)->ruleType_ = 0x01; (&aclRule)->actionType_ = 0x03;};
                                        ret = rtl8651_setAsicAclRule(aclStart, &aclRule);
                                        do {} while (0);
                                        aclStart++;
                                }
                                count ++;
                        }else{

                                sip = 0x00; sipm = 0x00;
                                dip = ipToBeAdded; dipm = 0xffffffff;
                                if (isAdd == 1){
                                        do {} while (0);
                                        if (aclStart > aclEnd)
                                                return count;
                                        ipUnnumber_t->ip_as_ACL_budget --;
                                        memset(&aclRule, 0, sizeof(aclRule));
                                        { (&aclRule)->un_ty.L3L4._srcIpAddr = sip; (&aclRule)->un_ty.L3L4._srcIpAddrMask = sipm; (&aclRule)->un_ty.L3L4._dstIpAddr = dip; (&aclRule)->un_ty.L3L4._dstIpAddrMask = dipm; (&aclRule)->un_ty.L3L4._tos = 0; (&aclRule)->un_ty.L3L4._tosMask = 0; (&aclRule)->un_ty.L3L4.is.ip._proto = 0; (&aclRule)->un_ty.L3L4.is.ip._protoMask = 0; (&aclRule)->un_ty.L3L4.is.ip.un._flag = 0; (&aclRule)->un_ty.L3L4.is.ip._flagMask = 0; (&aclRule)->ruleType_ = 0x01; (&aclRule)->actionType_ = 0x03;};
                                        ret = rtl8651_setAsicAclRule(aclStart, &aclRule);
                                        do {} while (0);
                                        aclStart++;
                                }
                                count ++;
                        }
                }
        }

        return count;
}
# 8920 "rtl8651_tblDrv.c"
 int8 _rtl8651_isLanSideIpUnnumberedIpAddr(ipaddr_t ipAddr) {
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;

        if (!lanSideIpUnnumberedLan)
                return 0;

        for((ipintf_t) = (&lanSideIpUnnumberedLan->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                if (ipintf_t->lanSideExternal == 0)
                        continue;
                if ((ipintf_t->ipMask&ipintf_t->ipAddr.slh_first->ipAddr)==(ipintf_t->ipMask&ipAddr))
                        return 1;
        }
        return 0;
}
# 8950 "rtl8651_tblDrv.c"
int8 _rtl8651_extIpAddr(ipaddr_t ipAddr, uint32 *netIdx) {
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t * ipAddrPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 i;

        netIfPtr = &DrvTbl.netIface[0];
        for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netIfPtr++) {
                if (netIfPtr->valid == 0) continue;
                if (DrvTbl.vlan[(netIfPtr->vid& (8 -1))].internal == 1 &&
                        netIfPtr->linkLayerType != 0x04)
                        continue;
                for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                        do {} while (0);
                        if (netIfPtr->linkLayerType == 0x04 &&
                                ipIntfPtr->lanSideExternal == 0)
                                continue;
                        for((ipAddrPtr) = (&ipIntfPtr->ipAddr)->slh_first; (ipAddrPtr); (ipAddrPtr) = (ipAddrPtr)->nextIpAddr.sle_next)
                                if (ipAddrPtr->ipAddr == ipAddr) {
                                        if (netIdx)
                                                *netIdx = i;
                                        return 1;
                        }
                }
        }
        return 0;
}

int8 _rtl8651_extNetIpAddr(ipaddr_t ipAddr, uint32 *netIdx) {
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 i;

        netIfPtr = &DrvTbl.netIface[0];
        for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++, netIfPtr++) {
                if (netIfPtr->valid == 0) continue;
                if (DrvTbl.vlan[(netIfPtr->vid& (8 -1))].internal == 1 &&
                        netIfPtr->linkLayerType != 0x04)
                        continue;
                for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                        if (netIfPtr->linkLayerType == 0x04 &&
                                ipIntfPtr->lanSideExternal == 0)
                                continue;
                        if ((ipAddr&ipIntfPtr->ipMask) == (ipIntfPtr->ipAddr.slh_first->ipAddr&ipIntfPtr->ipMask)) {
                                if (netIdx) *netIdx = i;
                                                return 1;
                        }
                }
        }
        return 0;
}





int8 _rtl8651_getVIDByGWIpAddr(ipaddr_t gwIpAddr, uint32 *vid) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ipPtr;
        uint32 netIdx;

        netIfPtr = &DrvTbl.netIface[0];
        for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++,netIfPtr++) {
                if (netIfPtr->valid == 0) continue;
                for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next)
                        for((ipPtr) = (&ipIntfPtr->ipAddr)->slh_first; (ipPtr); (ipPtr) = (ipPtr)->nextIpAddr.sle_next)
                                if (ipPtr->ipAddr == gwIpAddr) {
                                        *vid = netIfPtr->vid;
                                        return 0;
                                }
        }
        return -1;
}


int8 _rtl8651_intIpAddr(ipaddr_t ipAddr) {
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t * ipAddrPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 netIdx;

        netIfPtr = &DrvTbl.netIface[0];
        for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netIfPtr++) {
                if (netIfPtr->valid == 0) continue;
                if (DrvTbl.vlan[(netIfPtr->vid& (8 -1))].internal == 1)
                        for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                                do {} while (0);
                                if (ipIntfPtr->lanSideExternal == 1)
                                        continue;
                                for((ipAddrPtr) = (&ipIntfPtr->ipAddr)->slh_first; (ipAddrPtr); (ipAddrPtr) = (ipAddrPtr)->nextIpAddr.sle_next)
                                        if (ipAddr == ipAddrPtr->ipAddr)
                                                return 1;
                        }
        }
        return 0;
}

int8 _rtl8651_intNetIpAddr(ipaddr_t ipAddr) {
        rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 netIdx;

        netIfPtr = &DrvTbl.netIface[0];
        for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netIfPtr++) {
                if (netIfPtr->valid == 0) continue;
                if (DrvTbl.vlan[(netIfPtr->vid& (8 -1))].internal == 1)
                        for((ipIntfPtr) = (&(netIfPtr->IpHead))->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next) {
                                do {} while (0);
                                if (ipIntfPtr->lanSideExternal == 1)
                                        continue;
                                if ((ipAddr&ipIntfPtr->ipMask) == (ipIntfPtr->ipAddr.slh_first->ipAddr&ipIntfPtr->ipMask))
                                        return 1;
                        }
        }
        return 0;
}
# 9078 "rtl8651_tblDrv.c"
static int8 _rtl8651_isNatMapping(ipaddr_t *extip, ipaddr_t *intip) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_natEntry_t *nat_t;
        uint32 netIdx;

        do {} while (0);
        netif_t = &DrvTbl.netIface[0];
        for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                for((nat_t) = (&netif_t->nextNat)->slh_first; (nat_t); (nat_t) = (nat_t)->nextNatEntry.sle_next) {
                        if (extip && *extip != 0 && *extip != nat_t->globalIp)
                        continue;
                        if (intip && *intip != 0 && *intip != nat_t->localIp)
                        continue;
                        if (extip) *extip = nat_t->globalIp;
                        if (intip) *intip = nat_t->localIp;
                        return 1;
               }
        }
        return 0;
}
# 9132 "rtl8651_tblDrv.c"
rtl8651_tblDrv_natEntry_t *
_rtl8651_getNatInternalMappingEntry(ipaddr_t intIpAddr,struct rtl_pktHdr *phdr) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_natEntry_t * natPtr;
        uint32 netIdx;

        netif_t = &DrvTbl.netIface[0];
        for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netif_t++) {
                if (netif_t->valid == 0 )
                        continue;
                for((natPtr) = (&(netif_t->nextNat))->slh_first; (natPtr); (natPtr) = (natPtr)->nextNatEntry.sle_next) {
                        if (natPtr->localIp == intIpAddr)
                                return natPtr;
                }
                if (netif_t->linkLayerType == 0x04) {
                        for((ipintf_t) = (&netif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next)
                                if ((ipintf_t->lanSideExternal == 1) &&
                                        (ipintf_t->ipAddr.slh_first->ipAddr != intIpAddr) &&
                                        (ipintf_t->ipMask&ipintf_t->ipAddr.slh_first->ipAddr)==(ipintf_t->ipMask&intIpAddr)) {
                                        lanSideNatMapping.globalIp = intIpAddr;
                                        lanSideNatMapping.localIp = intIpAddr;

                                        return &lanSideNatMapping;
                                }
                }
        }
        if ( (phdr->ph_un_sw.ROMEDRV_USG._ph_unnumber & 0x1)
                 && ( ((phdr->ph_un_sw.ROMEDRV_USG._ph_unnumber & 0x2 ) && (phdr->ph_dip==(uint32)intIpAddr))
                      || (((phdr->ph_un_sw.ROMEDRV_USG._ph_unnumber & 0x2)==0) && (phdr->ph_sip==(uint32)intIpAddr))
                    )
                ){

                memset(&unnumNatEntry,0,sizeof(rtl8651_tblDrv_natEntry_t));
                unnumNatEntry.globalIp = intIpAddr;
                unnumNatEntry.localIp = intIpAddr;
                return (rtl8651_tblDrv_natEntry_t *)&unnumNatEntry;
        }else
                return ((void *)0);
}
# 9217 "rtl8651_tblDrv.c"
rtl8651_tblDrv_natEntry_t *
_rtl8651_getNatExternalMappingEntry(ipaddr_t extIpAddr,struct rtl_pktHdr *phdr) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        rtl8651_tblDrv_natEntry_t * natPtr;
        uint32 netIdx;

        netif_t = &DrvTbl.netIface[0];
        for(netIdx=0; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                for((natPtr) = (&(netif_t->nextNat))->slh_first; (natPtr); (natPtr) = (natPtr)->nextNatEntry.sle_next) {
                        if (natPtr->globalIp == extIpAddr)
                                return natPtr;
                }
                if (netif_t->linkLayerType == 0x04) {
                        struct rtl8651_tblDrv_ipIntfIpAddrEntry_s *gwIp;
                        for((ipintf_t) = (&netif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next){
                                if (ipintf_t->lanSideExternal == 1){
                                        for((gwIp) = (&ipintf_t->ipAddr)->slh_first; (gwIp); (gwIp) = (gwIp)->nextIpAddr.sle_next){
                                                if(gwIp->ipAddr==extIpAddr)
                                                        return ((void *)0);
                                        }

                                        if((ipintf_t->ipMask&ipintf_t->ipAddr.slh_first->ipAddr)==(ipintf_t->ipMask&extIpAddr)) {
                                        lanSideNatMapping.globalIp = extIpAddr;
                                        lanSideNatMapping.localIp = extIpAddr;


                                        return &lanSideNatMapping;
                                }
                         }
                   }
             }
        }

        if ( (phdr->ph_un_sw.ROMEDRV_USG._ph_unnumber & 0x1)
                 && ( ((phdr->ph_un_sw.ROMEDRV_USG._ph_unnumber & 0x2 ) && (phdr->ph_dip==(uint32)extIpAddr))
                      ||(((phdr->ph_un_sw.ROMEDRV_USG._ph_unnumber & 0x2)==0) && (phdr->ph_sip==(uint32)extIpAddr))
                    )
                ){

                memset(&unnumNatEntry,0,sizeof(rtl8651_tblDrv_natEntry_t));
                unnumNatEntry.globalIp = extIpAddr;
                unnumNatEntry.localIp = extIpAddr;
                return (rtl8651_tblDrv_natEntry_t *)&unnumNatEntry;
        }else
                return ((void *)0);
}
# 9281 "rtl8651_tblDrv.c"
int32 rtl8651_addNatMapping(ipaddr_t extIpAddr, ipaddr_t intIpAddr) {
        rtl8651_tblDrv_natEntry_t * tempNatMappingPtr;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_natEntry_t *nat1_t, *nat2_t=((void *)0);
        rtl8651_tblDrv_arpEntry_t *arp_t;
        uint32 netIdx;

        rtlglue_drvMutexLock();

        if ((_rtl8651_extIpAddr(extIpAddr, &netIdx) == 0)) { rtlglue_drvMutexUnlock(); return -2100; };

        if ((_rtl8651_intNetIpAddr(intIpAddr) == 0)) { rtlglue_drvMutexUnlock(); return -2101; };
        if ((_rtl8651_isNatMapping(&extIpAddr, ((void *)0)) == 1)) { rtlglue_drvMutexUnlock(); return -2102; };
        if ((_rtl8651_isNaptMapping(extIpAddr) == 1)) { rtlglue_drvMutexUnlock(); return -2103; };
        netif_t = &DrvTbl.netIface[netIdx];
        if ((DrvTbl.freeList.natMapping.slh_first==((void *)0))) { rtlglue_drvMutexUnlock(); return -9; };
        do {} while (0);
        for((tempNatMappingPtr) = (&(netif_t->nextNat))->slh_first; (tempNatMappingPtr); (tempNatMappingPtr) = (tempNatMappingPtr)->nextNatEntry.sle_next) {

                if (( (tempNatMappingPtr->globalIp == extIpAddr) || ( tempNatMappingPtr->localIp == intIpAddr) )) { rtlglue_drvMutexUnlock(); return -2; };




        }

        if ((arp_t=_rtl8651_getArpEntry(((void *)0), intIpAddr, 0)) && _rtl8651_isMacAccessControlPermit(&arp_t->macInfo->macAddr)==0) {

        }
        else {

                if ((_rtl8651_addIpEntry( extIpAddr, intIpAddr, 0x01, ((void *)0)) == ((void *)0))) { rtlglue_drvMutexUnlock(); return -9; };




        }


        tempNatMappingPtr = ((&DrvTbl.freeList.natMapping)->slh_first);
        do { (&DrvTbl.freeList.natMapping)->slh_first = (&DrvTbl.freeList.natMapping)->slh_first->nextNatEntry.sle_next; } while (0);
        tempNatMappingPtr->globalIp = extIpAddr;
        tempNatMappingPtr->localIp = intIpAddr;

        for((nat1_t) = (&netif_t->nextNat)->slh_first; (nat1_t); (nat1_t) = (nat1_t)->nextNatEntry.sle_next)
                if (intIpAddr < nat1_t->localIp)
                        break;
                else nat2_t = nat1_t;
        if (nat2_t == ((void *)0))
                do { (tempNatMappingPtr)->nextNatEntry.sle_next = (&(netif_t->nextNat))->slh_first; (&(netif_t->nextNat))->slh_first = (tempNatMappingPtr); } while (0);
        else do { (tempNatMappingPtr)->nextNatEntry.sle_next = (nat2_t)->nextNatEntry.sle_next; (nat2_t)->nextNatEntry.sle_next = (tempNatMappingPtr); } while (0);
        rtlglue_drvMutexUnlock();
        return 0;
}
# 9345 "rtl8651_tblDrv.c"
int32 rtl8651_delNatMapping(ipaddr_t extip, ipaddr_t intip) {
        rtl8651_tblDrv_natEntry_t *deletedNatMappingPtr;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        uint32 netIdx;
        int32 retval;

        rtlglue_drvMutexLock();
        if ((_rtl8651_extIpAddr(extip, &netIdx) == 0)) { rtlglue_drvMutexUnlock(); return -2100; };
        if ((_rtl8651_intNetIpAddr(intip) == 0)) { rtlglue_drvMutexUnlock(); return -2101; };
        netif_t = &DrvTbl.netIface[netIdx];
        if ((netif_t->nextNat.slh_first == ((void *)0))) { rtlglue_drvMutexUnlock(); return -3; };
        do {} while (0);
        for((deletedNatMappingPtr) = (&(netif_t->nextNat))->slh_first; (deletedNatMappingPtr); (deletedNatMappingPtr) = (deletedNatMappingPtr)->nextNatEntry.sle_next)
                if (deletedNatMappingPtr->globalIp == extip && deletedNatMappingPtr->localIp == intip)
                                break;
        if ((deletedNatMappingPtr==((void *)0))) { rtlglue_drvMutexUnlock(); return -3; };
        do { if ((&(netif_t->nextNat))->slh_first == (deletedNatMappingPtr)) { do { ((&(netif_t->nextNat)))->slh_first = ((&(netif_t->nextNat)))->slh_first->nextNatEntry.sle_next; } while (0); } else { struct rtl8651_tblDrv_natEntry_s *curelm = (&(netif_t->nextNat))->slh_first; while( curelm->nextNatEntry.sle_next != (deletedNatMappingPtr) ) curelm = curelm->nextNatEntry.sle_next; curelm->nextNatEntry.sle_next = curelm->nextNatEntry.sle_next->nextNatEntry.sle_next; } } while (0);
        retval = _rtl8651_delIpEntry(0x01, extip, intip);
        do { (deletedNatMappingPtr)->nextNatEntry.sle_next = (&DrvTbl.freeList.natMapping)->slh_first; (&DrvTbl.freeList.natMapping)->slh_first = (deletedNatMappingPtr); } while (0);
        rtlglue_drvMutexUnlock();
        return 0;
}
# 9382 "rtl8651_tblDrv.c"
int8 _rtl8651_isNaptMapping(ipaddr_t extip) {
        rtl8651_tblDrv_ipEntry_t *ipEntry_t=DrvTbl.iptbl;
        uint32 entry;

        for(entry=0; entry<16; entry++, ipEntry_t++) {
                if (ipEntry_t->valid == 0)
                        continue;
                if (ipEntry_t->type == 0x00 && ipEntry_t->extip == extip)
                        return 1;
        }
        return 0;
}

static int32 _rtl8651_addSoftNaptToAcl(uint32 aclStart, uint32 aclEnd)
{
        _rtl8651_tblDrvAclRule_t rule;

        do {} while (0);
        if (aclStart > aclEnd) return 0;
        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
        rule.ruleType_ = 0x01;
        rule.actionType_ = 0x03;
        rule.un_ty.L3L4._dstIpAddr = softNaptIp;
        rule.un_ty.L3L4._dstIpAddrMask = 0xffffffff;
        rtl8651_setAsicAclRule(aclStart, &rule);
        rtl8651_setAsicAclRule(124, &rule);
        return 1;
}

static int32 _rtl8651_delNaptMapping(ipaddr_t naptip) {
        if(_rtl8651_extIpAddr(naptip, ((void *)0)) == 0)
                return -1500;
        if (_rtl8651_delIpEntry(0x00, naptip, 0)== 0) {
                _rtl8651_delDmzHost(_rtl8651_DefaultDialSessionId, naptip);
                return 0;
        }
        return -3;
}


static int32 _rtl8651_addNaptMapping(ipaddr_t naptip, rtl8651_tblDrv_ipEntry_t **ie_t)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipEntry_t *ipEntry_t;
        uint32 netIdx;

        if (_rtl8651_extIpAddr(naptip, &netIdx) == 0)
                return -1500;
        if (_rtl8651_isNatMapping(&naptip, ((void *)0)) == 1)
                return -1501;


        netif_t = &DrvTbl.netIface[netIdx];
        if ((ipEntry_t=_rtl8651_addIpEntry(naptip, 0, 0x00, netif_t)) == ((void *)0))
                return -9;
        if (ie_t) *ie_t = ipEntry_t;
        return 0;
}
# 9452 "rtl8651_tblDrv.c"
int32 rtl8651_addNaptMapping(ipaddr_t naptip)
{
        int32 retval = 0;

        rtlglue_drvMutexLock();
        pppoeDefaultGlobalIpAddr = naptip;
        if ( def_napt_t != ((void *)0) ) {
                retval = -3010;
                goto out;
        }
        retval = _rtl8651_addNaptMapping(naptip, &def_napt_t);
# 9471 "rtl8651_tblDrv.c"
out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 9488 "rtl8651_tblDrv.c"
int32 rtl8651_addDriverNaptMapping(ipaddr_t naptip) {
        int32 retval = 0;
        rtlglue_drvMutexLock();
        softNaptIp = naptip;
        _rtl8651_arrangeAllACL();
        rtlglue_drvMutexUnlock();
        return retval;
}


int32 rtl8651_addNaptMappingExt(ipaddr_t naptip) {
        int32 retval = 0;
        rtlglue_drvMutexLock();
        if ((retval=_rtl8651_addNaptMapping(naptip, ((void *)0))) == 0) {
                softNaptIp = naptip;
                _rtl8651_arrangeAllACL();
        }

        rtlglue_drvMutexUnlock();
        return retval;
}
# 9519 "rtl8651_tblDrv.c"
int32 rtl8651_delNaptMapping(ipaddr_t extIpAddr) {
        uint32 retval=0;

        if (extIpAddr == 0)
                return -6;
        rtlglue_drvMutexLock();
# 9546 "rtl8651_tblDrv.c"
        if (extIpAddr == softNaptIp) {
                softNaptIp = 0;
                _rtl8651_arrangeAllACL();
                _rtl8651_removeNaptConnectionByExtIP(extIpAddr);
        } else if ((retval = _rtl8651_delNaptMapping(extIpAddr)) == 0) {
                _rtl8651_removeNaptConnectionByExtIP(extIpAddr);
                rtl8651_flushNaptServerPortbyExtIp(extIpAddr);
                if (def_napt_t && def_napt_t->extip == extIpAddr)
                        def_napt_t = ((void *)0);
        }


        rtlglue_drvMutexUnlock();
        return retval;
}






static int32 _rtl8651_delDmzHost(uint32 dsid,ipaddr_t naptIp) {
        uint32 i;
# 9578 "rtl8651_tblDrv.c"
        for (i = 0; i < 6; i++) {
                if (rtl8651DmzHost[dsid].naptIp[i] == naptIp) {
                        rtl8651DmzHost[dsid].naptIp[i] = 0;
                        return 0;
                }
        }
        return -1100;
}


int32 _rtl8651_getDmzHost(uint32 dsid,ipaddr_t naptIp, ipaddr_t *dmzHostIp) {

        uint32 i;
# 9601 "rtl8651_tblDrv.c"
        for (i = 0; i < 6; i++) {
                if (rtl8651DmzHost[dsid].naptIp[i] == naptIp) {
                        if (dmzHostIp)
                                *dmzHostIp = rtl8651DmzHost[dsid].dmzHost[i];
                        return 0;
                }
        }

        return -1100;
}

int32 _rtl8651_fromDmzHost(uint32 dsid, ipaddr_t dmzHostIp, ipaddr_t *naptIp) {

        uint32 i;
# 9623 "rtl8651_tblDrv.c"
        for (i = 0; i < 6; i++) {
                if (rtl8651DmzHost[dsid].dmzHost[i] ==dmzHostIp) {
                        if (naptIp)
                                *naptIp = rtl8651DmzHost[dsid].naptIp[i];
                        return 0;
                }
        }

        return -1100;
}
# 9647 "rtl8651_tblDrv.c"
int32 rtl8651a_addDmzHost(uint32 SessionID,ipaddr_t naptIp, ipaddr_t dmzHostIp) {
        uint32 dsid, i;
        rtlglue_drvMutexLock();
        dsid=_rtl8651_SessionIDToDSID(SessionID);

        if (dsid==_rtl8651_DefaultDialSessionId)
        {
                if ((_rtl8651_isNaptMapping(naptIp)==0)) { rtlglue_drvMutexUnlock(); return -1101; };
                if ((_rtl8651_intNetIpAddr(dmzHostIp)==0)) { rtlglue_drvMutexUnlock(); return -1102; };
                if ((_rtl8651_intIpAddr(dmzHostIp)==1)) { rtlglue_drvMutexUnlock(); return -1103; };
        }
        for (i = 0; i < 6; i++)
                if ((rtl8651DmzHost[dsid].naptIp[i]==naptIp)) { rtlglue_drvMutexUnlock(); return -2; };

        for (i = 0; i < 6; i++) {
                if (rtl8651DmzHost[dsid].naptIp[i] == 0) {
                        rtl8651DmzHost[dsid].naptIp[i] = naptIp;
                        rtl8651DmzHost[dsid].dmzHost[i] = dmzHostIp;
                        rtlglue_drvMutexUnlock();
                        return 0;
                }
        }
        rtlglue_drvMutexUnlock();
        return -1104;
}







int32 rtl8651a_delDmzHost(uint32 SessionID,ipaddr_t naptIp) {
        int32 retval;
        uint32 dsid;
        rtlglue_drvMutexLock();
        dsid=_rtl8651_SessionIDToDSID(SessionID);
        retval = _rtl8651_delDmzHost(dsid,naptIp);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 9723 "rtl8651_tblDrv.c"
rtl8651_tblDrv_naptServerPortEntry_t *
_rtl8651_getOutsideNaptServerPortMapping(int8 isTcp, ipaddr_t extIpAddr, uint16 extPort) {
        rtl8651_tblDrv_naptServerPortEntry_t * naptServerPortPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 netIdx;

        for(netIdx=0,netIfPtr=&DrvTbl.netIface[0]; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++,netIfPtr++)
                if (netIfPtr->valid == 1) {
                        for((naptServerPortPtr) = (&(netIfPtr->nextNaptServerPort))->slh_first; (naptServerPortPtr); (naptServerPortPtr) = (naptServerPortPtr)->nextServerPort.sle_next) {
                                if(naptServerPortPtr->globalIp == extIpAddr && (naptServerPortPtr->globalPort <= extPort && naptServerPortPtr->endGlobalPort >= extPort))
                                        if ((isTcp && naptServerPortPtr->tcp) ||
                                                (!isTcp && naptServerPortPtr->udp))
                                        return naptServerPortPtr;
                        }
                }
        return ((void *)0);
}

rtl8651_tblDrv_naptServerPortEntry_t *
_rtl8651_getInsideNaptServerPortMapping(int8 isTcp, ipaddr_t intIpAddr, uint16 intPort) {
        rtl8651_tblDrv_naptServerPortEntry_t * naptServerPortPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        uint32 netIdx;

        for(netIdx=0,netIfPtr=&DrvTbl.netIface[0]; netIdx<rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netIfPtr++)
                if (netIfPtr->valid == 1) {
                        for((naptServerPortPtr) = (&(netIfPtr->nextNaptServerPort))->slh_first; (naptServerPortPtr); (naptServerPortPtr) = (naptServerPortPtr)->nextServerPort.sle_next) {
                                if(naptServerPortPtr->localIp== intIpAddr && (naptServerPortPtr->localPort <= intPort && naptServerPortPtr->endLocalPort >= intPort))
                                        if ((isTcp && naptServerPortPtr->tcp) ||
                                                (!isTcp && naptServerPortPtr->udp))
                                        return naptServerPortPtr;
                        }
                }
        return ((void *)0);
}
# 9800 "rtl8651_tblDrv.c"
int32 rtl8651_flushNaptServerPortbyExtIp(ipaddr_t extIp) {

        rtl8651_tblDrv_serverPortAsicArrangementEntry_t *asic_t;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_naptServerPortEntry_t *servPort_t;
        rtl8651_tblDrv_naptServerPortEntry_t *servPort_next;
        uint32 netIdx, i, asicPos;


        if (_rtl8651_extIpAddr(extIp, &netIdx) == 0)
                return -2711;



        netif_t = &DrvTbl.netIface[netIdx];
        do {} while (0);




        servPort_t = ((&netif_t->nextNaptServerPort)->slh_first);
        while ( 1 )
        {
                if ( servPort_t == ((void *)0) ) break;
                servPort_next = ((servPort_t)->nextServerPort.sle_next);


                if (servPort_t->globalIp == extIp)
                {
                        int nCount;

                        nCount=servPort_t->endGlobalPort-servPort_t->globalPort;


                        do { if ((&(netif_t->nextNaptServerPort))->slh_first == (servPort_t)) { do { ((&(netif_t->nextNaptServerPort)))->slh_first = ((&(netif_t->nextNaptServerPort)))->slh_first->nextServerPort.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptServerPortEntry_s *curelm = (&(netif_t->nextNaptServerPort))->slh_first; while( curelm->nextServerPort.sle_next != (servPort_t) ) curelm = curelm->nextServerPort.sle_next; curelm->nextServerPort.sle_next = curelm->nextServerPort.sle_next->nextServerPort.sle_next; } } while (0);


                        do { (servPort_t)->nextServerPort.sle_next = (&DrvTbl.freeList.serverPort)->slh_first; (&DrvTbl.freeList.serverPort)->slh_first = (servPort_t); } while (0);
                        if (servPort_t->toAsic == 1) {
                                asicPos = servPort_t->asicTablePos;
                                asic_t = &AsicTableUsage.serverPort[asicPos];

                                for(i=0; i<=nCount; i++) {
                                        while(1) {
                                                if (asic_t->valid == 1 && asic_t->servPort_t == servPort_t)
                                                        break;
                                                asicPos++; asic_t++;
                                        }
                                        do {} while (0);
                                        rtl8651_delAsicServerPortTable(asicPos);
                                        asic_t->valid = 0;
                                }

                        }




                }


                servPort_t = servPort_next;
        }
        return 0;


}
# 9886 "rtl8651_tblDrv.c"
int32 _rtl8651_addNaptServerPort(int8 isTcp, ipaddr_t gip, uint16 gport, ipaddr_t lip, uint16 lport, uint16 nCount) {
        rtl8651_tblDrv_serverPortAsicArrangementEntry_t *asic_t, *asic_t1;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_naptServerPortEntry_t *servPort_t;
        uint16 lastPort, startPort, endPort;
        uint32 netIdx, asicPos=0, i, freeCount;





        if (_rtl8651_extIpAddr(gip, &netIdx) == 0 || _rtl8651_isNaptMapping(gip) == 0)
        {
                GET_NETWORK_INTERFACE(extIfName,&netIdx);

        }




        if (_rtl8651_intNetIpAddr(lip) == 0)
                return -2712;
        netif_t = &DrvTbl.netIface[netIdx];
        do {} while (0);





        nCount--;
        for((servPort_t) = (&netif_t->nextNaptServerPort)->slh_first; (servPort_t); (servPort_t) = (servPort_t)->nextServerPort.sle_next) {

                if ((servPort_t->globalIp == gip)&&(servPort_t->localIp == lip)&&
                        (servPort_t->globalPort == gport)&&(servPort_t->endGlobalPort == (gport+nCount))&&
                        (servPort_t->localPort == lport)&&(servPort_t->endLocalPort == (lport+nCount)))
                        goto __out;

                if (((isTcp&1) == 1 && servPort_t->tcp == 0) ||
                     ((isTcp&1) == 0 && servPort_t->udp == 0))
                        continue;



                if (servPort_t->globalIp == gip) {
                        lastPort = gport + nCount;
                        startPort = servPort_t->globalPort;
                        endPort = servPort_t->endGlobalPort;
                        if ((lastPort>=startPort && lastPort<=endPort) ||
                                (gport>=startPort && gport<=endPort) ||
                                (gport<=startPort && lastPort>=endPort)) {
                                return -3100;
                        }
                }


                if (servPort_t->localIp == lip ) {
                        lastPort = lport + nCount;
                        startPort = servPort_t->localPort;
                        endPort = servPort_t->endLocalPort;
                        if ((lastPort>=startPort && lastPort<=endPort) ||
                                (lport>=startPort && lport<=endPort) ||
                                (lport<=startPort && lastPort>=endPort)) {
                                return -3100;
                        }
                }
        }

__out:

        if (servPort_t != (rtl8651_tblDrv_naptServerPortEntry_t *)((void *)0)) {
                if ((isTcp&1) == 1 && servPort_t->tcp == 0)
                        servPort_t->tcp = 1;
                else if ((isTcp&1) == 0 && servPort_t->udp == 0)
                        servPort_t->udp = 1;
                else
                        return -2;



                goto find_empty_server_port_entry;





        }

        if(DrvTbl.freeList.serverPort.slh_first == (rtl8651_tblDrv_naptServerPortEntry_t *)((void *)0))
                return -9;
        servPort_t = ((&DrvTbl.freeList.serverPort)->slh_first);
        do { (&DrvTbl.freeList.serverPort)->slh_first = (&DrvTbl.freeList.serverPort)->slh_first->nextServerPort.sle_next; } while (0);
        do { (servPort_t)->nextServerPort.sle_next = (&(netif_t->nextNaptServerPort))->slh_first; (&(netif_t->nextNaptServerPort))->slh_first = (servPort_t); } while (0);
        servPort_t->globalIp = gip;
        servPort_t->globalPort = gport;
        servPort_t->endGlobalPort = gport+nCount;
        servPort_t->localIp = lip;
        servPort_t->localPort = lport;
        servPort_t->endLocalPort = lport+nCount;
        if((isTcp&1) == 1) {
                servPort_t->tcp = 1; servPort_t->udp = 0;
        }else { servPort_t->tcp = 0; servPort_t->udp = 1; }

find_empty_server_port_entry:



        freeCount = 0; asic_t1 = ((void *)0);
        asic_t=&AsicTableUsage.serverPort[0];
        for(i=0; i<16; i++,asic_t++) {
                if(asic_t->valid == 0) {
                        freeCount++;
                        if (!asic_t1) {
                                asic_t1 = asic_t; asicPos = i;
                        }
                }
        }
        if( (asic_t1 && freeCount>=(nCount+1))&&
            ((isTcp&2)==0) &&


            servPort_t->tcp &&
            servPort_t->udp



            )
        {

                rtl8651_tblDrv_arpEntry_t *arp_t;
                if ((arp_t=_rtl8651_getArpEntry(((void *)0), lip, 0)) && _rtl8651_isMacAccessControlPermit(&arp_t->macInfo->macAddr)==0) {

                        servPort_t->toAsic = 0;
                        return 0;
                }


                servPort_t->asicTablePos = asicPos;
                servPort_t->toAsic = 1;
                for(i=0; i<=nCount; i++) {
                        while(asic_t1->valid == 1 && asicPos < 16 ) {
                                asic_t1++; asicPos++;
                        }
                        asic_t1->valid = 1;
                        asic_t1->servPort_t = servPort_t;
                        do {} while (0);
                        convert_setAsicServerPortTable(asicPos, servPort_t->globalIp, servPort_t->globalPort+i, servPort_t->localIp, servPort_t->localPort+i);
                }
        }
        else {
                servPort_t->toAsic = 0;

        }


        return 0;
}


int32 _rtl8651_delNaptServerPort(int8 isTcp, ipaddr_t gip, uint16 gport, ipaddr_t lip, uint16 lport, uint16 nCount) {
        rtl8651_tblDrv_serverPortAsicArrangementEntry_t *asic_t;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_naptServerPortEntry_t *servPort_t;
        uint32 netIdx, i, asicPos;

        if (_rtl8651_extIpAddr(gip, &netIdx) == 0 || _rtl8651_isNaptMapping(gip) == 0)
        {
                GET_NETWORK_INTERFACE(extIfName,&netIdx);

        }


        if (_rtl8651_intNetIpAddr(lip) == 0)
                return -2712;
        netif_t = &DrvTbl.netIface[netIdx];
        do {} while (0);

        nCount--;
        for((servPort_t) = (&netif_t->nextNaptServerPort)->slh_first; (servPort_t); (servPort_t) = (servPort_t)->nextServerPort.sle_next)
                if (servPort_t->globalIp == gip && servPort_t->localIp == lip &&
                        servPort_t->globalPort == gport && servPort_t->endGlobalPort == (gport+nCount) &&
                        servPort_t->localPort == lport && servPort_t->endLocalPort == (lport+nCount))
                        break;
        if (servPort_t == (rtl8651_tblDrv_naptServerPortEntry_t *)((void *)0))
                return -3;

        if ((isTcp&1) == 1 && servPort_t->tcp == 1)
                servPort_t->tcp = 0;
        else if ((isTcp&1) == 0 && servPort_t->udp == 1)
                servPort_t->udp = 0;
        else return -3;



        if ( servPort_t->tcp == 0 || servPort_t->udp == 0 )




        {
                if (servPort_t->toAsic == 1) {
                        asicPos = servPort_t->asicTablePos;
                        asic_t = &AsicTableUsage.serverPort[asicPos];
                        for(i=0; i<=nCount; i++) {
                                while( asicPos < 16 ) {
                                        if (asic_t->valid == 1 && asic_t->servPort_t == servPort_t)
                                                break;
                                        asicPos++; asic_t++;
                                }
                                do {} while (0);
                                rtl8651_delAsicServerPortTable(asicPos);
                                asic_t->valid = 0;
                        }
                        servPort_t->toAsic = 0;
                }
        }

        if (servPort_t->tcp == 0 && servPort_t->udp == 0)
        {
                do { if ((&(netif_t->nextNaptServerPort))->slh_first == (servPort_t)) { do { ((&(netif_t->nextNaptServerPort)))->slh_first = ((&(netif_t->nextNaptServerPort)))->slh_first->nextServerPort.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptServerPortEntry_s *curelm = (&(netif_t->nextNaptServerPort))->slh_first; while( curelm->nextServerPort.sle_next != (servPort_t) ) curelm = curelm->nextServerPort.sle_next; curelm->nextServerPort.sle_next = curelm->nextServerPort.sle_next->nextServerPort.sle_next; } } while (0);

                do { (servPort_t)->nextServerPort.sle_next = (&DrvTbl.freeList.serverPort)->slh_first; (&DrvTbl.freeList.serverPort)->slh_first = (servPort_t); } while (0);
        }




        return 0;
}
# 10130 "rtl8651_tblDrv.c"
int32 rtl8651a_addNaptServerPortMapping(uint32 SessionID,int8 isTcp, ipaddr_t extIpAddr, uint16 extPort, ipaddr_t intIpAddr, uint16 intPort) {
        int32 retval;
        uint32 dsid;
        dsid=_rtl8651_SessionIDToDSID(SessionID);

        if( _rtl8651_getExtIpAddrByDsid(dsid)!=extIpAddr)
                return -2711;

        rtlglue_drvMutexLock();
        if(dsid==_rtl8651_DefaultDialSessionId)
                retval = _rtl8651_addNaptServerPort(isTcp, extIpAddr, extPort, intIpAddr, intPort, 1);
        else
                retval = _rtl8651_addNaptServerPort((isTcp|2), extIpAddr, extPort, intIpAddr, intPort, 1);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 10160 "rtl8651_tblDrv.c"
int32 rtl8651a_delNaptServerPortMapping(uint32 SessionID,int8 isTcp, ipaddr_t extIpAddr, uint16 extPort, ipaddr_t intIpAddr, uint16 intPort) {
        int32 retval;
        uint32 dsid;
        dsid=_rtl8651_SessionIDToDSID(SessionID);

        if( _rtl8651_getExtIpAddrByDsid(dsid)!=extIpAddr)
                return -2711;

        rtlglue_drvMutexLock();
        retval = _rtl8651_delNaptServerPort(isTcp, extIpAddr, extPort, intIpAddr, intPort, 1);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 10189 "rtl8651_tblDrv.c"
int32 rtl8651a_addNaptServerPortRange(uint32 SessionID,int8 isTcp, ipaddr_t extIp, uint16 extPort, ipaddr_t intIp, uint16 intPort, uint16 nCount) {
        int32 retval;
        uint32 dsid;
        dsid=_rtl8651_SessionIDToDSID(SessionID);



        if( _rtl8651_getExtIpAddrByDsid(dsid)!=extIp)
                return -2711;

        rtlglue_drvMutexLock();
        retval = _rtl8651_addNaptServerPort((isTcp|2), extIp, extPort, intIp, intPort, nCount);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 10219 "rtl8651_tblDrv.c"
int32 rtl8651a_delNaptServerPortRange(uint32 SessionID,int8 isTcp, ipaddr_t extIp, uint16 extPort, ipaddr_t intIp, uint16 intPort, uint16 nCount) {
        int32 retval;
        uint32 dsid;
        dsid=_rtl8651_SessionIDToDSID(SessionID);

        if( _rtl8651_getExtIpAddrByDsid(dsid)!=extIp)
                return -2711;

        rtlglue_drvMutexLock();
        retval = _rtl8651_delNaptServerPort(isTcp, extIp, extPort, intIp, intPort, nCount);
        rtlglue_drvMutexUnlock();
        return retval;
}







int32 rtl8651_enable4WayHash(uint8 isEnable)
{
        rtlglue_drvMutexLock();
        _set4WayHash((int32)isEnable);
        enable4WayHash = (isEnable==1)? 1: 0;
        rtlglue_drvMutexUnlock();
        return 0;

}

int32 rtl8651_is4WayHashEnable(uint8 *isEnable)
{
        rtlglue_drvMutexLock();
        if (isEnable != ((void *)0)) {
                *isEnable = (_Is4WayHashEnabled()!=0)? 1: 0;
        }
        rtlglue_drvMutexUnlock();
        return 0;
}







static void _rtl8651_setNaptAsicAge( void )
{

        rtl8651AsicAge = rtl8651GlobalControl;





        {
                uint32 asicTimeout;

                asicTimeout = _rtl8651_NaptAgingToSec( _rtl8651_NaptAgingToUnit(8) );

                do {} while (0);


                if ( rtl8651AsicAge.tcpFastTimeout > asicTimeout )
                {
                        rtl8651AsicAge.tcpFastTimeout = asicTimeout;
                }
                if ( rtl8651AsicAge.tcpMediumTimeout > asicTimeout )
                {
                        rtl8651AsicAge.tcpMediumTimeout = asicTimeout;
                }
                if ( rtl8651AsicAge.tcpLongTimeout > asicTimeout )
                {
                        rtl8651AsicAge.tcpLongTimeout = asicTimeout;
                }
                if ( rtl8651AsicAge.udpTimeout > asicTimeout )
                {
                        rtl8651AsicAge.udpTimeout = asicTimeout;
                }
                if ( rtl8651AsicAge.icmpTimeout > asicTimeout )
                {
                        rtl8651AsicAge.icmpTimeout = asicTimeout;
                }
                if ( rtl8651AsicAge.tcpFinTimeout > asicTimeout )
                {
                        rtl8651AsicAge.tcpFinTimeout = asicTimeout;
                }
        }


        rtl8651_setAsicNaptTcpFastTimeout( rtl8651AsicAge.tcpFastTimeout );
        rtl8651_setAsicNaptTcpMediumTimeout( rtl8651AsicAge.tcpMediumTimeout );
        rtl8651_setAsicNaptTcpLongTimeout( rtl8651AsicAge.tcpLongTimeout );
        rtl8651_setAsicNaptUdpTimeout( rtl8651AsicAge.udpTimeout );
        rtl8651_setAsicNaptIcmpTimeout( rtl8651AsicAge.icmpTimeout );
}
# 10324 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptIcmpTimeout(uint32 timeout) {

        rtlglue_drvMutexLock();
        rtl8651GlobalControl.icmpTimeout = timeout;
        _rtl8651_setNaptAsicAge();
        rtlglue_drvMutexUnlock();

        return 0;
}
# 10342 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptIcmpFastTimeout(uint32 timeout) {

        rtlglue_drvMutexLock();
        rtl8651GlobalControl.icmpFastTimeout = timeout;
        _rtl8651_setNaptAsicAge();
        rtlglue_drvMutexUnlock();

        return 0;
}
# 10360 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptUdpTimeout(uint32 timeout) {

        rtlglue_drvMutexLock();
        rtl8651GlobalControl.udpTimeout = timeout;
        _rtl8651_setNaptAsicAge();
        rtlglue_drvMutexUnlock();

        return 0;
}
# 10380 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptTcpLongTimeout(uint32 timeout) {

        rtlglue_drvMutexLock();
        rtl8651GlobalControl.tcpLongTimeout = timeout;
        _rtl8651_setNaptAsicAge();
        rtlglue_drvMutexUnlock();

        return 0;
}
# 10400 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptTcpMediumTimeout(uint32 timeout) {

        rtlglue_drvMutexLock();
        rtl8651GlobalControl.tcpMediumTimeout = timeout;
        _rtl8651_setNaptAsicAge();
        rtlglue_drvMutexUnlock();

        return 0;
}
# 10420 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptTcpFastTimeout(uint32 timeout) {

        rtlglue_drvMutexLock();
        _userConfigFastTimeoutValue = timeout;
        rtl8651GlobalControl.tcpFastTimeout = timeout;
        _rtl8651_setNaptAsicAge();
        rtlglue_drvMutexUnlock();

        return 0;
}
# 10439 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptTcpFinTimeout(uint32 timeout) {

        rtlglue_drvMutexLock();
        rtl8651GlobalControl.tcpFinTimeout = timeout;
        _rtl8651_setNaptAsicAge();
        rtlglue_drvMutexUnlock();

        return 0;
}
# 10468 "rtl8651_tblDrv.c"
int32 _rtl8651_setNaptEntry( uint16 tblIndex, rtl8651DrvNaptLine_t *naptLine, rtl8651_tblDrv_naptTcpUdpFlowEntry_t *entry, int8 statusUpdate)
{
        int32 collision = 0, collision2 = 0, index;
        uint32 entryType;
        rtl8651_tblAsic_naptTcpUdpTable_t asicEntry;
        rtl865x_tblAsicDrv_naptTcpUdpParam_t asic_napt;
        uint32 ageAsic;
        int32 inAsic;
        int32 outAsic;

        do {} while (0);






        if(!entry){

                if(statusUpdate){

                        do {} while (0);
                        return rtl8651_setAsicRawNaptTable( tblIndex, &asicEntry, 1);
                }

                entryType=(0x0<<0);


                asic_napt.ageSec = 0;
                asic_napt.insideLocalIpAddr = 0;
                asic_napt.insideLocalPort = 0;
                asic_napt.isCollision = (collision==1? 1: 0);
                asic_napt.isCollision2 = (collision2==1? 1: 0);
                asic_napt.isDedicated = 0;
                asic_napt.isStatic = 0;
                asic_napt.isTcp = 0;
                asic_napt.isValid = 0;
                asic_napt.offset = 0;
                asic_napt.selEIdx = 0;
                asic_napt.selExtIPIdx = 0;
                asic_napt.tcpFlag = 0;
                index = tblIndex & (1024 -1);
                return rtl8651_setAsicNaptTcpUdpTable(1, index, &asic_napt);
        }

        do {} while (0);


        if ( entry->tcp )
                ageAsic = ({ const typeof(entry->age) _x = (entry->age); const typeof(rtl8651AsicAge.tcpLongTimeout) _y = (rtl8651AsicAge.tcpLongTimeout); (void) (&_x == &_y); _x < _y ? _x : _y; });
        else
                ageAsic = ({ const typeof(entry->age) _x = (entry->age); const typeof(rtl8651AsicAge.udpTimeout) _y = (rtl8651AsicAge.udpTimeout); (void) (&_x == &_y); _x < _y ? _x : _y; });

        if( entry->hashing==1 ){
                if(statusUpdate)
                        entryType=entry->isStatic?
                                (0x1<<0):(0x0<<0);
                else
                        entryType=(0x1<<0);

                asic_napt.ageSec = ageAsic;
                asic_napt.insideLocalIpAddr = entry->insideLocalIpAddr;
                asic_napt.insideLocalPort = entry->insideLocalPort;
                asic_napt.isCollision = (collision==1? 1: 0);
                asic_napt.isCollision2 = (collision2==1? 1: 0);
                asic_napt.isDedicated = 0;
                asic_napt.isStatic = entryType&(0x1<<0)? 1: 0;
                asic_napt.isTcp = (entry->tcp==1?1: 0);
                asic_napt.isValid = 1;
                asic_napt.offset = entry->insideGlobalPort>>10;
                asic_napt.selEIdx = 0;
                asic_napt.selExtIPIdx = 0;
                asic_napt.tcpFlag = (entry->tcp==1)?entry->tcpFlag: 0;
                index = entry->insideGlobalPort&(1024 -1);
                return rtl8651_setAsicNaptTcpUdpTable(statusUpdate, index, &asic_napt);
        }


        do {} while (0);
        entryType=(0x1<<0)|(0x2<<0);
        if( entry->connectionType == 1 )
                ((entryType) |= ((4<<2)));

        ((entryType) &= ~((2<<2)));
        ((entryType) &= ~((1<<2)));
        inAsic = outAsic = 0;
        if(entry->inboundTblIdx==entry->outboundTblIdx)
        {
                if ( entry->inListType == 1 &&
                     entry->outListType == 0 )
                {

                        ((entryType) &= ~((2<<2)));
                        ((entryType) &= ~((1<<2)));
                        inAsic = outAsic = 1;
                }
                else if ( entry->inListType == 1 &&
                          entry->outListType != 0 )
                {

                        ((entryType) |= ((2<<2)));
                        ((entryType) |= ((0<<2)));
                        inAsic = 1;
                }
                else if ( entry->inListType != 1 &&
                          entry->outListType == 0 )
                {

                        ((entryType) |= ((2<<2)));
                        ((entryType) |= ((1<<2)));
                        outAsic = 1;
                }
                else
                {

                        do {} while (0);
                        return -1;
                }
        }
        else if(tblIndex==entry->outboundTblIdx)
        {

                if ( entry->outListType == 0 )
                {
                        ((entryType) |= ((2<<2)));
                        ((entryType) |= ((1<<2)));
                        outAsic = 1;
                }
        }
        else
        {

                do {} while (0);
                if ( entry->inListType == 1 )
                {
                        ((entryType) |= ((2<<2)));
                        ((entryType) |= ((0<<2)));
                        inAsic = 1;
                }
        }


        do {} while (0);


        if ( inAsic && entry->inboundTblIdx == tblIndex &&
             entry->inExtIpIdx < 0 )
        {
                entry->inExtIpIdx = _rtl8651_addHash2ToNexthop( entry->interfaceRoute? entry->dstIpAddr: 0,
                                                                entry->insideGlobalIpAddr );
                if ( entry->inExtIpIdx==-1 ) return -1;
        }
        if ( outAsic && entry->outboundTblIdx == tblIndex &&
             entry->outExtIpIdx < 0 )
        {
                entry->outExtIpIdx = _rtl8651_addHash2ToNexthop( entry->interfaceRoute? entry->dstIpAddr: 0,
                                                                 entry->insideGlobalIpAddr );
                if ( entry->outExtIpIdx==-1 )
                {

                        _rtl8651_delHash2FromNexthop( entry->interfaceRoute? entry->dstIpAddr: 0,
                                                      entry->insideGlobalIpAddr );
                        entry->inExtIpIdx = -1;
                        return -1;
                }
        }
        if ( entry->inExtIpIdx >= 0 &&
             entry->outExtIpIdx >= 0 )
                do {} while (0);
# 10650 "rtl8651_tblDrv.c"
        return rtl8651_setAsicLiberalNaptTcpUdpTable(statusUpdate, tblIndex, entry->insideLocalIpAddr,
                entry->insideLocalPort, entry->inExtIpIdx>=0?entry->inExtIpIdx:entry->outExtIpIdx, entry->insideGlobalPort,
                ageAsic ,entryType, entry->tcp, collision, collision2, 1);

}
# 10667 "rtl8651_tblDrv.c"
int32 _rtl8651_getNaptEntry(uint16 tblIndex, rtl8651DrvNaptLine_t *naptLine, rtl8651_tblDrv_naptTcpUdpFlowEntry_t **entry, int8 direct){
        struct naptEntryListHead *head;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *asicCached;
        rtl8651_tblDrv_naptTcpUdpFlowEntry_t *storage;
        rtl8651_tblAsic_naptTcpUdpTable_t asicEntry;

        do {} while (0);
        head=&naptLine->list[0];
        asicCached=((head)->slh_first);
        if(!asicCached){
                head=&naptLine->list[1];
                asicCached=((head)->slh_first);
        }

        if(direct|| !asicCached){

                uint32 index;

                storage= *entry;
                do {} while (0);
                memset(storage,0,sizeof(rtl8651_tblDrv_naptTcpUdpFlowEntry_t));
                rtl8651_getAsicRawNaptTable(tblIndex, (void *)&asicEntry);
                storage->asicSnapshot=1;
                storage->dstIpAddr=0;
                storage->insideLocalPort= asicEntry.intPort;
                storage->insideLocalIpAddr=asicEntry.intIPAddr;
                storage->dstPort=0;
                storage->age = _rtl8651_NaptAgingToSec(asicEntry.agingTime);
                storage->tcp = asicEntry.isTCP;
                storage->tcpFlag = asicEntry.TCPFlag;
                storage->alive=asicEntry.valid;
                storage->fromDrv=0;




                storage->pureSoftware = 0;
                storage->col1 = asicEntry.collision;
                storage->col2=asicEntry.collision2;
                storage->isStatic=asicEntry.isStatic;
                storage->hashing = asicEntry.dedicate?2:1;
                if(asicEntry.dedicate){
                        int32 retval;
                        rtl865x_tblAsicDrv_extIntIpParam_t ipt_entry;

                        retval = rtl8651_getAsicExtIntIpTable(asicEntry.selIPIdx , &ipt_entry);
                        do {} while (0);
                        storage->insideGlobalIpAddr = ipt_entry.extIpAddr;
                        storage->insideGlobalPort= asicEntry.offset << 10 | asicEntry.selEIdx;
                        storage->quiet=(asicEntry.TCPFlag&0x4)>>2;
                        storage->outboundTblIdx = tblIndex;
                        storage->inboundTblIdx = asicEntry.selEIdx;
                }else if (asicEntry.valid){
                        index = (asicEntry.intIPAddr & (16 -1))%naptIpCount;
                        do {} while (0);
                        storage->insideGlobalIpAddr=DrvTbl.iptbl[index].extip;
                        storage->insideGlobalPort= asicEntry.offset << 10 | tblIndex;
                        storage->quiet=0;
                        storage->outboundTblIdx =storage->inboundTblIdx= tblIndex;
                }
                return 0;
        }


        do {} while (0);
        *entry=asicCached;
        return 0;
}
# 10748 "rtl8651_tblDrv.c"
int32 rtl8651_setNaptTcpUdpPortRange(uint16 start, uint16 end) {
        if ((start&0x3ff) != 0 || (end&0x3ff) != 0x3ff || start > end) {
                return(-6);
        }
        start = start >> 10; end = end >> 10;
        if (end > 0x3f || start > 0x3f) {
                return(-6);
        }
        rtlglue_drvMutexLock();

        rtl8651GlobalControl.l4PortRangeEnd = end;
        rtl8651GlobalControl.l4PortRangeStart = start;
        rtl8651_setAsicL4Offset(rtl8651GlobalControl.l4PortRangeStart, rtl8651GlobalControl.l4PortRangeEnd);
        rtlglue_drvMutexUnlock();
        return 0;
}
# 10776 "rtl8651_tblDrv.c"
rtl8651_tblDrv_nextHopEntry_t*
_rtl8651_getDefaultNextHop( void )
{
        rtl8651_tblDrv_routeTable_t *rt_t = ((void *)0);

        rt_t = &DrvTbl.route[8 -1];
        if ( rt_t->valid==1 )
        {
                return rt_t->un.nxthop.start_t;
        }

        return ((void *)0);
}
# 10806 "rtl8651_tblDrv.c"
int8 _rtl8651_ExtPortIsShared( uint32 isTcp, ipaddr_t ExtIp, uint16 ExtPort, uint16 assumedPort )
{
        uint32 mask[2], thisBit[2];
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *thisConn;
        rtl8651DrvNaptLine_t *tcpudpPtr;
        uint32 thisOffset;
        int32 i;
        isTcp = (isTcp?1:0);
        tcpudpPtr = &DrvTbl.tcpudp[ ExtPort & (1024 -1) ];

        mask[0] = mask[1] = thisBit[0] = thisBit[1] = 0;
        do {} while (0);

        if ( assumedPort > 0 )
        {
                thisOffset = ( assumedPort >> 10 );
                thisBit[0] = thisBit[1] = 0;
                thisBit[thisOffset>>5] = 1 << (thisOffset&0x1f);
                mask[thisOffset>>5] |= thisBit[thisOffset>>5];
        }


        {
                rtl8651_tblDrv_networkIntfTable_t *netif_t;
                rtl8651_tblDrv_naptServerPortEntry_t *servPort_t;
                uint32 netIdx;

                if (_rtl8651_extIpAddr(ExtIp, &netIdx) == 0 ||
                    _rtl8651_isNaptMapping(ExtIp) == 0)
                {
                        GET_NETWORK_INTERFACE(extIfName,&netIdx);

                }

                netif_t = &DrvTbl.netIface[netIdx];
                do {} while (0);

                for((servPort_t) = (&netif_t->nextNaptServerPort)->slh_first; (servPort_t); (servPort_t) = (servPort_t)->nextServerPort.sle_next)
                {
                        if ( servPort_t->tcp == isTcp &&
                             servPort_t->globalIp == ExtIp )
                        {
                                if ( servPort_t->globalPort<= ExtPort &&
                                     ExtPort <= servPort_t->endGlobalPort )
                                        return 1;
                        }
                }
        }


        for( i = 1; i < 8; i+=2 )
        {
                for((thisConn) = (&tcpudpPtr->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextIn.sle_next)
                {
                        do {} while (0);
                        if ( thisConn->tcp != isTcp ) continue;
                        if ( thisConn->insideGlobalIpAddr != ExtIp ) continue;

                        thisOffset = ( thisConn->insideGlobalPort >> 10 );
                        thisBit[0] = thisBit[1] = 0;
                        thisBit[thisOffset>>5] = 1 << (thisOffset&0x1f);
                        if ( mask[thisOffset>>5] & thisBit[thisOffset>>5] )
                        {

                                return 1;
                        }
                        else
                        {
                                mask[thisOffset>>5] |= thisBit[thisOffset>>5];
                        }
                }
        }
        return 0;
}
# 10898 "rtl8651_tblDrv.c"
int32
_rtl8651_getOutboundAlgConnection( int8 isTcp, ipaddr_t sip, uint16 sport,
                                 ipaddr_t dip, uint16 dport,
                                 struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **ppEntry)
{
        rtl8651_tblDrv_naptTcpUdpFlowEntry_t *pEntry, *thisConn;
        int32 flowTblIdx;
        rtl8651DrvNaptLine_t *thisLine;

        do {} while (0);
        do {} while (0);
        pEntry = *ppEntry;

        flowTblIdx = rtl8651_naptTcpUdpTableIndex( isTcp, sip, sport, 0, 0 );
        thisLine = &DrvTbl.tcpudp[flowTblIdx];

        for((thisConn) = (&thisLine->list[2])->slh_first; (thisConn); (thisConn) = (thisConn)->nextOut.sle_next)
        {
                do {} while (0);

                if(thisConn->age==0)
                        continue;
                if((thisConn->tcp ==1? 1: 0) != isTcp)
                        continue;
                if(thisConn->insideLocalIpAddr != sip)
                        continue;
                if(thisConn->insideLocalPort != sport)
                        continue;
                if(dip&&thisConn->dstIpAddr!= dip)
                        continue;
                if(dport &&thisConn->dstPort!= dport)
                        continue;
                pEntry= thisConn;
                goto found;
        }
        *ppEntry=((void *)0);
        return -3;

found:



        if ( pEntry->tcp == 0 )
                pEntry->age = rtl8651GlobalControl.udpTimeout;

        do {} while (0);
        *ppEntry= pEntry;
        return 0;
}
# 10964 "rtl8651_tblDrv.c"
int32
_rtl8651_getInboundAlgConnection( int8 isTcp, ipaddr_t gip, uint16 gport,
                                ipaddr_t dip, uint16 dport,
                                struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **ppEntry )
{
        rtl8651_tblDrv_naptTcpUdpFlowEntry_t *pEntry, *thisConn;
        uint32 flowTblIdx = gport & (1024 -1);
        rtl8651DrvNaptLine_t *thisLine;
        do {} while (0);
        pEntry = *ppEntry;
        thisLine = &DrvTbl.tcpudp[flowTblIdx];
        do {} while (0);
        for((thisConn) = (&thisLine->list[3])->slh_first; (thisConn); (thisConn) = (thisConn)->nextIn.sle_next)
        {
                do {} while (0);

                if(thisConn->age==0)
                        continue;
                if((thisConn->tcp ==1? 1: 0) != isTcp)
                        continue;
                if(thisConn->insideGlobalIpAddr != gip)
                        continue;
                if(thisConn->insideGlobalPort != gport)
                        continue;
                if(dip&&thisConn->dstIpAddr!= dip)
                        continue;
                if(dport &&thisConn->dstPort!= dport)
                        continue;
                pEntry= thisConn;
                goto found;
        }
        *ppEntry=((void *)0);
        return -3;

found:



        if ( pEntry->tcp == 0 )
                pEntry->age = rtl8651GlobalControl.udpTimeout;

        do {} while (0);
        *ppEntry= pEntry;
        return 0;
}
# 11028 "rtl8651_tblDrv.c"
rtl8651_tblDrv_naptTcpUdpFlowEntry_t *
_rtl8651_findNaptConnection( uint32 tblIndex, int8 isTcp, ipaddr_t intIp, uint16 intPort,
                                                          ipaddr_t remoteIp, uint16 remotePort )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *thisConn, *candConn;
        rtl8651DrvNaptLine_t *thisLine = &DrvTbl.tcpudp[tblIndex];
        uint16 i;
        uint16 allowSp;

        allowSp = isTcp & (1<<1);
        isTcp &= 1;
        candConn = ((void *)0);


        for( i = 0; i < 8; i+=2 )
        {





                for((thisConn) = (&thisLine->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextOut.sle_next)
                {
                        if( thisConn->age > 0 &&
                            (thisConn->tcp==1 ?1 :0) == isTcp &&
                            thisConn->insideLocalIpAddr == intIp &&
                            thisConn->insideLocalPort == intPort )
                        {




                                if ( remoteIp != 0 && remotePort != 0 &&
                                     thisConn->dstIpAddr == remoteIp &&
                                     thisConn->dstPort == remotePort )
                                {
                                        return thisConn;
                                }

                                else if ( remoteIp == 0 && remotePort == 0 &&
                                          thisConn->dstIpAddr == 0 &&
                                          thisConn->dstPort == 0 )
                                {
                                        return thisConn;
                                }
                                else if ( allowSp && thisConn->dstIpAddr==0 && thisConn->dstPort == 0 )
                                {
                                        candConn = thisConn;
                                }
                        }
                }
        }

        return candConn;
}
# 11096 "rtl8651_tblDrv.c"
rtl8651_tblDrv_naptTcpUdpFlowEntry_t *
_rtl8651_findNaptConnectionByExtIpPort( int8 isTcp, ipaddr_t ExtIp, uint16 ExtPort,
                                        ipaddr_t remoteIp, uint16 remotePort )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *thisConn, *candConn;
        rtl8651DrvNaptLine_t *thisLine;
        uint16 i, j;
        uint16 allowSP;



        uint32 idx[1];





        if (!(ExtIp != 0 ))
                return ((void *)0);
        if (!((remoteIp == 0 && remotePort == 0 ) || ( remoteIp != 0 && remotePort != 0 )))
                return ((void *)0);






        allowSP = isTcp & (1<<1);
        isTcp &= 1;
        candConn = ((void *)0);






        idx[0] = ExtPort&(1024 -1);


        for( j = 0; j < sizeof(idx)/sizeof(idx[0]); j++ )
        {
                thisLine = &DrvTbl.tcpudp[idx[j]];


                for( i = 1; i < 8; i+=2 )
                {





                        for((thisConn) = (&thisLine->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextIn.sle_next)
                        {






                                if( thisConn->age > 0 &&
                                    (thisConn->tcp==1 ?1 :0) == isTcp &&
                                    thisConn->insideGlobalIpAddr== ExtIp &&
                                    thisConn->insideGlobalPort == ExtPort )
                                {




                                        if ( remoteIp != 0 && remotePort != 0 &&
                                             thisConn->dstIpAddr == remoteIp &&
                                             thisConn->dstPort == remotePort )
                                        {
                                                return thisConn;
                                        }

                                        else if ( remoteIp == 0 && remotePort == 0 &&
                                                  thisConn->dstIpAddr == 0 &&
                                                  thisConn->dstPort == 0 )
                                        {
                                                return thisConn;
                                        }
                                        else if ( allowSP && thisConn->dstIpAddr == 0 && thisConn->dstPort == 0)
                                        {
                                                candConn = thisConn;
                                        }
                                }
                        }
                }
        }

        return candConn;
}
# 11213 "rtl8651_tblDrv.c"
rtl8651_tblDrv_naptTcpUdpFlowEntry_t *
_rtl8651_addNaptAlgConnection( int8 assigned, int8 flowType,
                               ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                               ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort,
                               ipaddr_t dstIpAddr, uint16 dstPort )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tempNaptTcpUdpFlowPtr;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s entry, *pEntry = &entry;
        uint16 inIdx, outIdx;
        uint16 offset;
        uint32 isTcp = (flowType?1:0);
        int8 isExternal, is_gwip;

        do {} while (0);
# 11235 "rtl8651_tblDrv.c"
        if (_rtl8651_getIpInfo(insideLocalIpAddr, ((void *)0), &isExternal, &is_gwip)==((void *)0) || isExternal == 1 || is_gwip == 1)
        {



                return ((void *)0);
        }


        if( dstIpAddr && _rtl8651_localServerIpAddr( dstIpAddr ) == 1 )
        {



                return ((void *)0);
        }


        if( ((&DrvTbl.freeList.tcpudp)->tqh_count) == 0 )
        {



                return ((void *)0);
        }


        outIdx = rtl8651_naptTcpUdpTableIndex( (flowType==0? 0: 1),
                                               insideLocalIpAddr, insideLocalPort, 0, 0 );
# 11276 "rtl8651_tblDrv.c"
        if ( assigned & 0x0001 )
        {

                if( 0 == _rtl8651_getInboundAlgConnection( (flowType==0? 0: 1) ,
                                                                  *insideGlobalIpAddr, *insideGlobalPort,
                                                                  dstIpAddr, dstPort, &pEntry ) )
                {



                        return ((void *)0);
                }
        }
        else
        {

                if( 0 == _rtl8651_getOutboundAlgConnection( (flowType==0? 0: 1) ,
                                                                  insideLocalIpAddr, insideLocalPort,
                                                                  dstIpAddr, dstPort, &pEntry ) )
                {



                        return ((void *)0);
                }
        }

        if( !(assigned & 0x0001) )
        {

                *insideGlobalIpAddr = _rtl8651_getNaptInsideGlobalIpAddr( (flowType==0? 0: 1),
                                                                         insideLocalIpAddr, insideLocalPort,
                                                                         dstIpAddr, dstPort );

                if ( *insideGlobalIpAddr == 0 )
                {



                        return ((void *)0);
                }


                inIdx = outIdx;


                if( _rtl8651_selectNaptPortOffset( inIdx, isTcp, *insideGlobalIpAddr, &offset ) == -1 )
                {



                        return ((void *)0);
                }
                *insideGlobalPort = offset << 10 | inIdx;
        }
        else if ( *insideGlobalIpAddr != 0 && *insideGlobalPort != 0 )
        {

                pEntry = &entry;
                if( 0 == _rtl8651_getInboundAlgConnection( (flowType==0? 0: 1) ,
                                                               *insideGlobalIpAddr, *insideGlobalPort,
                                                               dstIpAddr, dstPort, &pEntry ) )
                {



                        return ((void *)0);
                }
                inIdx = *insideGlobalPort & (1024 -1);
        }
        else
        {




                return ((void *)0);
        }


        if ( assigned & 0x0020 )
        {
                do {} while (0);


                if ( _rtl8651_dosNaptConnCheck(
                        isTcp,
                        (assigned & 0x0040)?insideLocalIpAddr:dstIpAddr,
                        (assigned & 0x0040)?0:1) != 0)
                {



                        return ((void *)0);
                }
        }


        tempNaptTcpUdpFlowPtr = ((&DrvTbl.freeList.tcpudp)->tqh_first);
        memset( tempNaptTcpUdpFlowPtr, 0, ((size_t) &((struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *)0)->nextOut) );
        tempNaptTcpUdpFlowPtr->connectionType= 3;
        tempNaptTcpUdpFlowPtr->dstIpAddr = dstIpAddr;
        tempNaptTcpUdpFlowPtr->dstPort = dstPort;
        tempNaptTcpUdpFlowPtr->insideLocalIpAddr = insideLocalIpAddr;
        tempNaptTcpUdpFlowPtr->insideLocalPort = insideLocalPort;
        tempNaptTcpUdpFlowPtr->insideGlobalIpAddr = *insideGlobalIpAddr;
        tempNaptTcpUdpFlowPtr->insideGlobalPort = *insideGlobalPort;
        tempNaptTcpUdpFlowPtr->hashing = 2;
        tempNaptTcpUdpFlowPtr->alive = 1;
        tempNaptTcpUdpFlowPtr->fromDrv = 1;
        tempNaptTcpUdpFlowPtr->tcp = (flowType)? 1: 0;
        tempNaptTcpUdpFlowPtr->tcpFlag = flowType? flowType-1:0;
        tempNaptTcpUdpFlowPtr->toProtocolStack = (assigned & 0x0008)?1:0;
        tempNaptTcpUdpFlowPtr->dosEnCount = 0;
        tempNaptTcpUdpFlowPtr->dosFromInternal = 0;

        tempNaptTcpUdpFlowPtr->outboundTblIdx = outIdx;
        tempNaptTcpUdpFlowPtr->outListType= 2;
        tempNaptTcpUdpFlowPtr->inboundTblIdx = inIdx;
        tempNaptTcpUdpFlowPtr->inListType= 3;

        tempNaptTcpUdpFlowPtr->out_rt_t = ((void *)0);
        tempNaptTcpUdpFlowPtr->in_rt_t = (void *)_rtl8651_getRoutingEntry(insideLocalIpAddr);
        tempNaptTcpUdpFlowPtr->out_macInfo_t = ((void *)0);
        tempNaptTcpUdpFlowPtr->in_macInfo_t = ((void *)0);
        do {} while (0);
        tempNaptTcpUdpFlowPtr->dsid = 0;


        if( flowType == 5 )
                tempNaptTcpUdpFlowPtr->age = rtl8651GlobalControl.tcpLongTimeout;
        else
                tempNaptTcpUdpFlowPtr->age = (flowType)?rtl8651GlobalControl.tcpFastTimeout: rtl8651GlobalControl.udpTimeout;


        do { if (((tempNaptTcpUdpFlowPtr)->next.tqe_next) != ((void *)0)) (tempNaptTcpUdpFlowPtr)->next.tqe_next->next.tqe_prev = (tempNaptTcpUdpFlowPtr)->next.tqe_prev; else (&DrvTbl.freeList.tcpudp)->tqh_last = (tempNaptTcpUdpFlowPtr)->next.tqe_prev; *(tempNaptTcpUdpFlowPtr)->next.tqe_prev = (tempNaptTcpUdpFlowPtr)->next.tqe_next; (&DrvTbl.freeList.tcpudp)->tqh_count--;} while (0);
        do { if (((tempNaptTcpUdpFlowPtr)->next.tqe_next = (&DrvTbl.inuseList.tcpudp)->tqh_first) != ((void *)0)) (&DrvTbl.inuseList.tcpudp)->tqh_first->next.tqe_prev = &(tempNaptTcpUdpFlowPtr)->next.tqe_next; else (&DrvTbl.inuseList.tcpudp)->tqh_last = &(tempNaptTcpUdpFlowPtr)->next.tqe_next; (&DrvTbl.inuseList.tcpudp)->tqh_first = (tempNaptTcpUdpFlowPtr); (tempNaptTcpUdpFlowPtr)->next.tqe_prev = &(&DrvTbl.inuseList.tcpudp)->tqh_first; (&DrvTbl.inuseList.tcpudp)->tqh_count++;} while (0);
        do { (tempNaptTcpUdpFlowPtr)->nextOut.sle_next = (&DrvTbl.tcpudp[outIdx].list[2])->slh_first; (&DrvTbl.tcpudp[outIdx].list[2])->slh_first = (tempNaptTcpUdpFlowPtr); } while (0);
        do { (tempNaptTcpUdpFlowPtr)->nextIn.sle_next = (&DrvTbl.tcpudp[inIdx].list[3])->slh_first; (&DrvTbl.tcpudp[inIdx].list[3])->slh_first = (tempNaptTcpUdpFlowPtr); } while (0);
# 11432 "rtl8651_tblDrv.c"
        if ( assigned & 0x0020 )
        {
                tempNaptTcpUdpFlowPtr->dosEnCount = 1;

                if ( isTcp )
                {
                        if ( assigned & 0x0040 )
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalTcpCnt++;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedTcpCnt++;
                } else
                {
                        if ( assigned & 0x0040 )
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalUdpCnt++;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedUdpCnt++;
                }

                if ( assigned & 0x0040 )
                {
                        tempNaptTcpUdpFlowPtr->dosFromInternal = 1;

                        _rtl8651_dosSrcConnCtrlUpdateConnection(0, isTcp, insideLocalIpAddr);
                }else
                {
                        tempNaptTcpUdpFlowPtr->dosFromInternal = 0;

                        _rtl8651_dosSrcConnCtrlUpdateConnection(0, isTcp, dstIpAddr);
                }
        }


        rtl8651_tblDrvNaptCounter.drvAddCount++;
        return tempNaptTcpUdpFlowPtr;
}
# 11480 "rtl8651_tblDrv.c"
int32 _rtl8651_delNaptAlgConnection( rtl8651_tblDrv_naptTcpUdpFlowEntry_t *delConn )
{
        rtl8651DrvNaptLine_t *outLine, *inLine;

        do {} while (0);

        if ( delConn->inListType!=3 ||
             delConn->outListType!=2 )
        {
                printk("[%s:%d] assert error! delConn->inListType=%d delConn->inListType=%d\n",
                               "rtl8651_tblDrv.c", 11490, delConn->inListType, delConn->outListType );
                return -1;
        }
# 11506 "rtl8651_tblDrv.c"
        if ( candidateToBeFreed == delConn )
        {
                candidateToBeFreed = ((void *)0);
        }



        if ( delConn->dosEnCount == 1 )
        {



                _rtl8651_dosSrcConnCtrlUpdateConnection(1, delConn->tcp,
                        (delConn->dosFromInternal)?(delConn->insideLocalIpAddr):(delConn->dstIpAddr));

                if ( delConn->tcp )
                {
                        if ( delConn->dosFromInternal )
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalTcpCnt--;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedTcpCnt--;
                }
                else
                {
                        if ( delConn->dosFromInternal )
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalUdpCnt--;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedUdpCnt--;
                }
        }

        inLine = &DrvTbl.tcpudp[delConn->inboundTblIdx];
        outLine = &DrvTbl.tcpudp[delConn->outboundTblIdx];

        do { if ((&inLine->list[3])->slh_first == (delConn)) { do { ((&inLine->list[3]))->slh_first = ((&inLine->list[3]))->slh_first->nextIn.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&inLine->list[3])->slh_first; while( curelm->nextIn.sle_next != (delConn) ) curelm = curelm->nextIn.sle_next; curelm->nextIn.sle_next = curelm->nextIn.sle_next->nextIn.sle_next; } } while (0);

        do { if ((&outLine->list[2])->slh_first == (delConn)) { do { ((&outLine->list[2]))->slh_first = ((&outLine->list[2]))->slh_first->nextOut.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&outLine->list[2])->slh_first; while( curelm->nextOut.sle_next != (delConn) ) curelm = curelm->nextOut.sle_next; curelm->nextOut.sle_next = curelm->nextOut.sle_next->nextOut.sle_next; } } while (0);



        memset(delConn, 0, ((size_t) &((struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *)0)->next));
        do {} while (0);
        delConn->outboundTblIdx = delConn->outListType = -1;
        delConn->inboundTblIdx = delConn->inListType = -1;
        do { if (((delConn)->next.tqe_next) != ((void *)0)) (delConn)->next.tqe_next->next.tqe_prev = (delConn)->next.tqe_prev; else (&DrvTbl.inuseList.tcpudp)->tqh_last = (delConn)->next.tqe_prev; *(delConn)->next.tqe_prev = (delConn)->next.tqe_next; (&DrvTbl.inuseList.tcpudp)->tqh_count--;} while (0);
        do { if (((delConn)->next.tqe_next = (&DrvTbl.freeList.tcpudp)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.tcpudp)->tqh_first->next.tqe_prev = &(delConn)->next.tqe_next; else (&DrvTbl.freeList.tcpudp)->tqh_last = &(delConn)->next.tqe_next; (&DrvTbl.freeList.tcpudp)->tqh_first = (delConn); (delConn)->next.tqe_prev = &(&DrvTbl.freeList.tcpudp)->tqh_first; (&DrvTbl.freeList.tcpudp)->tqh_count++;} while (0);

        return 0;
}
# 11575 "rtl8651_tblDrv.c"
ipaddr_t _rtl8651_getNaptInsideGlobalIpAddr(int8 isTcp, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort, ipaddr_t dstIpAddr, uint16 dstPort)
{



        rtl8651_tblDrv_ipEntry_t *ipEntry;
        int i;

        for( i = 0; i < 16; i++ )
        {
                ipEntry = &DrvTbl.iptbl[i];

                if ( ipEntry->valid==0 ) continue;
                if (( ipEntry->type == 0x00 ) )
                        return ipEntry->extip;
        }

        return 0;
}
# 11610 "rtl8651_tblDrv.c"
static int32 _rtl8651_selectNaptPortOffset(uint32 tblIdx, uint32 isTcp, ipaddr_t wantedIp, uint16 *offset)
{
        uint32 mask[2];
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *thisConn;
        rtl8651DrvNaptLine_t *tcpudpPtr;
        uint32 maxUsed=0, thisOffset;
        int32 i;
        isTcp = (isTcp?1:0);
        tcpudpPtr = &DrvTbl.tcpudp[tblIdx];

        do {} while (0);
        do {} while (0);

        mask[0] = mask[1] = 0;

        if(tblIdx==0)
                mask[0]=1;


        {
                rtl8651_tblDrv_networkIntfTable_t *netif_t;
                rtl8651_tblDrv_naptServerPortEntry_t *servPort_t;
                uint32 netIdx;

                if (_rtl8651_extIpAddr(wantedIp, &netIdx) == 0 ||
                    _rtl8651_isNaptMapping(wantedIp) == 0)
                {
                        GET_NETWORK_INTERFACE(extIfName,&netIdx);

                }

                netif_t = &DrvTbl.netIface[netIdx];
                do {} while (0);

                for((servPort_t) = (&netif_t->nextNaptServerPort)->slh_first; (servPort_t); (servPort_t) = (servPort_t)->nextServerPort.sle_next)
                {
                        if ( servPort_t->tcp == isTcp &&
                             servPort_t->globalIp == wantedIp )
                        {
                                int32 firstPort, lastPort, port;


                                firstPort = ( servPort_t->globalPort & (1024 -1) ) + tblIdx;
                                if ( firstPort > servPort_t->globalPort ) firstPort += 1024;


                                lastPort = ( servPort_t->endGlobalPort & (1024 -1) ) + tblIdx;
                                if ( lastPort > servPort_t->endGlobalPort ) lastPort -= 1024;


                                for( port = firstPort;
                                     port <= lastPort;
                                     port += 1024 )
                                {
                                        thisOffset = ( port >> 10 );
                                        mask[thisOffset>>5] |= ( (uint32)1 << (thisOffset&0x1f) );
                                        if( thisOffset > maxUsed )
                                                maxUsed = thisOffset;
                                }
                        }
                }
        }


        for( i = 1; i < 8; i+=2 )
        {
                for((thisConn) = (&tcpudpPtr->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextIn.sle_next)
                {
                        do {} while (0);
                        if ( thisConn->insideGlobalIpAddr != wantedIp ) continue;

                        thisOffset = ( thisConn->insideGlobalPort >> 10 );
                        mask[thisOffset>>5] |= ( (uint32)1 << (thisOffset&0x1f) );
                        if( thisOffset > maxUsed )
                                maxUsed = thisOffset;
                }
        }


        if ( rtl8651GlobalControl.l4PortRangeStart == rtl8651GlobalControl.l4PortRangeEnd )
        {

                if ( ( mask[rtl8651GlobalControl.l4PortRangeStart>>5] &
                       ((uint32)1<<(rtl8651GlobalControl.l4PortRangeStart&0x1f) ) ) == 0 )
                {
                        *offset = rtl8651GlobalControl.l4PortRangeStart;
                        return 0;
                }

                return -1;
        }
        else
        {
                uint16 candidate = maxUsed + 1;
                uint8 count = 0;

                if ( candidate < rtl8651GlobalControl.l4PortRangeStart )
                        candidate = rtl8651GlobalControl.l4PortRangeStart;

                do
                {
                        if(candidate>rtl8651GlobalControl.l4PortRangeEnd)
                                candidate=rtl8651GlobalControl.l4PortRangeStart;


                        if ( ( mask[candidate>>5] &
                               ((uint32)1<<(candidate&0x1f)) ) == 0 )
                        {
                                *offset = candidate;
                                return 0;
                        }
                        candidate++, count++;
                } while ( count < (rtl8651GlobalControl.l4PortRangeEnd- rtl8651GlobalControl.l4PortRangeStart+1) );
        }

        return -1;
}
# 11738 "rtl8651_tblDrv.c"
void _rtl8651_NaptSafeSwapToAsic( rtl8651_tblDrv_naptTcpUdpFlowEntry_t *drvEntry )
{
        rtl8651DrvNaptLine_t *thisLine;
        rtl8651_tblDrv_naptTcpUdpFlowEntry_t *asicCache;

        do {} while (0);

        if ( drvEntry->pureSoftware ) return;


        if ( drvEntry->hashing == 1 )
        {

                do {} while (0);

                thisLine = &DrvTbl.tcpudp[drvEntry->inboundTblIdx];
                asicCache = ((&(thisLine->list[0]))->slh_first);
                if( asicCache == ((void *)0) ) asicCache = ((&(thisLine->list[1]))->slh_first);


                if ( asicCache && asicCache != drvEntry )
                {
                        if ( asicCache->hashing == 1 )
                        {

                                _rtl8651_changeNaptFlowListType( asicCache, 5, 4 );
                        }
                        else
                        {

                                if ( asicCache->inboundTblIdx == drvEntry->inboundTblIdx )
                                        _rtl8651_changeNaptFlowListType( asicCache, 5, asicCache->outListType );
                                if ( asicCache->outboundTblIdx == drvEntry->outboundTblIdx )
                                        _rtl8651_changeNaptFlowListType( asicCache, asicCache->inListType, 4 );
                        }
                }


                _rtl8651_changeNaptFlowListType( drvEntry, 1, 0 );
        }
        else
        {


                int bInboundAmbiguous, bOutboundAmbiguous;
                int bInboundAsicEmpty, bOutboundAsicEmpty;
                _rtl8651_AvoidAmbiguousHash2InAsic( drvEntry, &bInboundAmbiguous, &bOutboundAmbiguous, &bInboundAsicEmpty, &bOutboundAsicEmpty );


                if ( bInboundAmbiguous == 0 )
                {

                        thisLine = &DrvTbl.tcpudp[drvEntry->inboundTblIdx];
                        asicCache = ((&(thisLine->list[0]))->slh_first);
                        if( asicCache == ((void *)0) ) asicCache = ((&(thisLine->list[1]))->slh_first);


                        if ( asicCache && asicCache != drvEntry )
                        {
                                if ( asicCache->hashing == 1 )
                                {

                                        _rtl8651_changeNaptFlowListType( asicCache, 5, 4 );
                                }
                                else
                                {

                                        if ( asicCache->inboundTblIdx == drvEntry->inboundTblIdx )
                                                _rtl8651_changeNaptFlowListType( asicCache, 5, asicCache->outListType );
                                        if ( asicCache->outboundTblIdx == drvEntry->inboundTblIdx )
                                                _rtl8651_changeNaptFlowListType( asicCache, asicCache->inListType, 4 );
                                }
                        }


                        _rtl8651_changeNaptFlowListType( drvEntry, 1, drvEntry->outListType );
                }



                if ( bOutboundAmbiguous == 0 )



                {

                        thisLine = &DrvTbl.tcpudp[drvEntry->outboundTblIdx];
                        asicCache = ((&(thisLine->list[0]))->slh_first);
                        if( asicCache == ((void *)0) ) asicCache = ((&(thisLine->list[1]))->slh_first);


                        if ( asicCache && asicCache != drvEntry )
                        {
                                if ( asicCache->hashing == 1 )
                                {

                                        _rtl8651_changeNaptFlowListType( asicCache, 5, 4 );
                                }
                                else
                                {

                                        if ( asicCache->inboundTblIdx == drvEntry->outboundTblIdx )
                                                _rtl8651_changeNaptFlowListType( asicCache, 5, asicCache->outListType );
                                        if ( asicCache->outboundTblIdx == drvEntry->outboundTblIdx )
                                                _rtl8651_changeNaptFlowListType( asicCache, asicCache->inListType, 4 );
                                }
                        }


                        _rtl8651_changeNaptFlowListType( drvEntry, drvEntry->inListType, 0 );
                }
        }


        rtl8651_tblDrvNaptCounter.threadWriteBackCount++;
}
# 11865 "rtl8651_tblDrv.c"
int32 _rtl8651_getUsableExtPortWithIndex( uint32 idx, uint32 isTcp, ipaddr_t wantedIP, uint16 *ExtPort )
{
        uint16 portOffset;

        if ( _rtl8651_selectNaptPortOffset( idx, isTcp, wantedIP, &portOffset ) != 0 )
        {
                return -3001;
        }
        *ExtPort = ( portOffset << 10 ) + idx;

        return 0;
}
# 11895 "rtl8651_tblDrv.c"
int8 _rtl8651_getUsableExtIpAndPort(int8 isTcp, ipaddr_t sip, uint16 sport, ipaddr_t dip, uint16 dport, ipaddr_t *extip, uint16 *extport)
{
        uint32 flowTblIdx;
        uint16 offset;
        ipaddr_t extIpSelected;

        do {} while (0);

        extIpSelected= _rtl8651_getNaptInsideGlobalIpAddr(isTcp, sip, sport, dip, dport);
        if( extIpSelected == 0 )
                return -1;
        *extip = extIpSelected;

        flowTblIdx = rtl8651_naptTcpUdpTableIndex(isTcp, sip, sport, dip, dport);
        if(_rtl8651_selectNaptPortOffset(flowTblIdx, isTcp, extIpSelected, &offset) == -1)
                return -1;
        *extport = offset << 10 | flowTblIdx;
        do {} while (0);

        return 0;
}
# 11938 "rtl8651_tblDrv.c"
int32
_rtl8651_getOutboundNaptFlow( int8 isTcp, ipaddr_t sip, uint16 sport, ipaddr_t dip, uint16 dport,
                              struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **ppEntry )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *pEntry;
        int32 idx1, idx1_loop;
        int32 idx2;
        int32 ret;







        if ( !(ppEntry ) ||
             !(dip!=0 ))
                return -1;
# 11979 "rtl8651_tblDrv.c"
        pEntry = *ppEntry;
        *ppEntry = ((void *)0);

        idx1 = rtl8651_naptTcpUdpTableIndex( isTcp, sip, sport, dip, dport );

        if (enable4WayHash == 1)
        {

                int32 i;


                idx1_loop = idx1;
                for( i = 0; i < 4; i++ )
                {

                        if ( ( pEntry = _rtl8651_findNaptConnection( idx1_loop, isTcp, sip, sport, dip, dport ) ) ) goto found;
                        idx1_loop = ( (idx1_loop&~0x0003) | ((idx1_loop+1)&0x0003) );
                }

                idx2 = rtl8651_naptTcpUdpTableIndex( isTcp, sip, sport, 0, 0 );
                if ( ( pEntry = _rtl8651_findNaptConnection( idx2, isTcp|(1<<1), sip, sport, dip, dport ) ) ) goto found;
        }
        else
        {



                if ( ( pEntry = _rtl8651_findNaptConnection( idx1, isTcp, sip, sport, dip, dport ) ) ) goto found;
                idx2 = rtl8651_naptTcpUdpTableIndex( isTcp, sip, sport, 0, 0 );
                if ( ( pEntry = _rtl8651_findNaptConnection( idx2, isTcp|(1<<1), sip, sport, dip, dport ) ) ) goto found;
        }






        ret = -3;
        goto out;

found:
# 12038 "rtl8651_tblDrv.c"
        if ( pEntry->tcp == 0 )
                pEntry->age = rtl8651GlobalControl.udpTimeout;

        *ppEntry = pEntry;






        ret = 0;

out:
# 12074 "rtl8651_tblDrv.c"
        return ret;
}
# 12096 "rtl8651_tblDrv.c"
int32
_rtl8651_getInboundNaptFlow( int8 isTcp, ipaddr_t gip, uint16 gport, ipaddr_t dip, uint16 dport,
                             struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s **ppEntry )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *pEntry;
        int32 ret;
# 12110 "rtl8651_tblDrv.c"
        if (!(gip!=0 ) ||
            !(ppEntry ))
                return -1;
# 12136 "rtl8651_tblDrv.c"
        pEntry = *ppEntry;
        *ppEntry = ((void *)0);


        if ( ( pEntry = _rtl8651_findNaptConnectionByExtIpPort( isTcp, gip, gport, dip, dport ) ) ) goto found;
        if ( ( pEntry = _rtl8651_findNaptConnectionByExtIpPort( isTcp|(1<<1), gip, gport, 0, 0 ) ) ) goto found;






        ret = -3;
        goto out;

found:
# 12170 "rtl8651_tblDrv.c"
        if ( pEntry->tcp == 0 )
                pEntry->age = rtl8651GlobalControl.udpTimeout;

        *ppEntry = pEntry;






        ret = 0;

out:
# 12206 "rtl8651_tblDrv.c"
        return ret;
}
# 12220 "rtl8651_tblDrv.c"
int32 _rtl8651_updateNaptConnection( rtl8651_tblDrv_naptTcpUdpFlowEntry_t *drvEntry,
                                     int8 tcpstate, uint32 age )
{

        int32 retval = 0;





        do {} while (0);
        do {} while (0);


        if ( tcpstate != 0 ) drvEntry->tcpFlag = tcpstate - 1;
        drvEntry->age = age;


        drvEntry->pps++;


        if ( pureSoftFwd == 1 )
        {
                retval = 0;
                goto out;
        }


        if ( _enableSmartNaptSwappingByLoad )
        {

                if ( drvEntry->pps >= _smartNaptSwappingThresholdCdrouter )
                {

                        _rtl8651_NaptSafeSwapToAsic( drvEntry );
                        drvEntry->holdForCdrouter = 0;
# 12273 "rtl8651_tblDrv.c"
                }


                if ( ( drvEntry->tcp && drvEntry->pps >= _smartNaptSwappingThresholdTcp ) ||
                     ( drvEntry->tcp==0 && drvEntry->pps >= _smartNaptSwappingThresholdUdp ) )
                {

                        if ( drvEntry->inListType!=1 ||
                             drvEntry->outListType!=0 )
                        {
                                _rtl8651_NaptSafeSwapToAsic( drvEntry );
                                drvEntry->newlyAddedHash2Udp = 0;
# 12302 "rtl8651_tblDrv.c"
                        }
                }
        }


        if ( drvEntry->connectionType == 1 )
        {

                retval = 0;
                goto out;
        }

        if ( drvEntry->hashing == 1 )
        {
                do {} while (0);


                if ( drvEntry->outListType == 0 )
                {
# 12343 "rtl8651_tblDrv.c"
                }
                else
                {





                        if ( tcpstate == 5 &&
                             drvEntry->holdForCdrouter==0 &&
                             _rtl8651_NaptEntryIsEmpty( drvEntry->outboundTblIdx ) )
                        {
                                _rtl8651_NaptSafeSwapToAsic( drvEntry );
# 12370 "rtl8651_tblDrv.c"
                        }
                }


                if ( tcpstate == 8 )
                {
                        drvEntry->age = age = rtl8651GlobalControl.tcpFinTimeout;
                        retval = 0;
                        goto out;
                }

        }
        else if ( drvEntry->hashing == 2 )
        {





                if ( tcpstate == 5 &&
                     drvEntry->holdForCdrouter==0 &&
                     ( _rtl8651_NaptEntryIsEmpty( drvEntry->inboundTblIdx ) ||
                       _rtl8651_NaptEntryIsEmpty( drvEntry->outboundTblIdx ) ) )
                {
                        _rtl8651_NaptSafeSwapToAsic( drvEntry );
# 12409 "rtl8651_tblDrv.c"
                }


                if ( tcpstate == 8 )
                {
                        drvEntry->age = age = rtl8651GlobalControl.tcpFinTimeout;
                        retval = 0;
                        goto out;
                }
# 12432 "rtl8651_tblDrv.c"
                if ( tcpstate > 5 )
                {
                        _rtl8651_changeNaptFlowListType( drvEntry, 5, 4 );
# 12453 "rtl8651_tblDrv.c"
                }
        }
# 12466 "rtl8651_tblDrv.c"
        else
        {
                do {} while (0);

        }

out:





        return retval;
}
# 12708 "rtl8651_tblDrv.c"
int32 _rtl8651_setl4NaptFindEmptyAsicRetry( uint16 retry )
{
        if ( retry > 1024 ) return -6;

        rtlglue_drvMutexLock();
        rtl8651GlobalControl.l4NaptFindEmptyAsicRetry = retry;
        rtlglue_drvMutexUnlock();

        return 0;
}
# 12727 "rtl8651_tblDrv.c"
static int32
_rtl8651_NaptEntryIsInUse( uint16 tblIndex )
{

        rtl8651DrvNaptLine_t *line;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *asicCached;

        line = &DrvTbl.tcpudp[tblIndex];


        asicCached = ((&(line->list[1]))->slh_first);
        if ( asicCached == ((void *)0) ) asicCached = ((&(line->list[0]))->slh_first);

        return ( asicCached != ((void *)0) ) ?1 :0;
}
# 12751 "rtl8651_tblDrv.c"
static int32
_rtl8651_NaptEntryIsEmpty( uint16 tblIndex )
{
        return !_rtl8651_NaptEntryIsInUse( tblIndex );
}



void _rtl8651_derefHash2NexthopCount( uint16 tblIndex, rtl8651DrvNaptLine_t *naptLine,
                                      rtl8651_tblDrv_naptTcpUdpFlowEntry_t *entry,
                                      int32 cleanIn, int32 cleanOut )
{

        rtl8651_tblDrv_nextHopEntry_t *def_next;
        ipaddr_t nexthop = (ipaddr_t)((void *)0);
        int32 retval;

        if ( ( def_next = _rtl8651_getDefaultNextHop() ) ) nexthop = def_next->nexthop;


        if ( entry->hashing == 2 )
        {
                if ( entry->inboundTblIdx == tblIndex &&
                     entry->inListType == 1 &&
                     cleanIn )
                {
                        retval = _rtl8651_delHash2FromNexthop( entry->interfaceRoute? entry->dstIpAddr: 0, entry->insideGlobalIpAddr );
                        do {} while (0);
                        entry->inExtIpIdx = -1;
                }

                if ( entry->outboundTblIdx == tblIndex &&
                     entry->outListType == 0 &&
                     cleanOut )
                {
                        retval = _rtl8651_delHash2FromNexthop( entry->interfaceRoute? entry->dstIpAddr: 0, entry->insideGlobalIpAddr );
                        do {} while (0);
                        entry->outExtIpIdx = -1;
                }
        }

        _rtl8651_setNaptEntry( tblIndex, naptLine, ((void *)0), 0 );
}
# 12871 "rtl8651_tblDrv.c"
int32 _rtl8651_changeNaptIpAndPort( struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * thisFlow,
                                    ipaddr_t newIntIp, uint16 newIntPort,
                                    ipaddr_t newExtIp, uint16 newExtPort,
                                    ipaddr_t newRemIp, uint16 newRemPort
                                    )
{
        ipaddr_t orgIntIp;
        uint16 orgIntPort;
        ipaddr_t orgExtIp;
        uint16 orgExtPort;
        ipaddr_t orgRemIp;
        uint16 orgRemPort;
        rtl8651DrvNaptLine_t *orgInLine, *newInLine;
        rtl8651DrvNaptLine_t *orgOutLine, *newOutLine;
        int32 newIdx1, newIdx2;
        int32 orgInListType, orgOutListType;

        orgIntIp = thisFlow->insideLocalIpAddr;
        orgIntPort = thisFlow->insideLocalPort;
        orgExtIp = thisFlow->insideGlobalIpAddr;
        orgExtPort = thisFlow->insideGlobalPort;
        orgRemIp = thisFlow->dstIpAddr;
        orgRemPort = thisFlow->dstPort;
        orgInLine = &DrvTbl.tcpudp[thisFlow->inboundTblIdx];
        orgOutLine = &DrvTbl.tcpudp[thisFlow->outboundTblIdx];


        orgInListType = thisFlow->inListType;
        orgOutListType = thisFlow->outListType;
        if ( orgInListType==1 || orgOutListType==0 )
        {
                _rtl8651_changeNaptFlowListType( thisFlow, 5, 4 );
        }


        do { if ((&orgInLine->list[thisFlow->inListType])->slh_first == (thisFlow)) { do { ((&orgInLine->list[thisFlow->inListType]))->slh_first = ((&orgInLine->list[thisFlow->inListType]))->slh_first->nextIn.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&orgInLine->list[thisFlow->inListType])->slh_first; while( curelm->nextIn.sle_next != (thisFlow) ) curelm = curelm->nextIn.sle_next; curelm->nextIn.sle_next = curelm->nextIn.sle_next->nextIn.sle_next; } } while (0);
        do { if ((&orgOutLine->list[thisFlow->outListType])->slh_first == (thisFlow)) { do { ((&orgOutLine->list[thisFlow->outListType]))->slh_first = ((&orgOutLine->list[thisFlow->outListType]))->slh_first->nextOut.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&orgOutLine->list[thisFlow->outListType])->slh_first; while( curelm->nextOut.sle_next != (thisFlow) ) curelm = curelm->nextOut.sle_next; curelm->nextOut.sle_next = curelm->nextOut.sle_next->nextOut.sle_next; } } while (0);

        thisFlow->insideLocalIpAddr = newIntIp;
        thisFlow->insideLocalPort = newIntPort;
        thisFlow->insideGlobalIpAddr = newExtIp;
        thisFlow->insideGlobalPort = newExtPort;
        thisFlow->dstIpAddr = newRemIp;
        thisFlow->dstPort = newRemPort;

        newIdx1 = rtl8651_naptTcpUdpTableIndex( thisFlow->tcp,
                                                newIntIp, newIntPort,
                                                newRemIp, newRemPort );
        newIdx2 = rtl8651_naptTcpUdpTableIndex( thisFlow->tcp,
                                                newIntIp, newIntPort,
                                                0, 0 );

        if ( newIdx1 == ( newExtPort & (1024 -1) ) )
        {

                thisFlow->hashing = 1;
                thisFlow->inboundTblIdx = newIdx1;
                thisFlow->outboundTblIdx = newIdx1;
                thisFlow->selEIdx = 0;
        }
        else
        {

                thisFlow->hashing = 2;
                thisFlow->inboundTblIdx = newExtPort & (1024 -1);
                thisFlow->outboundTblIdx = newIdx2;
                thisFlow->selEIdx = newIdx2;
        }

        newInLine = &DrvTbl.tcpudp[thisFlow->inboundTblIdx];
        newOutLine = &DrvTbl.tcpudp[thisFlow->outboundTblIdx];


        do { (thisFlow)->nextIn.sle_next = (&newInLine->list[thisFlow->inListType])->slh_first; (&newInLine->list[thisFlow->inListType])->slh_first = (thisFlow); } while (0);
        do { (thisFlow)->nextOut.sle_next = (&newOutLine->list[thisFlow->outListType])->slh_first; (&newOutLine->list[thisFlow->outListType])->slh_first = (thisFlow); } while (0);


        _rtl8651_changeNaptFlowListType( thisFlow, orgInListType, orgOutListType );

        return 0;
}


char* strNaptFlowType[] =
{
        "AsicOut",
        "AsicIn",
        "AlgOut",
        "AlgIn",
        "CandOut",
        "CandIn",
};
# 12979 "rtl8651_tblDrv.c"
int32 _rtl8651_changeNaptFlowListType( struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * thisFlow,
                                              uint8 inListType, uint8 outListType )
{
        uint8 bSymmetric;
        uint8 bInboundNoChange;
        uint8 bOutboundNoChange;
        rtl8651DrvNaptLine_t *inLine;
        rtl8651DrvNaptLine_t *outLine;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *asicIn;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *asicOut;
        int32 ret;
# 13003 "rtl8651_tblDrv.c"
        if ( thisFlow->pureSoftware &&
             (inListType==1||outListType==0) ) return -1;
# 13018 "rtl8651_tblDrv.c"
        bSymmetric = (thisFlow->hashing == 1);
# 13032 "rtl8651_tblDrv.c"
        bInboundNoChange = ( thisFlow->inListType == inListType );
        bOutboundNoChange = ( thisFlow->outListType == outListType );

        if ( bSymmetric )
        {



                if ( bInboundNoChange == 1 && bOutboundNoChange == 1 )
                {
                        return 0;
                }
                else if ( bInboundNoChange == 0 && bOutboundNoChange == 0 )
                {

                }
                else if ( bInboundNoChange == 0 && bOutboundNoChange == 1 )
                {


                        bOutboundNoChange = 0;
                        outListType = inListType & 0xfe;
                }
                else
                {


                        bInboundNoChange = 0;
                        inListType = outListType | 0x01;
                }

                do {} while (0);
        }
        else
        {

                if ( bInboundNoChange == 1 && bOutboundNoChange == 1 ) return 0;
        }


        inLine = &DrvTbl.tcpudp[thisFlow->inboundTblIdx];
        outLine = &DrvTbl.tcpudp[thisFlow->outboundTblIdx];


        asicIn = ((&(inLine->list[1]))->slh_first);
        if ( asicIn == ((void *)0) ) asicIn = ((&(inLine->list[0]))->slh_first);
        asicOut = ((&(outLine->list[0]))->slh_first);
        if ( asicOut == ((void *)0) ) asicOut = ((&(outLine->list[1]))->slh_first);


        if ( !( ( thisFlow->inListType == 1 || thisFlow->inListType == 5 ) &&
                ( thisFlow->outListType == 0 || thisFlow->outListType == 4 ) ) )
        {




                return -1;
        }
        if ( !( ( inListType == 1 || inListType == 5 ) &&
                ( outListType == 0 || outListType == 4 ) ) )
        {




                return -1;
        }


        if ( bSymmetric )
        {
                do {} while (0);


                if ( bInboundNoChange == 0 && bOutboundNoChange == 0 )
                {

                        if ( inListType == 1 && asicIn != ((void *)0) )
                        {

                        }
                        else
                        {






                                if ( thisFlow->hashing == 1 &&
                                     asicIn != ((void *)0) &&
                                     inListType != 1 &&
                                     thisFlow->inListType == 1 )
                                {
                                        rtl8651DrvNaptLine_t *thisLine;
                                        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s entry;
                                        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *pEntry=&entry;

                                        thisLine = &DrvTbl.tcpudp[thisFlow->inboundTblIdx];
                                        ret = _rtl8651_getNaptEntry( thisFlow->inboundTblIdx, thisLine, &pEntry, 1);
                                        do {} while (0);

                                        if ( pEntry->tcpFlag > thisFlow->tcpFlag )
                                        {

                                                thisFlow->tcpFlag = pEntry->tcpFlag;
                                                thisFlow->age = *tcpAgeTimer[thisFlow->tcpFlag+1];
                                        }
                                }

                                do { if ((&inLine->list[thisFlow->inListType])->slh_first == (thisFlow)) { do { ((&inLine->list[thisFlow->inListType]))->slh_first = ((&inLine->list[thisFlow->inListType]))->slh_first->nextIn.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&inLine->list[thisFlow->inListType])->slh_first; while( curelm->nextIn.sle_next != (thisFlow) ) curelm = curelm->nextIn.sle_next; curelm->nextIn.sle_next = curelm->nextIn.sle_next->nextIn.sle_next; } } while (0);
                                do { if ((&outLine->list[thisFlow->outListType])->slh_first == (thisFlow)) { do { ((&outLine->list[thisFlow->outListType]))->slh_first = ((&outLine->list[thisFlow->outListType]))->slh_first->nextOut.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&outLine->list[thisFlow->outListType])->slh_first; while( curelm->nextOut.sle_next != (thisFlow) ) curelm = curelm->nextOut.sle_next; curelm->nextOut.sle_next = curelm->nextOut.sle_next->nextOut.sle_next; } } while (0);
                                if ( inListType == 1 ) do {} while (0);
                                if ( outListType == 0 ) do {} while (0);
                                do { (thisFlow)->nextIn.sle_next = (&inLine->list[inListType])->slh_first; (&inLine->list[inListType])->slh_first = (thisFlow); } while (0);
                                do { (thisFlow)->nextOut.sle_next = (&outLine->list[outListType])->slh_first; (&outLine->list[outListType])->slh_first = (thisFlow); } while (0);

                                if ( inListType == 1 )
                                {
                                        thisFlow->inListType = inListType;
                                        thisFlow->outListType = outListType;

                                        ret = _rtl8651_setNaptEntry( thisFlow->inboundTblIdx, inLine, thisFlow, 1 );
                                        do {} while (0);
                                }
                                else
                                {


                                        if ( thisFlow->hashing == 2 )
                                                _rtl8651_derefHash2NexthopCount( thisFlow->inboundTblIdx, inLine, thisFlow, 1, 1 );
                                        else
                                                _rtl8651_setNaptEntry( thisFlow->inboundTblIdx, inLine, ((void *)0), 0 );

                                        thisFlow->inListType = inListType;
                                        thisFlow->outListType = outListType;
                                }
                        }
                }
                else
                {
                        do {} while (0);
                }
        }
        else
        {

                if ( bInboundNoChange == 0 )
                {

                        if ( inListType == 1 && asicIn != ((void *)0) )
                        {

                        }
                        else
                        {

                                do { if ((&inLine->list[thisFlow->inListType])->slh_first == (thisFlow)) { do { ((&inLine->list[thisFlow->inListType]))->slh_first = ((&inLine->list[thisFlow->inListType]))->slh_first->nextIn.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&inLine->list[thisFlow->inListType])->slh_first; while( curelm->nextIn.sle_next != (thisFlow) ) curelm = curelm->nextIn.sle_next; curelm->nextIn.sle_next = curelm->nextIn.sle_next->nextIn.sle_next; } } while (0);
                                if ( inListType == 1 ) do {} while (0);
                                do { (thisFlow)->nextIn.sle_next = (&inLine->list[inListType])->slh_first; (&inLine->list[inListType])->slh_first = (thisFlow); } while (0);

                                if ( inListType == 1 )
                                {
                                        thisFlow->inListType = inListType;


                                        if ( thisFlow->inboundTblIdx == thisFlow->outboundTblIdx &&
                                             inListType == outListType )
                                        {




                                                do {} while (0);
                                                do {} while (0);
                                        }
                                        else
                                        {
                                                ret = _rtl8651_setNaptEntry( thisFlow->inboundTblIdx, inLine, thisFlow, 1 );
                                                do {} while (0);
                                        }
                                }
                                else
                                {

                                        _rtl8651_derefHash2NexthopCount( thisFlow->inboundTblIdx, inLine, thisFlow, 1, 0 );

                                        thisFlow->inListType = inListType;
                                }
                        }
                }

                if ( bOutboundNoChange == 0 )
                {

                        if ( outListType == 0 && asicOut != ((void *)0) )
                        {

                        }
                        else
                        {

                                do { if ((&outLine->list[thisFlow->outListType])->slh_first == (thisFlow)) { do { ((&outLine->list[thisFlow->outListType]))->slh_first = ((&outLine->list[thisFlow->outListType]))->slh_first->nextOut.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&outLine->list[thisFlow->outListType])->slh_first; while( curelm->nextOut.sle_next != (thisFlow) ) curelm = curelm->nextOut.sle_next; curelm->nextOut.sle_next = curelm->nextOut.sle_next->nextOut.sle_next; } } while (0);
                                if ( outListType == 0 ) do {} while (0);
                                do { (thisFlow)->nextOut.sle_next = (&outLine->list[outListType])->slh_first; (&outLine->list[outListType])->slh_first = (thisFlow); } while (0);

                                if ( outListType == 0 )
                                {
                                        thisFlow->outListType = outListType;


                                        ret = _rtl8651_setNaptEntry( thisFlow->outboundTblIdx, outLine, thisFlow, 1 );
                                        do {} while (0);
                                }
                                else
                                {

                                        _rtl8651_derefHash2NexthopCount( thisFlow->outboundTblIdx, outLine, thisFlow, 0, 1 );

                                        thisFlow->outListType = outListType;
                                }
                        }
                }
        }

        return 0;
}
# 13272 "rtl8651_tblDrv.c"
static int32
_rtl8651_AppendToCandidateList( uint16 tblIndex,
                                struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tmp )
{

        tmp->inListType = 5;
        tmp->outListType = 4;
        tmp->inboundTblIdx = tblIndex;
        tmp->outboundTblIdx = tblIndex;





        do { (tmp)->nextIn.sle_next = (&DrvTbl.tcpudp[tblIndex].list[5])->slh_first; (&DrvTbl.tcpudp[tblIndex].list[5])->slh_first = (tmp); } while (0);
        do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[tblIndex].list[4])->slh_first; (&DrvTbl.tcpudp[tblIndex].list[4])->slh_first = (tmp); } while (0);

        return 0;
}
# 13305 "rtl8651_tblDrv.c"
static int32
_rtl8651_WriteToAsicNaptEntry( uint16 tblIndex,
                               struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tmp )
{
        rtl865x_tblAsicDrv_naptTcpUdpParam_t e;


        do {} while (0);


        if ( ((&DrvTbl.tcpudp[tblIndex].list[1])->slh_first) != ((void *)0) ) return -1;
        if ( ((&DrvTbl.tcpudp[tblIndex].list[0])->slh_first) != ((void *)0) ) return -1;

        memset( &e, 0 ,sizeof( e ) );

        e.ageSec = tmp->age;
        e.insideLocalIpAddr = tmp->insideLocalIpAddr;
        e.insideLocalPort = tmp->insideLocalPort;
        e.isStatic = tmp->isStatic;
        e.isTcp = tmp->tcp;
        e.offset = tmp->insideGlobalPort >> 10;

        if ( tmp->hashing == 1 )
        {
                e.isCollision = 0;
                e.isCollision2 = 0;
                e.isValid = 1;
                e.isDedicated = 0;
                e.selEIdx = 0;
                e.selExtIPIdx = 0;
                e.tcpFlag = tmp->tcpFlag;
        }
        else if ( tmp->hashing == 2 )
        {
                e.isCollision = 0;
                e.isCollision2 = 0;
                e.isValid = 1;
                e.isDedicated = 1;
                e.selEIdx = tblIndex;

                if ( tmp->inExtIpIdx < 0 )
                {
                        tmp->inExtIpIdx = _rtl8651_addHash2ToNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                        if ( tmp->inExtIpIdx == -1 )
                                return -1;
                }

                if ( tmp->outExtIpIdx < 0 )
                {
                        tmp->outExtIpIdx = _rtl8651_addHash2ToNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                        if ( tmp->outExtIpIdx == -1 )
                        {
                                _rtl8651_delHash2FromNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                                tmp->inExtIpIdx = -1;
                                return -1;
                        }
                }
                do {} while (0);
                e.selExtIPIdx = tmp->inExtIpIdx;

                if ( tmp->connectionType == 1 ) e.tcpFlag |= 4;
                e.tcpFlag |= 0;
                e.tcpFlag |= 0;
        }
        else
        {
                do {} while (0);
        }

        if ( rtl8651_setAsicNaptTcpUdpTable( 1, tblIndex, &e ) == 0 )
        {

                tmp->inListType = 1;
                tmp->outListType = 0;
                tmp->inboundTblIdx = tblIndex;
                tmp->outboundTblIdx = tblIndex;





                do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[tblIndex].list[1])->slh_first; (&DrvTbl.tcpudp[tblIndex].list[1])->slh_first = (tmp); } while (0);
                do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[tblIndex].list[0])->slh_first; (&DrvTbl.tcpudp[tblIndex].list[0])->slh_first = (tmp); } while (0);

                return 0;
        }
        else
        {
                return -1;
        }
}
# 13407 "rtl8651_tblDrv.c"
static int32
_rtl8651_HalfHardwareAccelerated( uint16 inIdx, uint16 outIdx,
                                  struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tmp )
{
        rtl865x_tblAsicDrv_naptTcpUdpParam_t e;


        if ( ((&DrvTbl.tcpudp[inIdx].list[1])->slh_first) != ((void *)0) ) return -1;
        if ( ((&DrvTbl.tcpudp[inIdx].list[0])->slh_first) != ((void *)0) ) return -1;

        memset( &e, 0 ,sizeof( e ) );

        e.ageSec = tmp->age;
        e.insideLocalIpAddr = tmp->insideLocalIpAddr;
        e.insideLocalPort = tmp->insideLocalPort;
        e.isStatic = tmp->isStatic;
        e.isTcp = tmp->tcp;
        e.offset = tmp->insideGlobalPort >> 10;

        do {} while (0);
        tmp->inExtIpIdx = _rtl8651_addHash2ToNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
        if ( tmp->inExtIpIdx == -1 )
                return -1;
        e.selExtIPIdx = tmp->inExtIpIdx;

        e.isCollision = 0;
        e.isCollision2 = 0;
        e.isValid = 1;
        e.isDedicated = 1;
        e.selEIdx = inIdx;

        if ( tmp->connectionType == 1 ) e.tcpFlag |= 4;
        e.tcpFlag |= 2;
        e.tcpFlag |= 0;

        if ( rtl8651_setAsicNaptTcpUdpTable( 1, inIdx, &e ) == 0 )
        {

                tmp->inListType = 1;
                tmp->outListType = 4;
                tmp->inboundTblIdx = inIdx;
                tmp->outboundTblIdx = outIdx;
                do {} while (0);
                do {} while (0);
                do { (tmp)->nextIn.sle_next = (&DrvTbl.tcpudp[inIdx].list[1])->slh_first; (&DrvTbl.tcpudp[inIdx].list[1])->slh_first = (tmp); } while (0);
                do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[outIdx].list[4])->slh_first; (&DrvTbl.tcpudp[outIdx].list[4])->slh_first = (tmp); } while (0);

                return 0;
        }
        else
        {
                return -1;
        }
}
# 13473 "rtl8651_tblDrv.c"
static int32
_rtl8651_Hash2TryHardwareAccelerated( uint16 inIdx, uint16 outIdx,
                                  struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tmp, uint8 bPortReused )
{
        rtl865x_tblAsicDrv_naptTcpUdpParam_t e;

        if ( inIdx == outIdx )
        {





                if ( tmp->pureSoftware ) goto L070;


                if ( tmp->holdForCdrouter )
                {



                        goto L070;
                }


                if ( tmp->tcp==0 )
                {



                        tmp->newlyAddedHash2Udp = 1;
                        goto L070;
                }

                if ( ((&DrvTbl.tcpudp[inIdx].list[1])->slh_first) == ((void *)0) &&
                     ((&DrvTbl.tcpudp[inIdx].list[0])->slh_first) == ((void *)0) )
                {

                        if ( bPortReused == 1 ) goto L070;

                        memset( &e, 0, sizeof( e ) );
                        e.ageSec = tmp->age;
                        e.insideLocalIpAddr = tmp->insideLocalIpAddr;
                        e.insideLocalPort = tmp->insideLocalPort;
                        e.isStatic = tmp->isStatic;
                        e.isTcp = tmp->tcp;
                        e.offset = tmp->insideGlobalPort >> 10;

                        do {} while (0);
                        do {} while (0);
                        tmp->inExtIpIdx = _rtl8651_addHash2ToNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                        if ( tmp->inExtIpIdx == -1 )
                        {



                                goto L070;
                        }

                        tmp->outExtIpIdx = _rtl8651_addHash2ToNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                        if ( tmp->outExtIpIdx == -1 )
                        {



                                goto L070;
                        }
                        do {} while (0);
                        e.selExtIPIdx = tmp->inExtIpIdx;

                        e.isCollision = 0;
                        e.isCollision2 = 0;
                        e.isValid = 1;
                        e.isDedicated = 1;
                        e.selEIdx = inIdx;

                        if ( tmp->connectionType == 1 ) e.tcpFlag |= 4;
                        e.tcpFlag |= 0;
                        e.tcpFlag |= 0;

                        if ( rtl8651_setAsicNaptTcpUdpTable( 1, inIdx, &e ) == 0 )
                        {

                                tmp->inListType = 1;
                                tmp->inboundTblIdx = inIdx;
                                tmp->outListType = 0;
                                tmp->outboundTblIdx = outIdx;





                                do {} while (0);
                                do {} while (0);
                                do { (tmp)->nextIn.sle_next = (&DrvTbl.tcpudp[inIdx].list[1])->slh_first; (&DrvTbl.tcpudp[inIdx].list[1])->slh_first = (tmp); } while (0);
                                do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[outIdx].list[0])->slh_first; (&DrvTbl.tcpudp[outIdx].list[0])->slh_first = (tmp); } while (0);



                        }
                        else
                        {

                                goto L070;
                        }

                }
                else
                {

                        L070:



                        tmp->inListType = 5;
                        tmp->inboundTblIdx = inIdx;
                        tmp->outListType = 4;
                        tmp->outboundTblIdx = outIdx;


                        if ( tmp->inExtIpIdx >= 0 )
                        {
                                _rtl8651_delHash2FromNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                                tmp->inExtIpIdx = -1;
                        }
                        if ( tmp->outExtIpIdx >= 0 )
                        {
                                _rtl8651_delHash2FromNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                                tmp->outExtIpIdx = -1;
                        }





                        do { (tmp)->nextIn.sle_next = (&DrvTbl.tcpudp[inIdx].list[5])->slh_first; (&DrvTbl.tcpudp[inIdx].list[5])->slh_first = (tmp); } while (0);
                        do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[outIdx].list[4])->slh_first; (&DrvTbl.tcpudp[outIdx].list[4])->slh_first = (tmp); } while (0);



                }

        }
        else
        {







                if ( tmp->pureSoftware ) goto L071;


                if ( tmp->holdForCdrouter )
                {



                        goto L071;
                }


                if ( tmp->tcp==0 )
                {



                        tmp->newlyAddedHash2Udp = 1;
                        goto L071;
                }

                if ( ((&DrvTbl.tcpudp[inIdx].list[1])->slh_first) == ((void *)0) &&
                     ((&DrvTbl.tcpudp[inIdx].list[0])->slh_first) == ((void *)0) )
                {

                        if ( bPortReused == 1 ) goto L071;

                        memset( &e, 0, sizeof( e ) );
                        e.ageSec = tmp->age;
                        e.insideLocalIpAddr = tmp->insideLocalIpAddr;
                        e.insideLocalPort = tmp->insideLocalPort;
                        e.isStatic = tmp->isStatic;
                        e.isTcp = tmp->tcp;
                        e.offset = tmp->insideGlobalPort >> 10;

                        tmp->inExtIpIdx = _rtl8651_addHash2ToNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                        if ( tmp->inExtIpIdx == -1 )
                        {



                                goto L071;
                        }
                        e.selExtIPIdx = tmp->inExtIpIdx;

                        e.isCollision = 0;
                        e.isCollision2 = 0;
                        e.isValid = 1;
                        e.isDedicated = 1;
                        e.selEIdx = inIdx;

                        if ( tmp->connectionType == 1 ) e.tcpFlag |= 4;
                        e.tcpFlag |= 2;
                        e.tcpFlag |= 0;

                        if ( rtl8651_setAsicNaptTcpUdpTable( 1, inIdx, &e ) == 0 )
                        {

                                tmp->inListType = 1;
                                tmp->inboundTblIdx = inIdx;
                                do {} while (0);
                                do { (tmp)->nextIn.sle_next = (&DrvTbl.tcpudp[inIdx].list[1])->slh_first; (&DrvTbl.tcpudp[inIdx].list[1])->slh_first = (tmp); } while (0);



                        }
                        else
                        {

                                goto L071;
                        }

                }
                else
                {

                        L071:


                        if ( tmp->inExtIpIdx >= 0 )
                        {
                                _rtl8651_delHash2FromNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                                tmp->inExtIpIdx = -1;
                        }

                        tmp->inListType = 5;
                        tmp->inboundTblIdx = inIdx;
                        do { (tmp)->nextIn.sle_next = (&DrvTbl.tcpudp[inIdx].list[5])->slh_first; (&DrvTbl.tcpudp[inIdx].list[5])->slh_first = (tmp); } while (0);



                }





                if ( tmp->pureSoftware ) goto L072;


                if ( tmp->holdForCdrouter )
                {



                        goto L072;
                }


                if ( tmp->tcp==0 )
                {



                        tmp->newlyAddedHash2Udp = 1;
                        goto L072;
                }

                if ( ((&DrvTbl.tcpudp[outIdx].list[1])->slh_first) == ((void *)0) &&
                     ((&DrvTbl.tcpudp[outIdx].list[0])->slh_first) == ((void *)0) )
                {


                        memset( &e, 0, sizeof( e ) );
                        e.ageSec = tmp->age;
                        e.insideLocalIpAddr = tmp->insideLocalIpAddr;
                        e.insideLocalPort = tmp->insideLocalPort;
                        e.isStatic = tmp->isStatic;
                        e.isTcp = tmp->tcp;
                        e.offset = tmp->insideGlobalPort >> 10;

                        tmp->outExtIpIdx = _rtl8651_addHash2ToNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                        if ( tmp->outExtIpIdx == -1 )
                        {



                                goto L072;
                        }
                        e.selExtIPIdx = tmp->outExtIpIdx;

                        e.isCollision = 0;
                        e.isCollision2 = 0;
                        e.isValid = 1;
                        e.isDedicated = 1;
                        e.selEIdx = inIdx;

                        if ( tmp->connectionType == 1 ) e.tcpFlag |= 4;
                        e.tcpFlag |= 2;
                        e.tcpFlag |= 1;

                        if ( rtl8651_setAsicNaptTcpUdpTable( 1, outIdx, &e ) == 0 )
                        {

                                tmp->outListType = 0;
                                tmp->outboundTblIdx = outIdx;
                                do {} while (0);
                                do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[outIdx].list[0])->slh_first; (&DrvTbl.tcpudp[outIdx].list[0])->slh_first = (tmp); } while (0);



                        }
                        else
                        {

                                goto L072;
                        }

                }
                else
                {

                        L072:


                        if ( tmp->outExtIpIdx >= 0 )
                        {
                                _rtl8651_delHash2FromNexthop( tmp->interfaceRoute? tmp->dstIpAddr: 0, tmp->insideGlobalIpAddr );
                                tmp->outExtIpIdx = -1;
                        }

                        tmp->outListType = 4;
                        tmp->outboundTblIdx = outIdx;
                        do { (tmp)->nextOut.sle_next = (&DrvTbl.tcpudp[outIdx].list[4])->slh_first; (&DrvTbl.tcpudp[outIdx].list[4])->slh_first = (tmp); } while (0);



                }
        }
# 13857 "rtl8651_tblDrv.c"
        return 0;
}

static int32 _rtl8651_delFlowFromMNQueue(rtl8651_tblDrvAclRule_t *rule, uint32 GroupId);
# 13870 "rtl8651_tblDrv.c"
int32 _rtl8651_delNaptConnection( rtl8651_tblDrv_naptTcpUdpFlowEntry_t *delConn )
{
        rtl8651DrvNaptLine_t *outLine, *inLine;





        do {} while (0);
        do {} while (0);
        do {} while (0);
        do {} while (0);
        do {} while (0);


        do {} while (0);






{
        int i;
        rtl8651_tblDrvAclRule_t rule;
        memset(&rule,0,sizeof(rule));
        rule.actionType_ = 0x02;

        rule.un_ty.L3L4._srcIpAddr = delConn->insideLocalIpAddr;
        rule.un_ty.L3L4._srcIpAddrMask = 0xffffffff;
        if(delConn->tcp)
        {
                rule.ruleType_ = 0x04;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = delConn->insideLocalPort;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = delConn->insideLocalPort;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 65535;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0;
        }
        else
        {
                rule.ruleType_= 0x05;
                rule.un_ty.L3L4.is.udp._srcPortUpperBound = delConn->insideLocalPort;
                rule.un_ty.L3L4.is.udp._srcPortLowerBound = delConn->insideLocalPort;
                rule.un_ty.L3L4.is.udp._dstPortUpperBound = 65535;
                rule.un_ty.L3L4.is.udp._dstPortLowerBound = 0;
        }

        for(i=0;i<32;i++)
        {
                if(alg_qosqid[0][i]!=0)
                {
                        int r;
                        r=_rtl8651_delFlowFromMNQueue(&rule, alg_qosqid[0][i]);

                }
        }

}
# 13940 "rtl8651_tblDrv.c"
        outLine = &DrvTbl.tcpudp[delConn->outboundTblIdx];

        do { if ((&outLine->list[delConn->outListType])->slh_first == (delConn)) { do { ((&outLine->list[delConn->outListType]))->slh_first = ((&outLine->list[delConn->outListType]))->slh_first->nextOut.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&outLine->list[delConn->outListType])->slh_first; while( curelm->nextOut.sle_next != (delConn) ) curelm = curelm->nextOut.sle_next; curelm->nextOut.sle_next = curelm->nextOut.sle_next->nextOut.sle_next; } } while (0);


        if( delConn->outListType == 0 )
        {

                do {} while (0);
                _rtl8651_derefHash2NexthopCount( delConn->outboundTblIdx, outLine, delConn, 0, 1 );
                { (&outLine->list[0])->slh_first = ((void *)0); };
                do {} while (0);
        }
# 13966 "rtl8651_tblDrv.c"
        if ( candidateToBeFreed == delConn )
        {
                candidateToBeFreed = ((void *)0);
        }



        if ( delConn->dosEnCount == 1 )
        {



                _rtl8651_dosSrcConnCtrlUpdateConnection(1, delConn->tcp,
                        (delConn->dosFromInternal)?(delConn->insideLocalIpAddr):(delConn->dstIpAddr));

                if ( delConn->tcp )
                {
                        if ( delConn->dosFromInternal )
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalTcpCnt--;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedTcpCnt--;
                }
                else
                {
                        if ( delConn->dosFromInternal )
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalUdpCnt--;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedUdpCnt--;
                }
        }




        inLine = &DrvTbl.tcpudp[delConn->inboundTblIdx];

        do { if ((&inLine->list[delConn->inListType])->slh_first == (delConn)) { do { ((&inLine->list[delConn->inListType]))->slh_first = ((&inLine->list[delConn->inListType]))->slh_first->nextIn.sle_next; } while (0); } else { struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *curelm = (&inLine->list[delConn->inListType])->slh_first; while( curelm->nextIn.sle_next != (delConn) ) curelm = curelm->nextIn.sle_next; curelm->nextIn.sle_next = curelm->nextIn.sle_next->nextIn.sle_next; } } while (0);


        if( delConn->inListType == 1 )
        {

                do {} while (0);
                _rtl8651_derefHash2NexthopCount( delConn->inboundTblIdx, inLine, delConn, 1, 0 );
                do {} while (0);
        }





        memset( delConn, 0, ((size_t) &((struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *)0)->next) );
        do {} while (0);
        delConn->outboundTblIdx = delConn->outListType = -1;
        delConn->inboundTblIdx = delConn->inListType = -1;
        do { if (((delConn)->next.tqe_next) != ((void *)0)) (delConn)->next.tqe_next->next.tqe_prev = (delConn)->next.tqe_prev; else (&DrvTbl.inuseList.tcpudp)->tqh_last = (delConn)->next.tqe_prev; *(delConn)->next.tqe_prev = (delConn)->next.tqe_next; (&DrvTbl.inuseList.tcpudp)->tqh_count--;} while (0);
        do { if (((delConn)->next.tqe_next = (&DrvTbl.freeList.tcpudp)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.tcpudp)->tqh_first->next.tqe_prev = &(delConn)->next.tqe_next; else (&DrvTbl.freeList.tcpudp)->tqh_last = &(delConn)->next.tqe_next; (&DrvTbl.freeList.tcpudp)->tqh_first = (delConn); (delConn)->next.tqe_prev = &(&DrvTbl.freeList.tcpudp)->tqh_first; (&DrvTbl.freeList.tcpudp)->tqh_count++;} while (0);





        return 0;
}
# 14080 "rtl8651_tblDrv.c"
static int32 _rtl8651_flushNaptConnection(void) {
        uint32 flowTblIdx, i=((&DrvTbl.inuseList.tcpudp)->tqh_count);
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * tempNaptTcpUdpFlowPtr;
        rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr;
        rtl8651DrvNaptLine_t *tcpudpPtr;


        tempNaptTcpUdpFlowPtr = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
        while(tempNaptTcpUdpFlowPtr){

                _rtl8651_delNaptConnection(tempNaptTcpUdpFlowPtr);
                tempNaptTcpUdpFlowPtr = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
        }


        for(i=0,tcpudpPtr=&DrvTbl.tcpudp[0];i<1024;i++,tcpudpPtr++) {
                int j;

                for(j=0; j < 8; j++)
                        { (&tcpudpPtr->list[j])->slh_first = ((void *)0); };
        }


        for(flowTblIdx=0; flowTblIdx<1024; flowTblIdx++)
                convert_setAsicNaptTcpUdpTable(1, 0, 0, flowTblIdx, 0, (0x0<<0), 0, 0, 0, 0, 0);


        for(flowTblIdx=0; flowTblIdx<32; flowTblIdx++) {
                while(DrvTbl.icmp[flowTblIdx]) {
                        tempNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
                        DrvTbl.icmp[flowTblIdx] = tempNaptIcmpFlowPtr->next;
                        tempNaptIcmpFlowPtr->next = DrvTbl.freeList.icmp;
                        DrvTbl.freeList.icmp = tempNaptIcmpFlowPtr;
                }
        }
        for(flowTblIdx=0; flowTblIdx<32; flowTblIdx++) {
                rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx] = 0;
                rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx] = 0;
                rtl8651NaptIcmpFlowNumberTable[flowTblIdx] = 0;
        }
        rtl8651ExistedNaptIcmpFlows = 0;
# 14130 "rtl8651_tblDrv.c"
        return 0;
}
# 14188 "rtl8651_tblDrv.c"
static int32 _rtl8651_flushNaptOldestConnection2( int32 NumWantedToBeFreed )
{
        int32 numFreed;
        int i;
        int retval;

        numFreed = 0;

        for( i = 0; i < NumWantedToBeFreed; i++ )
        {


                if ( candidateToBeFreed == ((void *)0) ) break;
# 14213 "rtl8651_tblDrv.c"
                if ( candidateToBeFreed->connectionType == 3 )
                {
                        retval = _rtl8651_delNaptAlgConnection( candidateToBeFreed );
                        do {} while (0);
                }
                else
                {



                        retval = _rtl8651_delNaptConnection( candidateToBeFreed );
                        do {} while (0);
                }

                candidateToBeFreed = ((void *)0);

                numFreed++;
        }

        return numFreed;
}
# 14311 "rtl8651_tblDrv.c"
static int32 _rtl8651_flushNaptHeadConnection( int32 NumWantedToBeFreed )
{
        int32 numFreed;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tempNaptTcpUdpFlowPtr;
        int i;
        int retval;

        numFreed = 0;

        for( i = 0; i < NumWantedToBeFreed; i++ )
        {

                tempNaptTcpUdpFlowPtr = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
                if ( tempNaptTcpUdpFlowPtr == ((void *)0) ) break;


                if ( tempNaptTcpUdpFlowPtr->connectionType == 3 )
                {
                        retval = _rtl8651_delNaptAlgConnection( tempNaptTcpUdpFlowPtr );
                        do {} while (0);
                }
                else
                {



                        retval = _rtl8651_delNaptConnection( tempNaptTcpUdpFlowPtr );
                        do {} while (0);
                }
                numFreed++;
        }

        return numFreed;
}
# 14357 "rtl8651_tblDrv.c"
void _rtl8651_removeNaptConnectionByExtIP( ipaddr_t ExtIp )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *naptflow;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *nextFlow;
        uint32 flowTblIdx;
        rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr;


        naptflow = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
        while(naptflow)
        {
                nextFlow = ((naptflow)->next.tqe_next);;
                if ( naptflow->insideGlobalIpAddr == ExtIp )
                        _rtl8651_delNaptConnection(naptflow);
                naptflow = nextFlow;
        }


        for(flowTblIdx=0; flowTblIdx<32; flowTblIdx++) {
                while(DrvTbl.icmp[flowTblIdx]) {
                        tempNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
                        DrvTbl.icmp[flowTblIdx] = tempNaptIcmpFlowPtr->next;
                        tempNaptIcmpFlowPtr->next = DrvTbl.freeList.icmp;
                        DrvTbl.freeList.icmp = tempNaptIcmpFlowPtr;
                }
        }
        for(flowTblIdx=0; flowTblIdx<32; flowTblIdx++) {
                rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx] = 0;
                rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx] = 0;
                rtl8651NaptIcmpFlowNumberTable[flowTblIdx] = 0;
        }
        rtl8651ExistedNaptIcmpFlows = 0;
}
# 14401 "rtl8651_tblDrv.c"
void _rtl8651_removeNaptConnectionBySrcIP( ipaddr_t sip )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *naptflow;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *nextFlow;
        rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr;
        uint32 flowTblIdx;


        naptflow = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
        while(naptflow)
        {
                nextFlow = ((naptflow)->next.tqe_next);;
                if ( naptflow->insideLocalIpAddr == sip )
                        _rtl8651_delNaptConnection(naptflow);
                naptflow = nextFlow;
        }


        for(flowTblIdx=0; flowTblIdx<32; flowTblIdx++) {
                while(DrvTbl.icmp[flowTblIdx]) {
                        tempNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
                        DrvTbl.icmp[flowTblIdx] = tempNaptIcmpFlowPtr->next;
                        tempNaptIcmpFlowPtr->next = DrvTbl.freeList.icmp;
                        DrvTbl.freeList.icmp = tempNaptIcmpFlowPtr;
                }
        }
        for(flowTblIdx=0; flowTblIdx<32; flowTblIdx++) {
                rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx] = 0;
                rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx] = 0;
                rtl8651NaptIcmpFlowNumberTable[flowTblIdx] = 0;
        }
        rtl8651ExistedNaptIcmpFlows = 0;
}
# 14447 "rtl8651_tblDrv.c"
int32 _rtl8651_removeNaptConnectionByIntIPandPort( int8 isTcp, ipaddr_t intIp, uint16 intPort )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *thisFlow;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *nextFlow;
        int32 delNo;

        delNo = 0;

        thisFlow = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
        while( thisFlow )
        {
                nextFlow = ((thisFlow)->next.tqe_next);;
                if ( thisFlow->tcp == isTcp &&
                     thisFlow->insideLocalIpAddr == intIp &&
                     thisFlow->insideLocalPort == intPort )
                {
                        delNo++;
                        _rtl8651_delNaptConnection( thisFlow );
                }
                thisFlow = nextFlow;
        }

        return delNo;
}
# 14481 "rtl8651_tblDrv.c"
int32 _rtl8651_removeNaptConnectionByIP( ipaddr_t ip )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *thisFlow;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *nextFlow;
        int32 delNo;

        delNo = 0;

        thisFlow = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
        while( thisFlow )
        {
                nextFlow = ((thisFlow)->next.tqe_next);;
                if ( thisFlow->insideLocalIpAddr == ip ||
                     thisFlow->dstIpAddr== ip )
                {
                        delNo++;
                        _rtl8651_delNaptConnection( thisFlow );
                }
                thisFlow = nextFlow;
        }

        return delNo;
}
# 14514 "rtl8651_tblDrv.c"
int32 _rtl8651_countNaptConnectionByIP( ipaddr_t ip, uint32 *tcpCnt, uint32 *udpCnt )
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *thisFlow;
        uint32 tcp;
        uint32 udp;

        tcp = 0;
        udp = 0;
# 14532 "rtl8651_tblDrv.c"
        thisFlow = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
        while( thisFlow )
        {
                if ( thisFlow->dosEnCount == 1 )
                {
                        if (( thisFlow->dosFromInternal && thisFlow->insideLocalIpAddr == ip ) ||
                                ( !thisFlow->dosFromInternal && thisFlow->dstIpAddr == ip ))
                        {
                                if ( thisFlow->tcp )
                                {
                                        tcp ++;
                                }
                                else
                                {
                                        udp ++;
                                }
                        }
                }
                thisFlow = ((thisFlow)->next.tqe_next);
        }





        if (tcpCnt)
        {
                *tcpCnt = tcp;
        }
        if (udpCnt)
        {
                *udpCnt = udp;
        }

        return 0;
}
# 14578 "rtl8651_tblDrv.c"
static int32
_rtl8651_FindEmptyASICEntry( uint16 *tblIndex )
{
        uint16 i;

        for( i = 0; i < rtl8651GlobalControl.l4NaptFindEmptyAsicRetry; i++ )
        {
                if ( _rtl8651_NaptEntryIsEmpty( *tblIndex ) )
                {
                        return 0;
                }

                *tblIndex = ( (*tblIndex) + 1 ) & ( 1024 - 1 );
        }
        return -1;
}



void _dump_naptEntry( rtl8651_tblDrv_naptTcpUdpFlowEntry_t* pe )
{
        printk("[%s] %s Int:%d.%d.%d.%d:%d Ext:%d.%d.%d.%d:%d Rem:%d.%d.%d.%d:%d\n",
                               pe->hashing==1?"H1":"H2",
                               pe->tcp?"TCP":"UDP",
                               pe->insideLocalIpAddr>>24, (pe->insideLocalIpAddr&0x00ff0000) >> 16,
                               (pe->insideLocalIpAddr&0x0000ff00)>>8, pe->insideLocalIpAddr&0x000000ff,
                               pe->insideLocalPort,
                               pe->insideGlobalIpAddr>>24, (pe->insideGlobalIpAddr&0x00ff0000) >> 16,
                               (pe->insideGlobalIpAddr&0x0000ff00)>>8, pe->insideGlobalIpAddr&0x000000ff,
                               pe->insideGlobalPort,
                               pe->dstIpAddr>>24, (pe->dstIpAddr&0x00ff0000) >> 16,
                               (pe->dstIpAddr&0x0000ff00)>>8, pe->dstIpAddr&0x000000ff,
                               pe->dstPort );

        printk("    %s age(%d) tcpflag(%d) inList:%s outList:%s\n",
                                (pe->connectionType==0)?"NOR":"SP",
                                pe->age, pe->tcpFlag,
                                pe->inListType==1?"ASIC_IN":
                                pe->inListType==5?"CAND_IN":
                                pe->inListType==3?"ALG_IN":"Uknown",
                                pe->outListType==0?"ASIC_OUT":
                                pe->outListType==4?"CAND_OUT":
                                pe->outListType==2?"ALG_OUT":"Uknown" );
}


void _dump_naptLine( uint16 inIdx, uint16 outIdx )
{
        rtl8651DrvNaptLine_t *thisNaptLine;
        rtl8651_tblDrv_naptTcpUdpFlowEntry_t *thisConn;
        uint32 i;

        printk( "Dump NaptLine -----\n" );
        thisNaptLine = &DrvTbl.tcpudp[inIdx];
        for( i = 1; i < 8; i += 2 )
        {
                printk( "idx[%d],list[%d]:\n", inIdx, i );
                for((thisConn) = (&thisNaptLine->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextIn.sle_next)
                {
                        _dump_naptEntry( thisConn );
                }
        }
        thisNaptLine = &DrvTbl.tcpudp[outIdx];
        for( i = 0; i < 8; i += 2 )
        {
                printk( "idx[%d],list[%d]:\n", outIdx, i );
                for((thisConn) = (&thisNaptLine->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextOut.sle_next)
                {
                        _dump_naptEntry( thisConn );
                }
        }
        printk( "-------------------\n" );
}
# 14692 "rtl8651_tblDrv.c"
int32 _rtl8651_AvoidAmbiguousHash2InAsic( rtl8651_tblDrv_naptTcpUdpFlowEntry_t *newConn,
                                          int *bInboundAmbiguous, int *bOutboundAmbiguous,
                                          int *bInboundAsicEmpty, int *bOutboundAsicEmpty )
{
        rtl8651DrvNaptLine_t *thisNaptLine;
        rtl8651_tblDrv_naptTcpUdpFlowEntry_t *thisConn;
        uint16 inIdx, outIdx;
        int32 i;

        *bInboundAmbiguous = *bOutboundAmbiguous = 0;
        *bInboundAsicEmpty = *bOutboundAsicEmpty = 1;


        inIdx = newConn->inboundTblIdx;
        thisNaptLine = &DrvTbl.tcpudp[inIdx];
        for( i = 1; i < 8; i += 2 )
        {
                for((thisConn) = (&thisNaptLine->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextIn.sle_next)
                {
                        if ( i == 1 ) *bInboundAsicEmpty = 0;
                        if ( thisConn == newConn ) continue;
                        if ( thisConn->tcp == newConn->tcp &&
                             thisConn->insideGlobalPort == newConn->insideGlobalPort )
                        {

                                if ( thisConn->insideLocalIpAddr != newConn->insideLocalIpAddr ||
                                     thisConn->insideLocalPort != newConn->insideLocalPort )
                                {

                                        *bInboundAmbiguous = 1;


                                        if ( i == 1 )
                                        {
                                                if ( thisConn->hashing == 2 )
                                                {

                                                        _rtl8651_changeNaptFlowListType( thisConn, 5, thisConn->outListType );
                                                        *bInboundAsicEmpty = 1;
                                                }
                                        }

                                        break;
                                }
                        }
                }
                if ( *bInboundAmbiguous == 1 ) break;
        }



        outIdx = newConn->outboundTblIdx;
        thisNaptLine = &DrvTbl.tcpudp[outIdx];
        for( i = 0; i < 8; i += 2 )
        {
                for((thisConn) = (&thisNaptLine->list[i])->slh_first; (thisConn); (thisConn) = (thisConn)->nextOut.sle_next)
                {
                        if ( i == 0 ) *bOutboundAsicEmpty = 0;
                        if ( thisConn == newConn ) continue;
                        if ( thisConn->tcp == newConn->tcp &&
                             thisConn->insideLocalIpAddr == newConn->insideLocalIpAddr &&
                             thisConn->insideLocalPort == newConn->insideLocalPort )
                        {

                                if ( thisConn->insideGlobalIpAddr != newConn->insideGlobalIpAddr ||
                                     thisConn->insideGlobalPort != newConn->insideGlobalPort )
                                {

                                        *bOutboundAmbiguous = 1;


                                        if ( i == 0 )
                                        {
                                                if ( thisConn->hashing == 2 )
                                                {

                                                        _rtl8651_changeNaptFlowListType( thisConn, thisConn->inListType, 4 );
                                                        *bOutboundAsicEmpty = 1;
                                                }
                                        }

                                        if ( newConn->outListType == 0 &&
                                             newConn->hashing == 2 )
                                        {




                                                _rtl8651_changeNaptFlowListType( newConn, newConn->inListType, 4 );
                                                *bOutboundAsicEmpty = 1;
                                        }

                                        break;
                                }
                                else if ( thisConn->insideGlobalIpAddr == newConn->insideGlobalIpAddr &&
                                          thisConn->insideGlobalPort == newConn->insideGlobalPort )
                                {






                                        _rtl8651_changeNaptFlowListType( newConn, newConn->inListType, 4 );
                                        *bOutboundAmbiguous = 1;
                                        *bOutboundAsicEmpty = 1;
                                }
                        }
                }
                if ( *bOutboundAmbiguous == 1 ) break;
        }
# 14817 "rtl8651_tblDrv.c"
        return 0;
}
# 14849 "rtl8651_tblDrv.c"
int32 _rtl8651_addNaptConnection(int8 fromDrv, int16 assigned, int8 flowType, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                        ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort, ipaddr_t dstIpAddr, uint16 dstPort)
{
# 14866 "rtl8651_tblDrv.c"
        uint16 idx1, idx2;
        uint16 inIdx, outIdx;
        uint32 isTcp = (flowType==0? 0: 1);
        uint16 foundIdx;
        uint8 bPortReused = 0;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *pe;
        int8 isExternal, is_gwip;
        uint32 interfaceRoute = 0;





        do {} while (0);



        do {} while (0);
        do {} while (0);





        if ( fromDrv == 0 ) assigned |= 0x0100;

        idx1 = rtl8651_naptTcpUdpTableIndex( isTcp, insideLocalIpAddr, insideLocalPort, dstIpAddr, dstPort );
        idx2 = rtl8651_naptTcpUdpTableIndex( isTcp, insideLocalIpAddr, insideLocalPort, 0, 0 );
# 14906 "rtl8651_tblDrv.c"
        rtl8651_tblDrvNaptCounter.addAttempts++;
# 14918 "rtl8651_tblDrv.c"
        if ((!(assigned & 0x0004)) && (_rtl8651_getIpInfo(insideLocalIpAddr, ((void *)0), &isExternal, &is_gwip)==((void *)0) || isExternal==1 || is_gwip == 1))
        {



                return -2712;
        }
# 14934 "rtl8651_tblDrv.c"
        if( dstIpAddr && _rtl8651_localServerIpAddr( dstIpAddr ) == 1 )
        {



                return -3000;
        }
# 14949 "rtl8651_tblDrv.c"
        if( assigned & 0x0001 )
        {
                if (_rtl8651_getIpInfo(*insideGlobalIpAddr, ((void *)0), &isExternal, &is_gwip) == ((void *)0) || isExternal == 0 || is_gwip == 0)
                {



                        return -3007;
                }
        }
# 14978 "rtl8651_tblDrv.c"
        if ( dstIpAddr != 0 && dstPort == 0 )
        {



                return -3006;
        }






        if ( ( assigned & 0x0100 ) == 0 )
        {



        }
        else if ( dstIpAddr != 0 && dstPort != 0 )
        {






                if( _rtl8651_findNaptConnection( idx1, isTcp, insideLocalIpAddr, insideLocalPort,
                                                              dstIpAddr, dstPort ) )
                {



                        return -3005;
                }

                if( ( assigned & 0x0001 ) &&
                    _rtl8651_findNaptConnectionByExtIpPort( isTcp, *insideGlobalIpAddr, *insideGlobalPort,
                                                            dstIpAddr, dstPort ) )
                {



                        return -3002;
                }
# 15040 "rtl8651_tblDrv.c"
        }
        else
        {






                struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *tmp;

                if( assigned & 0x0001 )
                {
                        for( tmp = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
                             tmp;
                             tmp = ((tmp)->next.tqe_next) )
                        {






                                if ( tmp->tcp==isTcp &&
                                     tmp->insideLocalIpAddr==insideLocalIpAddr &&
                                     tmp->insideLocalPort==insideLocalPort &&
                                     tmp->insideGlobalIpAddr==*insideGlobalIpAddr &&
                                     tmp->insideGlobalPort==*insideGlobalPort )
                                {



                                        return -3005;
                                }
                        }
                }
                else
                {



                }
# 15100 "rtl8651_tblDrv.c"
        }
# 15131 "rtl8651_tblDrv.c"
        if( assigned & 0x0001 )
        {



                if ( ( assigned & 0x0100 ) &&
                     _rtl8651_findNaptConnectionByExtIpPort( isTcp, *insideGlobalIpAddr, *insideGlobalPort,
                                                                dstIpAddr, dstPort ) != ((void *)0) )
                {



                        return -3002;
                }


                if ( _rtl8651_ExtPortIsShared( isTcp, *insideGlobalIpAddr, *insideGlobalPort, *insideGlobalPort ) )
                {
                        bPortReused = 1;
                }
        }
# 15160 "rtl8651_tblDrv.c"
        if ( (assigned & 0x0001) &&
             *insideGlobalIpAddr != 0 )
        {



        }
        else
        {
                ipaddr_t defExtIp;

                defExtIp = _rtl8651_getNaptInsideGlobalIpAddr( isTcp, insideLocalIpAddr, insideLocalPort,
                                                                     dstIpAddr, dstPort );

                if ( dstIpAddr != 0 )
                {


                        if ( defExtIp )
                        {
                                *insideGlobalIpAddr = defExtIp;
                        }
                        else
                        {




                                return -3008;
                        }
                }
                else
                {


                        if ( defExtIp )
                        {
                                *insideGlobalIpAddr = defExtIp;
                        }
                        else
                        {




                                return -3008;
                        }
                }




        }







        if ( dstIpAddr != 0 )
        {
                rtl8651_tblDrv_routeTable_t *rt;

                rt = _rtl8651_getRoutingEntry( dstIpAddr );
                if ( rt == ((void *)0) )
                {



                        return -3008;
                }

                interfaceRoute = rt->ifrt_flag;


                if ( interfaceRoute )
                {
                        if ( DrvTbl.route[rtl8651_tblDrvPara.routingTableSize-1].valid )
                        {

                                if ( dstIpAddr == DrvTbl.route[rtl8651_tblDrvPara.routingTableSize-1].nextHop )
                                {
                                        interfaceRoute = 0;
                                }
                        }
                        else
                        {

                        }
                }


        }





        if ( assigned & 0x0020 )
        {
                do {} while (0);


                if ( _rtl8651_dosNaptConnCheck(
                        isTcp,
                        (assigned & 0x0040)?insideLocalIpAddr:dstIpAddr,
                        (assigned & 0x0040)?0:1) != 0)
                {



                        return -3011;
                }
        }





        if ( ( pe = ((&DrvTbl.freeList.tcpudp)->tqh_first) ) == ((void *)0) )
        {



                if ( _rtl8651_flushNaptOldestConnection2( 1 ) >= 1 )
                {




                        pe = ((&DrvTbl.freeList.tcpudp)->tqh_first);
                        do {} while (0);
                }
# 15306 "rtl8651_tblDrv.c"
                else if ( _rtl8651_flushNaptHeadConnection( 1 ) >= 1 )
                {




                        pe = ((&DrvTbl.freeList.tcpudp)->tqh_first);
                        do {} while (0);
                }
# 15326 "rtl8651_tblDrv.c"
                else
                {




                        return -9;
                }
# 15343 "rtl8651_tblDrv.c"
        }
        do { if (((pe)->next.tqe_next) != ((void *)0)) (pe)->next.tqe_next->next.tqe_prev = (pe)->next.tqe_prev; else (&DrvTbl.freeList.tcpudp)->tqh_last = (pe)->next.tqe_prev; *(pe)->next.tqe_prev = (pe)->next.tqe_next; (&DrvTbl.freeList.tcpudp)->tqh_count--;} while (0);
        do { (pe)->next.tqe_next = ((void *)0); (pe)->next.tqe_prev = (&DrvTbl.inuseList.tcpudp)->tqh_last; *(&DrvTbl.inuseList.tcpudp)->tqh_last = (pe); (&DrvTbl.inuseList.tcpudp)->tqh_last = &(pe)->next.tqe_next; (&DrvTbl.inuseList.tcpudp)->tqh_count++;} while (0);
# 15390 "rtl8651_tblDrv.c"
        pe->insideLocalIpAddr = insideLocalIpAddr;
        pe->insideLocalPort = insideLocalPort;
        pe->insideGlobalIpAddr = *insideGlobalIpAddr;

        pe->dstIpAddr = dstIpAddr;
        pe->dstPort = dstPort;
        pe->alive = 1;
        pe->tcp = isTcp;
        pe->hashing = 0;
        pe->tcpFlag = flowType ?flowType-1 :0;
        pe->quiet = 0;
        pe->fromDrv = fromDrv;
        pe->col1 = 1;
        pe->col2 = 1;
        pe->isStatic = 1;
        pe->asicSnapshot = 0;





        pe->pureSoftware = (assigned & 0x0002)?1:0 ||
                           (softNaptIp!=0&&softNaptIp==pe->insideGlobalIpAddr) ||
                           (RtkHomeGatewayChipRevisionID==1&&dstIpAddr==0);
        pe->interfaceRoute = interfaceRoute;
        pe->newlyAddedHash2Udp = 0;
        pe->holdForCdrouter = (assigned&0x0010)
                              ?0
                              :1;



        pe->connectionType = 0;
        pe->toProtocolStack = (assigned & 0x0008)?1:0;
        pe->dosEnCount = 0;
        pe->dosFromInternal = 0;
        pe->out_rt_t = ((void *)0);
        pe->in_rt_t = (void *)_rtl8651_getRoutingEntry(insideLocalIpAddr);
        pe->out_macInfo_t = ((void *)0);
        pe->in_macInfo_t = ((void *)0);
        pe->dsid = 0;
        pe->inExtIpIdx = -1;
        pe->outExtIpIdx = -1;
        do {} while (0);


        if( flowType == 5 )
                pe->age = rtl8651GlobalControl.tcpLongTimeout;
        else
                pe->age = (flowType) ?rtl8651GlobalControl.tcpFastTimeout :rtl8651GlobalControl.udpTimeout;
# 15448 "rtl8651_tblDrv.c"
        if ( dstIpAddr != 0 && dstPort != 0 )
        {


                if ( (assigned & 0x0001) )

                {

                        inIdx = *insideGlobalPort & (1024 -1);
                        outIdx = idx1;

                        if ( inIdx == outIdx )
                        {



                                if ( pe->pureSoftware )
                                {



                                        goto L01;
                                }


                                if ( pe->holdForCdrouter )
                                {



                                        goto L01;
                                }


                                if ( isTcp==0 )
                                {



                                        pe->newlyAddedHash2Udp = 1;
                                        goto L01;
                                }

                                if ( _rtl8651_NaptEntryIsEmpty( idx1 ) )
                                {
                                        if ( bPortReused == 1 )
                                        {



                                                goto L01;
                                        }
                                        inIdx = *insideGlobalPort & (1024 -1);
                                        outIdx = idx1;
                                        pe->hashing = 1;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        if ( isTcp && flowType < 5 )
                                                goto L01;
                                        if ( _rtl8651_WriteToAsicNaptEntry( idx1, pe ) == -1 ) goto L01;



                                }
                                else
                                {
                                        L01:





                                        inIdx = *insideGlobalPort & (1024 -1);
                                        outIdx = idx1;
                                        pe->hashing = 1;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        _rtl8651_AppendToCandidateList( idx1, pe );



                                }
                        }
                        else
                        {

                                outIdx = idx2;
                                goto L07;
                        }
                }
                else
                {


                        if (enable4WayHash == 1)
                        {

                                int i, idx_loop;
                                int found = 0;


                                idx_loop = idx1;
                                for( i = 0; i < 4; i++ )
                                {





                                        rtl8651DrvNaptLine_t *line;

                                        line = &DrvTbl.tcpudp[idx_loop];

                                        if ( ((&(line->list[1]))->slh_first)==((void *)0) &&
                                             ((&(line->list[0]))->slh_first)==((void *)0) &&
                                             ((&(line->list[5]))->slh_first)==((void *)0) &&
                                             ((&(line->list[4]))->slh_first)==((void *)0) )
                                        {
                                                found = 1;
                                                break;
                                        }
# 15576 "rtl8651_tblDrv.c"
                                        idx_loop = ( (idx_loop&~0x0003) | ((idx_loop+1)&0x0003) );
                                }





                                idx1 = idx_loop;

                                if ( pe->pureSoftware )
                                {



                                        goto L04;
                                }


                                if ( pe->holdForCdrouter )
                                {



                                        goto L04;
                                }


                                if ( isTcp==0 )
                                {



                                        pe->newlyAddedHash2Udp = 1;
                                        goto L04;
                                }

                                if ( found == 0 )
                                {




                                        goto L02;
                                }
                                else
                                {

                                        if ( -3001 == _rtl8651_getUsableExtPortWithIndex( idx_loop, isTcp, *insideGlobalIpAddr, insideGlobalPort ) ) goto err_offset;
                                        inIdx = idx_loop;
                                        outIdx = idx_loop;
                                        pe->hashing = 1;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        if ( isTcp && flowType < 5 )
                                        {



                                                goto L04;
                                        }
                                        if ( _rtl8651_WriteToAsicNaptEntry( idx_loop, pe ) == -1 ) goto L02;



                                }
                        }
                        else
                        {


                                if ( pe->pureSoftware )
                                {



                                        goto L04;
                                }


                                if ( pe->holdForCdrouter )
                                {



                                        goto L04;
                                }


                                if ( isTcp==0 )
                                {



                                        pe->newlyAddedHash2Udp = 1;
                                        goto L04;
                                }

                                if ( _rtl8651_NaptEntryIsEmpty( idx1 ) )
                                {
                                        if ( -3001 == _rtl8651_getUsableExtPortWithIndex( idx1, isTcp, *insideGlobalIpAddr, insideGlobalPort ) ) goto err_offset;
                                        inIdx = idx1;
                                        outIdx = idx1;
                                        pe->hashing = 1;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        if ( isTcp && flowType < 5 )
                                        {



                                                goto L04;
                                        }
                                        if ( _rtl8651_WriteToAsicNaptEntry( idx1, pe ) == -1 ) goto L02;



                                }
                                else
                                {
                                        L02:




                                        if ( _rtl8651_NaptEntryIsEmpty( idx2 ) )
                                        {
                                                goto L03;
                                        }
                                        else
                                        {



                                                foundIdx = idx2;
                                                if ( _rtl8651_FindEmptyASICEntry( &foundIdx ) == 0 )
                                                {



                                                        if ( bPortReused == 1 ) do {} while (0);

                                                        inIdx = foundIdx;
                                                        outIdx = idx2;
                                                        if ( -3001 == _rtl8651_getUsableExtPortWithIndex( foundIdx, isTcp, *insideGlobalIpAddr, insideGlobalPort ) ) goto err_offset;
                                                        pe->insideGlobalPort = *insideGlobalPort;
                                                        if ( flowType ) pe->tcpFlag |= 2;
                                                        pe->hashing = 2;
                                                        if ( _rtl8651_HalfHardwareAccelerated( inIdx, outIdx, pe ) == -1 ) goto L04;



                                                }
                                                else
                                                {
                                                        L04:






                                                        inIdx = idx1;
                                                        outIdx = idx1;
                                                        if ( -3001 == _rtl8651_getUsableExtPortWithIndex( idx1, isTcp, *insideGlobalIpAddr, insideGlobalPort ) ) goto err_offset;
                                                        pe->insideGlobalPort = *insideGlobalPort;

                                                        inIdx = *insideGlobalPort & (1024 -1);
                                                        if ( flowType ) pe->tcpFlag &= ~2;
                                                        pe->hashing = 1;
                                                        _rtl8651_AppendToCandidateList( idx1, pe );



                                                }
                                        }
                                }
                        }
                }
        }
        else
        {


                if ( (assigned & 0x0001) )

                {

                        inIdx = *insideGlobalPort & (1024 -1);
                        outIdx = idx2;






                        if ( inIdx == outIdx )
                        {



                                if ( pe->pureSoftware )
                                {



                                        goto L05;
                                }

                                if ( _rtl8651_NaptEntryIsEmpty( idx2 ) )
                                {

                                        if ( bPortReused == 1 )
                                        {



                                                goto L05;
                                        }


                                        if ( pe->holdForCdrouter )
                                        {



                                                goto L05;
                                        }


                                        if ( isTcp==0 )
                                        {



                                                pe->newlyAddedHash2Udp = 1;
                                                goto L05;
                                        }

                                        inIdx = *insideGlobalPort & (1024 -1);
                                        outIdx = idx2;

                                        pe->hashing = 2;
                                        if ( flowType ) pe->tcpFlag &= ~2;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        if ( _rtl8651_WriteToAsicNaptEntry( idx2,pe ) == -1 )
                                        {



                                                goto L05;
                                        }



                                }
                                else
                                {
                                        L05:





                                        inIdx = *insideGlobalPort & (1024 -1);
                                        outIdx = idx2;

                                        pe->hashing = 2;
                                        if ( flowType ) pe->tcpFlag &= ~2;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        _rtl8651_AppendToCandidateList( idx2, pe );



                                }
                        }
                        else
                        {
                                inIdx = *insideGlobalPort & (1024 -1);
                                outIdx = idx2;

                                L07:



                                pe->hashing = 2;
                                if ( flowType ) pe->tcpFlag |= 2;
                                pe->insideGlobalPort = *insideGlobalPort;
                                if ( _rtl8651_Hash2TryHardwareAccelerated( inIdx, outIdx, pe, bPortReused ) != 0 )
                                {
                                        goto err_L07;
                                }
                        }
                }
                else
                {
                        if ( pe->pureSoftware )
                        {



                                goto L06;
                        }

                        if ( _rtl8651_NaptEntryIsEmpty( idx2 ) )
                        {
                                L03:






                                if ( bPortReused == 1 ) do {} while (0);

                                if ( -3001 == _rtl8651_getUsableExtPortWithIndex( idx2, isTcp, *insideGlobalIpAddr, insideGlobalPort ) ) goto err_offset;
                                inIdx = idx2;
                                outIdx = idx2;
                                pe->hashing = 2;
                                pe->tcpFlag &= ~2;
                                pe->insideGlobalPort = *insideGlobalPort;


                                if ( pe->holdForCdrouter )
                                {



                                        goto L06;
                                }


                                if ( isTcp==0 )
                                {



                                        pe->newlyAddedHash2Udp = 1;
                                        goto L06;
                                }

                                if ( _rtl8651_WriteToAsicNaptEntry( idx2, pe ) == -1 )
                                {



                                        goto L06;
                                }



                        }
                        else
                        {



                                foundIdx = idx2;
                                if ( _rtl8651_FindEmptyASICEntry( &foundIdx ) == 0 )
                                {



                                        if ( bPortReused == 1 ) do {} while (0);

                                        inIdx = foundIdx;
                                        outIdx = idx2;
                                        if ( -3001 == _rtl8651_getUsableExtPortWithIndex( foundIdx, isTcp, *insideGlobalIpAddr, insideGlobalPort ) ) goto err_offset;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        if ( flowType ) pe->tcpFlag |= 2;
                                        pe->hashing = 2;
                                        if ( _rtl8651_HalfHardwareAccelerated( inIdx, outIdx, pe ) == -1 ) goto L06;



                                }
                                else
                                {
                                        L06:






                                        inIdx = idx2;
                                        outIdx = idx2;
                                        if ( -3001 == _rtl8651_getUsableExtPortWithIndex( idx2, isTcp, *insideGlobalIpAddr, insideGlobalPort ) ) goto err_offset;
                                        pe->hashing = 2;
                                        if ( flowType ) pe->tcpFlag &= ~2;
                                        pe->insideGlobalPort = *insideGlobalPort;
                                        _rtl8651_AppendToCandidateList( idx2, pe );



                                }
                        }
                }
        }
# 15982 "rtl8651_tblDrv.c"
        pe->tcpFlag = flowType ?flowType-1 :0;
# 15995 "rtl8651_tblDrv.c"
        if ( 1 )
        {




                int bInboundAmbiguous, bOutboundAmbiguous;
                int bInboundAsicEmpty, bOutboundAsicEmpty;
# 16013 "rtl8651_tblDrv.c"
                _rtl8651_AvoidAmbiguousHash2InAsic( pe, &bInboundAmbiguous, &bOutboundAmbiguous, &bInboundAsicEmpty, &bOutboundAsicEmpty );
# 16134 "rtl8651_tblDrv.c"
        }





        if ( assigned & 0x0020 )
        {
                pe->dosEnCount = 1;

                if ( isTcp )
                {
                        if ( assigned & 0x0040)
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalTcpCnt++;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedTcpCnt++;
                } else
                {
                        if ( assigned & 0x0040)
                        {
                                rtl8651_tblDrvNaptCounter.dosCountedFromInternalUdpCnt++;
                        }

                        rtl8651_tblDrvNaptCounter.dosCountedUdpCnt++;
                }

                if ( assigned & 0x0040 )
                {
                        pe->dosFromInternal = 1;

                        _rtl8651_dosSrcConnCtrlUpdateConnection(0, isTcp, insideLocalIpAddr);
                }else
                {
                        pe->dosFromInternal = 0;

                        _rtl8651_dosSrcConnCtrlUpdateConnection(0, isTcp, dstIpAddr);
                }
        }


        rtl8651_tblDrvNaptCounter.addSucceeded++;
        if ( fromDrv )
                rtl8651_tblDrvNaptCounter.drvAddCount++;
        else
                rtl8651_tblDrvNaptCounter.protoAddCount++;

        rtl8651_tblDrvNaptCounter.naptUnitAddCnt++;
# 16203 "rtl8651_tblDrv.c"
return 0;


err_offset:





        do { if (((pe)->next.tqe_next) != ((void *)0)) (pe)->next.tqe_next->next.tqe_prev = (pe)->next.tqe_prev; else (&DrvTbl.inuseList.tcpudp)->tqh_last = (pe)->next.tqe_prev; *(pe)->next.tqe_prev = (pe)->next.tqe_next; (&DrvTbl.inuseList.tcpudp)->tqh_count--;} while (0);
        do { if (((pe)->next.tqe_next = (&DrvTbl.freeList.tcpudp)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.tcpudp)->tqh_first->next.tqe_prev = &(pe)->next.tqe_next; else (&DrvTbl.freeList.tcpudp)->tqh_last = &(pe)->next.tqe_next; (&DrvTbl.freeList.tcpudp)->tqh_first = (pe); (pe)->next.tqe_prev = &(&DrvTbl.freeList.tcpudp)->tqh_first; (&DrvTbl.freeList.tcpudp)->tqh_count++;} while (0);




        return -3001;


err_L07:





        do { if (((pe)->next.tqe_next) != ((void *)0)) (pe)->next.tqe_next->next.tqe_prev = (pe)->next.tqe_prev; else (&DrvTbl.inuseList.tcpudp)->tqh_last = (pe)->next.tqe_prev; *(pe)->next.tqe_prev = (pe)->next.tqe_next; (&DrvTbl.inuseList.tcpudp)->tqh_count--;} while (0);
        do { if (((pe)->next.tqe_next = (&DrvTbl.freeList.tcpudp)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.tcpudp)->tqh_first->next.tqe_prev = &(pe)->next.tqe_next; else (&DrvTbl.freeList.tcpudp)->tqh_last = &(pe)->next.tqe_next; (&DrvTbl.freeList.tcpudp)->tqh_first = (pe); (pe)->next.tqe_prev = &(&DrvTbl.freeList.tcpudp)->tqh_first; (&DrvTbl.freeList.tcpudp)->tqh_count++;} while (0);




        return -3009;

}
# 16400 "rtl8651_tblDrv.c"
void _rtl8651_updateAsicNaptTable(uint32 index)
{
        rtl8651DrvNaptLine_t *thisLine;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s entry;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *pEntry=&entry;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *asicCache=((void *)0);
        uint32 asicTcpState, swTcpState;

        thisLine = &DrvTbl.tcpudp[index];

        asicCache = ((&(thisLine->list[0]))->slh_first);

        if( asicCache == ((void *)0) )
                asicCache = ((&(thisLine->list[1]))->slh_first);

        do {} while (0);

        _rtl8651_getNaptEntry(index, thisLine, &pEntry, 1);
        do {} while (0);



        if ( asicCache != ((void *)0) && pEntry->alive == 0 )
        {


                return;
        }




        if ( asicCache->tcp )
        {
                if ( asicCache->hashing == 1 )
                {

                        asicTcpState = pEntry->tcpFlag+1;
                        swTcpState = asicCache->tcpFlag+1;
                }
                else if ( asicCache->hashing == 2 ||
                          asicCache->hashing == 3 )
                {



                        asicTcpState = asicCache->tcpFlag+1;
                        swTcpState = asicCache->tcpFlag+1;
                }
                else
                {
                        do {} while (0);
                        return;
                }
        }
        else
        {
                asicTcpState = 0;
                swTcpState = 0;
        }


        pEntry->out_rt_t = asicCache->out_rt_t;




        {
                rtl8651_tblDrv_routeTable_t *rt;
                rtl8651_tblDrv_pppTable_t *ppp = ((void *)0);

                rt = (rtl8651_tblDrv_routeTable_t*) asicCache->out_rt_t;
                if ( rt && rt->nextHopType != 0x01 )
                {
                        rtl8651_tblDrv_nextHopEntry_t *nexthop;

                        switch( rt->process )
                        {
                                case 0x05:
                                        nexthop = rt->un.nxthop.start_t;
                                        if ( nexthop )
                                        {
                                                ppp = (rtl8651_tblDrv_pppTable_t*)nexthop->nexthop_t;
                                        }
                                        break;
                                case 0x08:
                                        ppp = rt->un.nxthop.un1.session.session_t;
                                        break;
                        }
                }

                {
                        uint32 ageFull;

                        if ( asicCache->tcp )
                                ageFull = rtl8651AsicAge.tcpLongTimeout;
                        else
                                ageFull = rtl8651AsicAge.udpTimeout;





                        if ( ageFull != 0 &&
                             pEntry->age >= ageFull )
                        {

                                if ( asicCache->tcp )
                                        asicCache->age = *tcpAgeTimer[asicTcpState];
                                else
                                        asicCache->age = rtl8651GlobalControl.udpTimeout;
                        }
                }
        }


        if ( asicTcpState > 5 ||
             swTcpState > 5 )
        {
                _rtl8651_changeNaptFlowListType( asicCache, 5, 4 );
                return;
        }

        if( asicCache->hashing == 1 )
        {

                do {} while (0);
                do {} while (0);

                if(asicTcpState == swTcpState){
                        uint32 maxAge=0;


                        if(asicTcpState>1){
                                maxAge=*tcpAgeTimer[asicTcpState];
                                if(maxAge&&pEntry->age>maxAge)
                                        pEntry->age=*tcpAgeTimer[asicTcpState];
                        }else
                                maxAge=rtl8651GlobalControl.udpTimeout;


                        if(asicCache->age!=pEntry->age){
                                if(asicCache->age>pEntry->age){

                                        pEntry->age=asicCache->age;
                                        _rtl8651_setNaptEntry(index, thisLine, pEntry, 1);
                                }else if(asicCache->age<3){

                                        asicCache->age=pEntry->age-1;
                                }
                        }
                }else if(asicTcpState>swTcpState){
                        if(asicTcpState==3&&swTcpState==2){

                                asicCache->age=pEntry->age = rtl8651GlobalControl.tcpLongTimeout;
                                asicCache->tcpFlag = pEntry->tcpFlag = 5 -1;
                                _rtl8651_setNaptEntry(index, thisLine, pEntry, 1);
                        }else if(asicTcpState==7&&swTcpState==6){

                                asicCache->age=pEntry->age = rtl8651GlobalControl.tcpFastTimeout;
                                asicCache->tcpFlag = pEntry->tcpFlag = 8 -1;
                                _rtl8651_setNaptEntry(index, thisLine, pEntry, 1);
                        }else{
                                asicCache->age=pEntry->age;
                                asicCache->tcpFlag=pEntry->tcpFlag;
                        }
                }else{
                        if(swTcpState==3&&asicTcpState==2){

                                asicCache->age=pEntry->age = rtl8651GlobalControl.tcpLongTimeout;
                                asicCache->tcpFlag = pEntry->tcpFlag = 5 -1;
                                _rtl8651_setNaptEntry(index, thisLine, pEntry, 1);
                        }else if(swTcpState==7&&asicTcpState==6){

                                asicCache->age=pEntry->age = rtl8651GlobalControl.tcpFastTimeout;
                                asicCache->tcpFlag = pEntry->tcpFlag = 8 -1;
                                _rtl8651_setNaptEntry(index, thisLine, pEntry, 1);
                        }else{
                                pEntry->age=asicCache->age;
                                pEntry->tcpFlag=asicCache->tcpFlag;
                                _rtl8651_setNaptEntry(index, thisLine, pEntry, 1);
                        }
                }
        }
        else if ( asicCache->hashing == 2 ||
                  asicCache->hashing == 3 )
        {



                rtl8651DrvNaptLine_t *line = &DrvTbl.tcpudp[index];
                rtl8651_tblDrv_naptTcpUdpFlowEntry_t *itEntry;







                if ( asicCache->tcpFlag != 8 -1 )
                {
                        if ( pEntry->age < 3 )
                        {

                                if ( asicCache->age > pEntry->age )
                                {

                                        pEntry->age = asicCache->age-1;
                                        _rtl8651_setNaptEntry(index, thisLine, pEntry, 1);
                                }
                        }
                        if ( asicCache->age < 3 )
                        {

                                if ( pEntry->age > asicCache->age )
                                {
                                        asicCache->age = pEntry->age-1;
                                }
                        }
                }
# 16630 "rtl8651_tblDrv.c"
                if ( asicCache->inboundTblIdx == index )
                {
                        int i;
                        for( i = 1; i < 8; i += 2 )
                        {
                                for((itEntry) = (&line->list[i])->slh_first; (itEntry); (itEntry) = (itEntry)->nextIn.sle_next)
                                {
                                        if ( itEntry->tcp == asicCache->tcp &&
                                             itEntry->tcpFlag == 5 -1 &&
                                             itEntry->insideGlobalPort == asicCache->insideGlobalPort )
                                        {

                                                if ( itEntry->age < pEntry->age )
                                                {
                                                        itEntry->age = pEntry->age;
                                                }
                                        }
                                }
                        }
                }



                if ( asicCache->outboundTblIdx == index )
                {
                        int i;
                        for( i = 0; i < 8; i += 2 )
                        {
                                for((itEntry) = (&line->list[i])->slh_first; (itEntry); (itEntry) = (itEntry)->nextOut.sle_next)
                                {
                                        if ( itEntry->tcp == asicCache->tcp &&
                                             itEntry->tcpFlag == 5 -1 &&
                                             itEntry->insideLocalIpAddr == asicCache->insideLocalIpAddr &&
                                             itEntry->insideLocalPort == asicCache->insideLocalPort )
                                        {

                                                if ( itEntry->age < pEntry->age )
                                                {
                                                        itEntry->age = pEntry->age;
                                                }
                                        }
                                }
                        }
                }
        }
        else
        {
                do {} while (0);
        }
}





void _rtl8651_naptTimerAdaptiveAdjust(int8 enabled, uint32 threshold, uint32 secPassed){
        uint32 currentFastTimeoutValue, newFastTimeoutValue;
        if(threshold)
                _adaptiveTimeoutThreshold=threshold;
        if(enabled){
                _enableAdaptiveNAPTfastTimeout=1;
                currentFastTimeoutValue=rtl8651GlobalControl.tcpFinTimeout;
                if(rtl8651_tblDrvNaptCounter.naptUnitAddCnt>_adaptiveTimeoutThreshold){
                        if(currentFastTimeoutValue>2 &&_userConfigFastTimeoutValue>2){



                                newFastTimeoutValue=(currentFastTimeoutValue>>2);
                                newFastTimeoutValue=(newFastTimeoutValue<2)?
                                        2:newFastTimeoutValue;
                                rtl8651GlobalControl.tcpFinTimeout=newFastTimeoutValue;

                        }
                }else{
                        if(currentFastTimeoutValue < _userConfigFastTimeoutValue){
                                newFastTimeoutValue=currentFastTimeoutValue+1;
                                newFastTimeoutValue=(newFastTimeoutValue>_userConfigFastTimeoutValue)?
                                        _userConfigFastTimeoutValue:newFastTimeoutValue;
                                rtl8651GlobalControl.tcpFinTimeout=newFastTimeoutValue;

                        }
                }


                if ( secPassed > 0 )
                {
                        if ( rtl8651_tblDrvNaptCounter.maxNaptUnitAddCnt < ( rtl8651_tblDrvNaptCounter.naptUnitAddCnt/secPassed ) )
                        {
                                rtl8651_tblDrvNaptCounter.maxNaptUnitAddCnt = rtl8651_tblDrvNaptCounter.naptUnitAddCnt/secPassed;
                        }
                        rtl8651_tblDrvNaptCounter.naptUnitAddCnt=0;
                }
        }else{
                _enableAdaptiveNAPTfastTimeout=0;
                rtl8651GlobalControl.tcpFinTimeout=_userConfigFastTimeoutValue;

        }
}
# 16737 "rtl8651_tblDrv.c"
void _rtl8651_naptSmartFlowSwapByPPS(int8 enabled, uint32 threshold)
{
        if(enabled)
        {
                _enableSmartNaptSwappingByLoad = 1;
                _smartNaptSwappingThresholdTcp = threshold;
                _smartNaptSwappingThresholdUdp = threshold;
        }
        else
        {
                _enableSmartNaptSwappingByLoad = 0;
                _smartNaptSwappingThresholdTcp = threshold;
                _smartNaptSwappingThresholdUdp = threshold;
        }
        return;
}
# 16761 "rtl8651_tblDrv.c"
void _rtl8651_naptSmartFlowSwapByPPSTcp( uint32 threshold )
{
        _smartNaptSwappingThresholdTcp = threshold;
        return;
}
# 16774 "rtl8651_tblDrv.c"
void _rtl8651_naptSmartFlowSwapByPPSUdp( uint32 threshold )
{
        _smartNaptSwappingThresholdUdp = threshold;
        return;
}
# 16787 "rtl8651_tblDrv.c"
void _rtl8651_naptSmartFlowSwapByPPSCdrouter( uint32 threshold )
{
        _smartNaptSwappingThresholdCdrouter = threshold;
        return;
}
# 16802 "rtl8651_tblDrv.c"
void _rtl8651_softwareNaptAging(uint32 secPassed)
{
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s * thisFlow, *nextFlow;
        for( thisFlow = ((&DrvTbl.inuseList.tcpudp)->tqh_first);
             thisFlow;
             thisFlow = nextFlow )
        {
                nextFlow = ((thisFlow)->next.tqe_next);
                do {} while (0);
                if (thisFlow->age > secPassed)
                {
                        thisFlow->age -= secPassed;
                }
                else if(thisFlow->fromDrv)
                {

                        int32 retval = 0;

                        thisFlow->age=0;

                        if ( thisFlow->connectionType == 3 )
                        {
                                retval = _rtl8651_delNaptAlgConnection( thisFlow );
                        }
                        else
                        {
                                if ( thisFlow->connectionType == 1 )
                                {

                                }
                                else
                                {
                                        retval = _rtl8651_delNaptConnection( thisFlow );
                                }
                        }
                        do {} while (0);
                        rtl8651_tblDrvNaptCounter.drvAgeoutCount++;

                        continue;
                }
                else
                {



                        thisFlow->age=0;


                }
# 16873 "rtl8651_tblDrv.c"
                if ( candidateToBeFreed == ((void *)0) )
                {
                        candidateToBeFreed = thisFlow;
                }
                else
                {
                        register uint32 flag1, flag2;

                        flag1 = thisFlow->tcp?thisFlow->tcpFlag:5 -1;
                        flag2 = candidateToBeFreed->tcp?candidateToBeFreed->tcpFlag:5 -1;

                        if ( flag1 >= flag2 &&
                             thisFlow->age < candidateToBeFreed->age )
                        {
                                candidateToBeFreed = thisFlow;
                        }
                }



                thisFlow->pps=0;


                if ( thisFlow->outListType==0)
                        _rtl8651_updateAsicNaptTable(thisFlow->outboundTblIdx);
                if(thisFlow->inboundTblIdx!=thisFlow->outboundTblIdx &&
                   thisFlow->inListType==1)
                        _rtl8651_updateAsicNaptTable(thisFlow->inboundTblIdx);

        }

}
# 16931 "rtl8651_tblDrv.c"
int32 rtl8651_addNaptConnection(int16 assigned, int8 flowType, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                                 ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalPort, ipaddr_t dstIpAddr, uint16 dstPort )
{
        uint32 result;

        rtlglue_drvMutexLock();


        result = _rtl8651_addNaptConnection(0, assigned, flowType, insideLocalIpAddr, insideLocalPort, insideGlobalIpAddr, insideGlobalPort, dstIpAddr, dstPort);

        rtlglue_drvMutexUnlock();
        return result;
}
# 16963 "rtl8651_tblDrv.c"
int32 rtl8651_delNaptConnection( int8 isTcp, ipaddr_t insideLocalIpAddr, uint16 insideLocalPort,
                                         ipaddr_t dstIpAddr, uint16 dstPort )
{
        uint16 idx1, idx1_loop, idx2;
        int32 ret = 0;
        struct rtl8651_tblDrv_naptTcpUdpFlowEntry_s *deletedEntry;
        int8 isExternal, is_gwip;

        rtlglue_drvMutexLock();

        idx1 = rtl8651_naptTcpUdpTableIndex( isTcp, insideLocalIpAddr, insideLocalPort, dstIpAddr, dstPort );
        idx2 = rtl8651_naptTcpUdpTableIndex( isTcp, insideLocalIpAddr, insideLocalPort, 0, 0 );

        if (_rtl8651_getIpInfo(insideLocalIpAddr, ((void *)0), &isExternal, &is_gwip) == ((void *)0) || isExternal==1 || is_gwip==1) {
                ret= -2712;
                goto failed;
        }


        if( _rtl8651_localServerIpAddr(dstIpAddr) == 1 )
        {
                ret = -3000;
                goto failed;
        }


        if (enable4WayHash == 1)
        {

                int i;
                idx1_loop = idx1;
                for( i = 0; i < 4; i++ )
                {
                        deletedEntry = _rtl8651_findNaptConnection( idx1_loop, isTcp, insideLocalIpAddr, insideLocalPort,
                                                                              dstIpAddr, dstPort );
                        idx1_loop = ( (idx1_loop&~0x0003) | ((idx1_loop+1)&0x0003) );
                if ( deletedEntry ) break;
                }
        }
        else
        {

                deletedEntry = _rtl8651_findNaptConnection( idx1, isTcp, insideLocalIpAddr, insideLocalPort,
                                                                     dstIpAddr, dstPort );
        }


        if( deletedEntry == ((void *)0) ||
            deletedEntry->fromDrv )
        {
                deletedEntry = _rtl8651_findNaptConnection( idx2, isTcp, insideLocalIpAddr, insideLocalPort,
                                                                         dstIpAddr, dstPort );

                if( deletedEntry == ((void *)0) ||
                    deletedEntry->fromDrv )
                {
                        ret= -3;
                        goto failed;
                }
        }


        if( deletedEntry->fromDrv == 1 )
        {
                ret= -3;
                goto failed;
        }


        if ( deletedEntry->connectionType == 3 )
        {
                ret = _rtl8651_delNaptAlgConnection( deletedEntry );
        }
        else
        {
                ret=_rtl8651_delNaptConnection(deletedEntry);
        }
        if(ret==0)
                rtl8651_tblDrvNaptCounter.protoDelCount++;
failed:
        rtlglue_drvMutexUnlock();
        return ret;
}
# 17054 "rtl8651_tblDrv.c"
int32 rtl8651_flushAllNaptConnections(void) {
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_flushNaptConnection();
        rtlglue_drvMutexUnlock();
        return retval;
}






uint8 _rtl8651_NaptIcmpExtIdIsInUsed( ipaddr_t ExtIp, uint16 ExtId )
{
        rtl8651_tblDrv_naptIcmpFlowEntry_t *tmpIcmpEntry;
        uint32 i;



        for( i = 0; i < 32; i++ )
        {
                tmpIcmpEntry = DrvTbl.icmp[i];
                for(; tmpIcmpEntry; tmpIcmpEntry=tmpIcmpEntry->next)
                        if (tmpIcmpEntry->insideGlobalId == ExtId) {
                                if ( tmpIcmpEntry->insideGlobalIpAddr == ExtIp )
                                {
                                        return 1;
                                }
                        }
        }

        return 0;
}



static int32 _rtl8651_selectNaptIcmpFlowOffset(uint32 flowTblIdx, uint32 HashIdx, ipaddr_t ExtIp, uint16 *offset) {
        int8 isValid;
        uint32 mask[2];
        rtl8651_tblDrv_naptIcmpFlowEntry_t * trackNaptIcmpFlowPtr;

        mask[0] = mask[1] =0;


        rtl8651_getAsicNaptIcmpOffset(flowTblIdx, offset, &isValid);

        do {} while (0);
        if(isValid == 1)
                mask[*offset>>5] |= ((uint32)1)<<(*offset&0x1f);


        trackNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
        while(trackNaptIcmpFlowPtr) {



                if ( 1 )
                {
                        *offset = trackNaptIcmpFlowPtr->insideGlobalId>>10;
                        mask[*offset>>5] |= ((uint32)1)<<(*offset&0x1f);
                }
                trackNaptIcmpFlowPtr = trackNaptIcmpFlowPtr->next;
        }


        for(*offset = 0; *offset < 64; (*offset)++)
        {



                uint16 TryExtPort = ( *offset << 10 ) + HashIdx;

                if( ( ( mask[*offset>>5] & ((uint32)1)<<(*offset&0x1f)) ) == 0 &&
                    0 == _rtl8651_NaptIcmpExtIdIsInUsed( ExtIp, TryExtPort ) )
                        break;
        }
        if(*offset == 64)
                return -1;
        return 0;
}


int8 _rtl8651_getIcmpUsableExtIpAndID(ipaddr_t sip, uint16 sID, ipaddr_t dip, ipaddr_t *gip, uint16 *gID) {
        uint32 flowTblIdx, flowHashingIdx;
        uint16 offset;

        if (gip == ((void *)0) || gID == ((void *)0))
                return -1;

        *gip = _rtl8651_getNaptInsideGlobalIpAddr(0, sip, sID, dip, 0);
        if (*gip==0)
                return -1;

        flowHashingIdx = rtl8651_naptIcmpTableIndex(sip, sID, dip, &flowTblIdx);
        if (_rtl8651_selectNaptIcmpFlowOffset(flowTblIdx, flowHashingIdx, *gip, &offset ) == -1)
                return -1;
        *gID = offset<<10 | ((uint16)flowHashingIdx);
        return 0;
}


static void _rtl8651_removeIcmpFlowBySrcIP(ipaddr_t sip) {
        rtl8651_tblDrv_naptIcmpFlowEntry_t *naptflow;
        ipaddr_t asicLocalIpAddr;
        uint32 flowTblIdx;
        int8 asicIsValid;

        for(flowTblIdx=0; flowTblIdx<32; flowTblIdx++) {

                naptflow = DrvTbl.icmp[flowTblIdx];
                while(naptflow) {
                        if (naptflow->insideLocalIpAddr == sip) {
                                naptflow->age = 0;
                                _rtl8651_delNaptIcmpFlow(flowTblIdx, naptflow);
                        }
                        naptflow = naptflow->next;
                }

                convert_getAsicNaptIcmpTable(0, flowTblIdx, &asicLocalIpAddr, ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0), ((void *)0), &asicIsValid);






        }
}


static rtl8651_tblDrv_naptIcmpFlowEntry_t * _rtl8651_getNaptIcmpFlowEntry(uint32 flowTblIdx, ipaddr_t insideLocalIpAddr, uint16 insideLocalId) {
        rtl8651_tblDrv_naptIcmpFlowEntry_t * trackNaptIcmpFlowPtr;

        trackNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
        while(trackNaptIcmpFlowPtr) {
                if(trackNaptIcmpFlowPtr->insideLocalIpAddr == insideLocalIpAddr &&
                   trackNaptIcmpFlowPtr->insideLocalId == insideLocalId) {
                        return trackNaptIcmpFlowPtr;
                }
                trackNaptIcmpFlowPtr = trackNaptIcmpFlowPtr->next;
        }
        return ((void *)0);
}

static int32 _rtl8651_delNaptIcmpFlowEntry(uint32 flowTblIdx, rtl8651_tblDrv_naptIcmpFlowEntry_t * deletedEntry) {
        rtl8651_tblDrv_naptIcmpFlowEntry_t * trackEntry;

        if(deletedEntry == ((void *)0) || DrvTbl.icmp[flowTblIdx] == ((void *)0))
                return -1;





        if (deletedEntry->protoDel == 1) {
                if(DrvTbl.icmp[flowTblIdx] == deletedEntry)
                        DrvTbl.icmp[flowTblIdx] = deletedEntry->next;
                else {
                        trackEntry = DrvTbl.icmp[flowTblIdx];
                        while(trackEntry->next) {
                                if(trackEntry->next == deletedEntry) {
                                        trackEntry->next = deletedEntry->next;
                                        break;
                                }
                                trackEntry = trackEntry->next;
                        }
                        if(trackEntry == ((void *)0))
                                return -1;
                }
                deletedEntry->next = DrvTbl.freeList.icmp;
                DrvTbl.freeList.icmp = deletedEntry;
                rtl8651ExistedNaptIcmpFlows--;
        }
        rtl8651NaptIcmpFlowNumberTable[flowTblIdx]--;
        if(deletedEntry->canAsic == 0)
                rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx]--;
        deletedEntry->alive = 0;
        return 0;
}


rtl8651_tblDrv_naptIcmpFlowEntry_t *
_rtl8651_getOutsideNaptIcmpEntry(ipaddr_t gip, uint16 gID, ipaddr_t dip, int8 isRefresh, int8 needFastFin) {
        rtl8651_tblDrv_naptIcmpFlowEntry_t *tmpIcmpEntry;
        uint32 flowTblIdx = gID&(32 -1);



        uint32 bFound = 0;
        for( flowTblIdx = 0; flowTblIdx < 32; flowTblIdx++ )
        {
                tmpIcmpEntry = DrvTbl.icmp[flowTblIdx];
                for(; tmpIcmpEntry; tmpIcmpEntry=tmpIcmpEntry->next)
                {
                        if ( tmpIcmpEntry->age == 0 || !tmpIcmpEntry->alive ) continue;
                        if ( tmpIcmpEntry->insideGlobalId == gID ) {
# 17260 "rtl8651_tblDrv.c"
                                if ( tmpIcmpEntry->dstIpAddr == dip &&
                                     tmpIcmpEntry->insideGlobalIpAddr == gip)
                                {
                                        bFound = 1;
                                        break;
                                }
                        }
                }
                if ( bFound == 1 ) break;
        }
        if (tmpIcmpEntry != (rtl8651_tblDrv_naptIcmpFlowEntry_t *)((void *)0)) {
                if (isRefresh == 1) {
                        if (needFastFin == 1)
                                tmpIcmpEntry->age = rtl8651GlobalControl.icmpFastTimeout;
                        else
                                tmpIcmpEntry->age = rtl8651GlobalControl.icmpTimeout;
                }
                return tmpIcmpEntry;
        }


        return tmpIcmpEntry;


        if(DrvTbl.freeList.icmp) {
                ipaddr_t asicInsideLocalIp;
                uint32 asicAgeSec;
                uint16 asicInsideLocalId, asicInsideGlobalId, asicCount;
                int8 isAsicStatic, isAsicCollision, isAsicValid;

                convert_getAsicNaptIcmpTable(0, flowTblIdx, &asicInsideLocalIp, &asicInsideLocalId, &asicInsideGlobalId, &asicAgeSec, &isAsicStatic, &asicCount, &isAsicCollision, &isAsicValid);
                if(isAsicValid == 1 && (asicInsideGlobalId&0xfc1f) == (gID&0xfc1f)) {
                        tmpIcmpEntry = DrvTbl.freeList.icmp;
                        DrvTbl.freeList.icmp = tmpIcmpEntry->next;
                        do {} while (0);
                        tmpIcmpEntry->next = DrvTbl.icmp[flowTblIdx];
                        DrvTbl.icmp[flowTblIdx] = tmpIcmpEntry;
                        do {} while (0);
                        rtl8651NaptIcmpFlowNumberTable[flowTblIdx]++;
                        rtl8651ExistedNaptIcmpFlows++;
                        tmpIcmpEntry->canAsic = 1;
                        tmpIcmpEntry->insideLocalIpAddr = asicInsideLocalIp;
                        tmpIcmpEntry->insideLocalId = asicInsideLocalId;
                        tmpIcmpEntry->insideGlobalId= asicInsideGlobalId;
                        tmpIcmpEntry->insideGlobalIpAddr = 0;
                        tmpIcmpEntry->dstIpAddr = 0;
                        tmpIcmpEntry->age = asicAgeSec;
                        tmpIcmpEntry->count = asicCount;
                        tmpIcmpEntry->fromAsic = 1;
                        tmpIcmpEntry->fromDrv = 0;
                        tmpIcmpEntry->toAsic = 1;
                        tmpIcmpEntry->staticEntry = 0;
                        tmpIcmpEntry->protoDel = 1;
                        tmpIcmpEntry->alive = 1;
                        rtl8651_tblDrvIcmpCounter.drvAddCount++;
                        return tmpIcmpEntry;
                }
        }
        return (rtl8651_tblDrv_naptIcmpFlowEntry_t *)((void *)0);
}



rtl8651_tblDrv_naptIcmpFlowEntry_t *
_rtl8651_getInsideNaptIcmpEntry(ipaddr_t sip, uint16 sID, ipaddr_t dip, int8 isRefresh, int8 needFastFin) {
        rtl8651_tblDrv_naptIcmpFlowEntry_t *tmpIcmpEntry;
        uint32 flowTblIdx;

        rtl8651_naptIcmpTableIndex(sip, sID, dip, &flowTblIdx);
        tmpIcmpEntry = DrvTbl.icmp[flowTblIdx];
        for(; tmpIcmpEntry; tmpIcmpEntry=tmpIcmpEntry->next)
        {
                if ( tmpIcmpEntry->age == 0 || !tmpIcmpEntry->alive ) continue;
                if ((tmpIcmpEntry->insideLocalIpAddr == sip) &&
                        (tmpIcmpEntry->dstIpAddr == dip) &&
                        (tmpIcmpEntry->insideLocalId == sID)) {
                        if (isRefresh == 1)
                        {
                                if (needFastFin == 1)
                                        tmpIcmpEntry->age = rtl8651GlobalControl.icmpFastTimeout;
                                else
                                        tmpIcmpEntry->age = rtl8651GlobalControl.icmpTimeout;
                        }
                        return tmpIcmpEntry;
                }
        }
        return (rtl8651_tblDrv_naptIcmpFlowEntry_t *)((void *)0);
}
# 17403 "rtl8651_tblDrv.c"
int8 _rtl8651_addNaptIcmpCandidateFlow(int8 fromDrv, ipaddr_t insideLocalIpAddr, uint16 insideLocalId,
                        ipaddr_t insideGlobalIpAddr, uint16 insideGlobalId, ipaddr_t dstIpAddr) {
        uint32 flowTblIdx, asicAgeSec;
        ipaddr_t asicInsideLocalIp;
        uint16 asicInsideLocalId, asicInsideGlobalId, asicCount;
        int8 asicEntryType, asicIsColl, asicIsValid;
        rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr,
                                                                           * trackNaptIcmpFlowPtr;

        if (_rtl8651_isNaptMapping(insideGlobalIpAddr) == 0 && softNaptIp!=insideGlobalIpAddr)
                return -1;
        rtl8651_naptIcmpTableIndex(insideLocalIpAddr, insideLocalId, dstIpAddr, &flowTblIdx);
        if(DrvTbl.freeList.icmp == ((void *)0)) {
                rtl8651_tblDrvIcmpCounter.addFailure++;
                return -9;
        }
        tempNaptIcmpFlowPtr = DrvTbl.freeList.icmp;
        DrvTbl.freeList.icmp = tempNaptIcmpFlowPtr->next;
        tempNaptIcmpFlowPtr->next = DrvTbl.icmp[flowTblIdx];
        DrvTbl.icmp[flowTblIdx] = tempNaptIcmpFlowPtr;
        rtl8651ExistedNaptIcmpFlows++;
        rtl8651NaptIcmpFlowNumberTable[flowTblIdx]++;
        tempNaptIcmpFlowPtr->insideLocalIpAddr = insideLocalIpAddr;
        tempNaptIcmpFlowPtr->insideLocalId = insideLocalId;
        tempNaptIcmpFlowPtr->insideGlobalId = insideGlobalId;
        tempNaptIcmpFlowPtr->insideGlobalIpAddr = insideGlobalIpAddr;
        tempNaptIcmpFlowPtr->dstIpAddr = dstIpAddr;
        tempNaptIcmpFlowPtr->age = rtl8651GlobalControl.icmpTimeout;
        tempNaptIcmpFlowPtr->canAsic = 1;
        tempNaptIcmpFlowPtr->fromAsic = 0;
        tempNaptIcmpFlowPtr->fromDrv = fromDrv==1? 1: 0;
        tempNaptIcmpFlowPtr->staticEntry = 1;
        tempNaptIcmpFlowPtr->protoDel = fromDrv==1? 1: 0;
        tempNaptIcmpFlowPtr->alive = 1;
        tempNaptIcmpFlowPtr->toAsic = 0;
        tempNaptIcmpFlowPtr->count = 0;
        tempNaptIcmpFlowPtr->dsid = 0;
        if (fromDrv == 0)
                rtl8651_tblDrvIcmpCounter.protoAddCount++;
        else rtl8651_tblDrvIcmpCounter.drvAddCount++;

        if(rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx] > 0)
                return 0;
        if(rtl8651NaptIcmpFlowNumberTable[flowTblIdx] - rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx] == 1) {
                if(convert_setAsicNaptIcmpTable(0, tempNaptIcmpFlowPtr->insideLocalIpAddr, tempNaptIcmpFlowPtr->insideLocalId, tempNaptIcmpFlowPtr->insideGlobalId, tempNaptIcmpFlowPtr->age, tempNaptIcmpFlowPtr->staticEntry==1? (0x1<<0): (0x0<<0), tempNaptIcmpFlowPtr->count, rtl8651NaptIcmpFlowNumberTable[flowTblIdx]> 1 || rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx]>0 ||rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx]>0? 1: 0, 1) == 0)
                        tempNaptIcmpFlowPtr->toAsic = 1;
                else {






                        convert_getAsicNaptIcmpTable(0, flowTblIdx, &asicInsideLocalIp, &asicInsideLocalId, &asicInsideGlobalId, &asicAgeSec, &asicEntryType, &asicCount, &asicIsColl, &asicIsValid);
                        if (asicIsValid == 1)
                                convert_setAsicNaptIcmpTable(1, asicInsideLocalIp, asicInsideLocalId, asicInsideGlobalId, asicAgeSec, asicEntryType, asicCount, 1, asicIsValid);
                        else {
                                convert_setAsicNaptIcmpTable(1, tempNaptIcmpFlowPtr->insideLocalIpAddr, tempNaptIcmpFlowPtr->insideLocalId, tempNaptIcmpFlowPtr->insideGlobalId, tempNaptIcmpFlowPtr->age, tempNaptIcmpFlowPtr->staticEntry==1? (0x1<<0): (0x0<<0), tempNaptIcmpFlowPtr->count, rtl8651NaptIcmpFlowNumberTable[flowTblIdx]> 1 || rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx]>0 ||rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx]>0? 1: 0, 1);
                                tempNaptIcmpFlowPtr->toAsic = 1;
                        }
                }
        }
        else if(rtl8651NaptIcmpFlowNumberTable[flowTblIdx] == 2) {
                trackNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
                while(trackNaptIcmpFlowPtr) {
                        if(trackNaptIcmpFlowPtr->toAsic == 1)
                                break;
                        trackNaptIcmpFlowPtr = trackNaptIcmpFlowPtr->next;
                }
                if(trackNaptIcmpFlowPtr)
                        convert_setAsicNaptIcmpTable(1, trackNaptIcmpFlowPtr->insideLocalIpAddr, trackNaptIcmpFlowPtr->insideLocalId, trackNaptIcmpFlowPtr->insideGlobalId, trackNaptIcmpFlowPtr->age, trackNaptIcmpFlowPtr->staticEntry==1? (0x1<<0): (0x0<<0), trackNaptIcmpFlowPtr->count, rtl8651NaptIcmpFlowNumberTable[flowTblIdx]> 1 || rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx]>0 ||rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx]>0? 1: 0, 1);
        }
        return 0;
}

int32 _rtl8651_addNaptIcmpNonCandidateFlow(int8 fromDrv, ipaddr_t insideLocalIpAddr, uint16 insideLocalId,
                        ipaddr_t insideGlobalIpAddr, uint16 insideGlobalId, ipaddr_t dstIpAddr) {
        uint32 flowTblIdx;



        rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr, * asicNaptIcmpFlowPtr;
        uint32 i;

        if (_rtl8651_isNaptMapping(insideGlobalIpAddr) == 0 && softNaptIp!=insideGlobalIpAddr)
                return -1;

        rtl8651_naptIcmpTableIndex(insideLocalIpAddr, insideLocalId, dstIpAddr, &flowTblIdx);



        for( i = 0; i < 32; i++ )
        {
                tempNaptIcmpFlowPtr = DrvTbl.icmp[i];
                for(; tempNaptIcmpFlowPtr; tempNaptIcmpFlowPtr = tempNaptIcmpFlowPtr->next)
                {
                        if ( tempNaptIcmpFlowPtr->insideGlobalIpAddr == insideGlobalIpAddr &&
                             tempNaptIcmpFlowPtr->insideGlobalId == insideGlobalId )
                                return(-3004);
                }
        }
        if(DrvTbl.freeList.icmp == ((void *)0)) {
                rtl8651_tblDrvIcmpCounter.addFailure++;
                return -9;
        }
        tempNaptIcmpFlowPtr = DrvTbl.freeList.icmp;
        DrvTbl.freeList.icmp = tempNaptIcmpFlowPtr->next;
        tempNaptIcmpFlowPtr->next = DrvTbl.icmp[flowTblIdx];
        DrvTbl.icmp[flowTblIdx] = tempNaptIcmpFlowPtr;
        rtl8651ExistedNaptIcmpFlows++;
        rtl8651NaptIcmpFlowNumberTable[flowTblIdx]++;
        rtl8651NaptIcmpFlowNonAsicNumberTable[flowTblIdx]++;
        tempNaptIcmpFlowPtr->insideLocalIpAddr = insideLocalIpAddr;
        tempNaptIcmpFlowPtr->insideLocalId = insideLocalId;
        tempNaptIcmpFlowPtr->insideGlobalId = insideGlobalId;
        tempNaptIcmpFlowPtr->insideGlobalIpAddr = insideGlobalIpAddr;
        tempNaptIcmpFlowPtr->dstIpAddr = dstIpAddr;
        tempNaptIcmpFlowPtr->age = rtl8651GlobalControl.icmpTimeout;
        tempNaptIcmpFlowPtr->canAsic = 0;
        tempNaptIcmpFlowPtr->fromAsic = 0;
        tempNaptIcmpFlowPtr->fromDrv = fromDrv==1? 1: 0;
        tempNaptIcmpFlowPtr->staticEntry = 1;
        tempNaptIcmpFlowPtr->protoDel = fromDrv==1? 1: 0;
        tempNaptIcmpFlowPtr->alive = 1;
        tempNaptIcmpFlowPtr->count = 0;
        tempNaptIcmpFlowPtr->toAsic = 0;
        tempNaptIcmpFlowPtr->dsid = 0;
        rtl8651_tblDrvIcmpCounter.diffHashCount++;
        if (fromDrv == 0)
                rtl8651_tblDrvIcmpCounter.protoAddCount++;

        if(rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx] == 0) {
                asicNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
                while(asicNaptIcmpFlowPtr) {
                        if(asicNaptIcmpFlowPtr->toAsic == 1)
                                break;
                        asicNaptIcmpFlowPtr = asicNaptIcmpFlowPtr->next;
                }
# 17556 "rtl8651_tblDrv.c"
        }
        flowTblIdx = insideGlobalId & (32 -1);
        rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx]++;
# 17569 "rtl8651_tblDrv.c"
        return 0;
}
# 17593 "rtl8651_tblDrv.c"
int32 rtl8651_addNaptIcmpFlow(int8 assigned, ipaddr_t insideLocalIpAddr, uint16 insideLocalId,
                        ipaddr_t *insideGlobalIpAddr, uint16 *insideGlobalId, ipaddr_t dstIpAddr) {
        rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr;
        uint32 flowTblIdx, flowHashingIdx, result;
        uint16 offset;

        if(insideGlobalIpAddr == ((void *)0) || insideGlobalId == ((void *)0))
                return -6;
        rtlglue_drvMutexLock();

        if(_rtl8651_intNetIpAddr(insideLocalIpAddr) == 0) {
                rtlglue_drvMutexUnlock();
                return -2712;
        }
        if(assigned == 1 && _rtl8651_extIpAddr(*insideGlobalIpAddr, ((void *)0)) == 0) {
                rtlglue_drvMutexUnlock();
                return -2711;
        }
        if(_rtl8651_localServerIpAddr(dstIpAddr) == 1) {
                rtlglue_drvMutexUnlock();
                return -3000;
        }

        flowHashingIdx = rtl8651_naptIcmpTableIndex(insideLocalIpAddr, insideLocalId, dstIpAddr, &flowTblIdx);
        do {} while (0);



        if(assigned == 0) {

                *insideGlobalIpAddr = _rtl8651_getNaptInsideGlobalIpAddr(0, insideLocalIpAddr, insideLocalId, dstIpAddr, 0);
                if ( *insideGlobalIpAddr == 0 )
                {
                        rtlglue_drvMutexUnlock();
                        return -3007;
                }

                if( -1 == _rtl8651_selectNaptIcmpFlowOffset( flowTblIdx, flowHashingIdx, *insideGlobalIpAddr, &offset ) )
                {
                        rtlglue_drvMutexUnlock();
                        return -3000;
                }
                *insideGlobalId = offset<<10 | flowHashingIdx;

        }

        if ((tempNaptIcmpFlowPtr=_rtl8651_getNaptIcmpFlowEntry(flowTblIdx, insideLocalIpAddr, insideLocalId))) {




                if (tempNaptIcmpFlowPtr->protoDel == 1 && tempNaptIcmpFlowPtr->age > 0) {
                        tempNaptIcmpFlowPtr->age = rtl8651GlobalControl.icmpTimeout;






                        tempNaptIcmpFlowPtr->protoDel = 0;
                        *insideGlobalId = tempNaptIcmpFlowPtr->insideGlobalId;
                        *insideGlobalIpAddr = tempNaptIcmpFlowPtr->insideGlobalIpAddr;
                        rtl8651_tblDrvIcmpCounter.protoAddCount++;
                        rtlglue_drvMutexUnlock();
                        return 0;
                }
                rtlglue_drvMutexUnlock();
                return -2;
        }

        result = _rtl8651_addNaptIcmpNonCandidateFlow(0, insideLocalIpAddr, insideLocalId, *insideGlobalIpAddr, *insideGlobalId, dstIpAddr);
# 17672 "rtl8651_tblDrv.c"
        rtlglue_drvMutexUnlock();
        return result;
}
# 17728 "rtl8651_tblDrv.c"
static int32 _rtl8651_delNaptIcmpFlow(uint32 flowTblIdx, rtl8651_tblDrv_naptIcmpFlowEntry_t *delEntry) {




        rtl8651_tblDrv_naptIcmpFlowEntry_t *tmpDrvEntry;

        if (delEntry == (rtl8651_tblDrv_naptIcmpFlowEntry_t *)0)
                return -1;

        _rtl8651_delNaptIcmpFlowEntry(flowTblIdx, delEntry);
        rtl8651_tblDrvIcmpCounter.drvDelCount++;
        if(delEntry->toAsic == 1) {
                do {} while (0);
                do {} while (0);
        }
        if(delEntry->toAsic == 1 || delEntry->canAsic == 0)





                ;

        else {
# 17763 "rtl8651_tblDrv.c"
                tmpDrvEntry = DrvTbl.icmp[flowTblIdx];
                while(tmpDrvEntry && tmpDrvEntry->toAsic != 1)
                        tmpDrvEntry = tmpDrvEntry->next;
# 17777 "rtl8651_tblDrv.c"
        }
        if(delEntry->canAsic==0) {
                do {} while (0);
                flowTblIdx = delEntry->insideGlobalId & (32 -1);
                rtl8651NaptIcmpBackwardCollisionCountTable[flowTblIdx]--;






        }
        return 0;
}
# 17802 "rtl8651_tblDrv.c"
int32 rtl8651_delNaptIcmpFlow(ipaddr_t insideLocalIpAddr, uint16 insideLocalId, ipaddr_t dstIpAddr) {
        uint32 flowTblIdx;
        rtl8651_tblDrv_naptIcmpFlowEntry_t * deletedEntry, * preDelEntry;

        rtlglue_drvMutexLock();
        if(_rtl8651_intNetIpAddr(insideLocalIpAddr) == 0) {
                rtlglue_drvMutexUnlock();
                return -2712;
        }
        if(_rtl8651_localServerIpAddr(dstIpAddr) == 1) {
                rtlglue_drvMutexUnlock();
                return -3000;
        }
        rtl8651_naptIcmpTableIndex(insideLocalIpAddr, insideLocalId, dstIpAddr, &flowTblIdx);

        deletedEntry = DrvTbl.icmp[flowTblIdx];
        for(preDelEntry=((void *)0); deletedEntry; preDelEntry=deletedEntry, deletedEntry=deletedEntry->next) {
                if (deletedEntry->fromAsic == 0 && deletedEntry->fromDrv == 0 &&
                        deletedEntry->insideLocalIpAddr == insideLocalIpAddr &&
                        deletedEntry->insideLocalId == insideLocalId &&
                        deletedEntry->dstIpAddr == dstIpAddr)
                                break;
        }
        if(deletedEntry == ((void *)0)) {
                rtlglue_drvMutexUnlock();
                return -3;
        }




        if (deletedEntry->protoDel == 1) {
                rtlglue_drvMutexUnlock();
                return -3;
        }
        deletedEntry->protoDel = 1;


        if (deletedEntry->age == 0) {

                if (preDelEntry == ((void *)0))
                        DrvTbl.icmp[flowTblIdx] = deletedEntry->next;
                else preDelEntry->next = deletedEntry->next;
                deletedEntry->next = DrvTbl.freeList.icmp;
                DrvTbl.freeList.icmp = deletedEntry;
                rtl8651ExistedNaptIcmpFlows --;
        }
        rtl8651_tblDrvIcmpCounter.protoDelCount++;
        rtlglue_drvMutexUnlock();
        return 0;
}
# 17862 "rtl8651_tblDrv.c"
void rtl8651_updateAsicIcmpTable(void) {
# 17920 "rtl8651_tblDrv.c"
}


static void _rtl8651_timeUpdateNaptIcmpTable(uint32 secPassed) {
        uint32 flowTblIdx;
        rtl8651_tblDrv_naptIcmpFlowEntry_t * trackNaptIcmpFlowPtr, * deletedNaptIcmpFlowPtr;

        for(flowTblIdx = 0; flowTblIdx < 32; flowTblIdx++) {
                trackNaptIcmpFlowPtr = DrvTbl.icmp[flowTblIdx];
                while(trackNaptIcmpFlowPtr) {


                        if (trackNaptIcmpFlowPtr->alive == 0) {
                                trackNaptIcmpFlowPtr = trackNaptIcmpFlowPtr->next;
                                continue;
                        }

                        if (trackNaptIcmpFlowPtr->age > secPassed) {
                                trackNaptIcmpFlowPtr->age -= secPassed;
                                deletedNaptIcmpFlowPtr = ((void *)0);
                        } else {
                                trackNaptIcmpFlowPtr->age = 0;
                                deletedNaptIcmpFlowPtr = trackNaptIcmpFlowPtr;
                        }
                        trackNaptIcmpFlowPtr = trackNaptIcmpFlowPtr->next;
                        if (deletedNaptIcmpFlowPtr) {



                                _rtl8651_delNaptIcmpFlow(flowTblIdx, deletedNaptIcmpFlowPtr);
                                deletedNaptIcmpFlowPtr->toAsic = 0;

                        }
                }
        }
}
# 18029 "rtl8651_tblDrv.c"
static void _rtl8651_setAsicAclDefaultRule(uint32 aclIdx, int8 actionType) {
        _rtl8651_tblDrvAclRule_t rule;

        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
        memset(&rule.un_ty.MAC._dstMac, 0, sizeof(ether_addr_t));
        memset(&rule.un_ty.MAC._dstMacMask, 0, sizeof(ether_addr_t));
        memset(&rule.un_ty.MAC._srcMac, 0, sizeof(ether_addr_t));
        memset(&rule.un_ty.MAC._srcMacMask, 0, sizeof(ether_addr_t));
        rule.un_ty.MAC._typeLen = 0;
        rule.un_ty.MAC._typeLenMask = 0;
        if (actionType == 0x06) {
                rule.actionType_ = 0x01;
                rule.pktOpApp = 1;
        }else
                rule.actionType_ = actionType;
        rule.ruleType_ = 0x00;
        rtl8651_setAsicAclRule(aclIdx, &rule);
}


static uint32 _rtl8651_acl_PPTP_L2TP(uint16 vid, uint32 aclStart, uint32 aclEnd)
{
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        _rtl8651_tblDrvAclRule_t rule;
        ether_addr_t *mac, *macMask;
        int32 retval;
        uint32 count=0;


        if (aclStart > aclEnd || aclEnd>=125)
                return 0;

        vlan_t = &DrvTbl.vlan[(vid& (8 -1))];
        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
        rule.ruleType_ = 0x00;
        rule.actionType_ = 0x03;
        if (vid == tunnel.loopBackVid) {



                mac = &rule.un_ty.MAC._srcMac;
                macMask = &rule.un_ty.MAC._srcMacMask;
        }
        else {

                mac = &rule.un_ty.MAC._dstMac;
                macMask = &rule.un_ty.MAC._dstMacMask;
        }
        rtl8651_memcpy(mac, &vlan_t->macAddr, sizeof(ether_addr_t));
        memset(macMask, 0xff, sizeof(ether_addr_t));
        retval = rtl8651_setAsicAclRule(aclStart, &rule);
        do {} while (0);
        count ++;


        if (vid == tunnel.wanVid)
        {
                _rtl8651_setAsicAclDefaultRule((1), 0x01);
                vlan_t->inAclStart = 0;
                vlan_t->inAclEnd = 1;
                RTL8651_SETASICVLAN(vlan_t);
                count ++;
        }
        return count;
}


uint32 _rtl8651_addAclRuleToTrapPPPoEMulticastPkt( rtl8651_tblDrv_networkIntfTable_t *netif, uint32 aclStart, uint32 aclEnd)
{
        _rtl8651_tblDrvAclRule_t rule;

        do {} while (0);

        if (aclStart > aclEnd)
                return 0;


        memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
        { (&rule)->un_ty.L3L4._srcIpAddr = 0; (&rule)->un_ty.L3L4._srcIpAddrMask = 0; (&rule)->un_ty.L3L4._dstIpAddr = 0xe0000000; (&rule)->un_ty.L3L4._dstIpAddrMask = 0xf0000000; (&rule)->un_ty.L3L4._tos = 0; (&rule)->un_ty.L3L4._tosMask = 0; (&rule)->un_ty.L3L4.is.ip._proto = 0; (&rule)->un_ty.L3L4.is.ip._protoMask = 0; (&rule)->un_ty.L3L4.is.ip.un._flag = 0; (&rule)->un_ty.L3L4.is.ip._flagMask = 0; (&rule)->ruleType_ = 0x01; (&rule)->actionType_ = 0x03;};
        rtl8651_setAsicAclRule(aclStart, &rule);
        return 1;

}


static uint32 _rtl8651_tryAddAlgToAcl(uint16 vid, uint32 aclStart, uint32 aclEnd) {
        rtl8651_tblDrv_algEntry_t *trackAlgPtr;
        rtl8651_tblDrv_vlanTable_t *vlanPtr;
        _rtl8651_tblDrvAclRule_t rule;
        uint16 _spUB, _spLB, _dpUB, _dpLB;
        uint32 servFlag, count = 0;

        do {} while (0);
        if (aclStart > aclEnd) return 0;
        vlanPtr = &DrvTbl.vlan[(vid& (8 -1))];
        for((trackAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (trackAlgPtr); (trackAlgPtr) = (trackAlgPtr)->nextAlgEntry.sle_next) {
                if (trackAlgPtr->toAsic == 1)
                        continue;

                servFlag = 0;
                if (trackAlgPtr->tcpServer == 1) servFlag |= 0x01;
                if (trackAlgPtr->tcpClient == 1) servFlag |= 0x02;
                if (trackAlgPtr->udpServer == 1) servFlag |= 0x04;
                if (trackAlgPtr->udpClient == 1) servFlag |= 0x08;
                while (servFlag) {
                        if(servFlag & (0x01 | 0x02)) {
                                if( ((servFlag & 0x01) && vlanPtr->internal == 1) ||
                                        ((servFlag & 0x02) && vlanPtr->internal == 0)){
                                        _spUB = trackAlgPtr->endPort;
                                        _spLB = trackAlgPtr->startPort;
                                        _dpUB = 0xffff;
                                        _dpLB = 0x0;
                                } else {
                                        _spUB = 0xffff;
                                        _spLB = 0x0;
                                        _dpUB = trackAlgPtr->endPort;
                                        _dpLB = trackAlgPtr->startPort;
                                }
                                { (&rule)->actionType_ = 0x03; (&rule)->ruleType_ = 0x04; (&rule)->un_ty.L3L4._dstIpAddr = 0; (&rule)->un_ty.L3L4._dstIpAddrMask = 0; (&rule)->un_ty.L3L4._srcIpAddr = 0; (&rule)->un_ty.L3L4._srcIpAddrMask = 0; (&rule)->un_ty.L3L4._tos = 0x0; (&rule)->un_ty.L3L4._tosMask = 0; (&rule)->un_ty.L3L4.is.tcp.un._flag = 0; (&rule)->un_ty.L3L4.is.tcp._flagMask = 0; (&rule)->un_ty.L3L4.is.tcp._srcPortUpperBound = _spUB; (&rule)->un_ty.L3L4.is.tcp._srcPortLowerBound = _spLB; (&rule)->un_ty.L3L4.is.tcp._dstPortUpperBound = _dpUB; (&rule)->un_ty.L3L4.is.tcp._dstPortLowerBound = _dpLB; };






                                if(servFlag & 0x01)
                                        servFlag &= ~0x01;
                                else servFlag &= ~0x02;
                        }
                        else {
                                do {} while (0);
                                if( ((servFlag & 0x04) && vlanPtr->internal == 1) ||
                                        ((servFlag & 0x08) && vlanPtr->internal == 0)){
                                        _spUB = trackAlgPtr->endPort;
                                        _spLB = trackAlgPtr->startPort;
                                        _dpUB = 0xffff;
                                        _dpLB = 0x0;
                                } else {
                                        _spUB = 0xffff;
                                        _spLB = 0x0;
                                        _dpUB = trackAlgPtr->endPort;
                                        _dpLB = trackAlgPtr->startPort;
                                }
                                { (&rule)->actionType_ = 0x03; (&rule)->ruleType_ = 0x05; (&rule)->un_ty.L3L4._dstIpAddr = 0; (&rule)->un_ty.L3L4._dstIpAddrMask = 0; (&rule)->un_ty.L3L4._srcIpAddr = 0; (&rule)->un_ty.L3L4._srcIpAddrMask = 0; (&rule)->un_ty.L3L4._tos = 0; (&rule)->un_ty.L3L4._tosMask = 0; (&rule)->un_ty.L3L4.is.udp._srcPortUpperBound = _spUB; (&rule)->un_ty.L3L4.is.udp._srcPortLowerBound = _spLB; (&rule)->un_ty.L3L4.is.udp._dstPortUpperBound = _dpUB; (&rule)->un_ty.L3L4.is.udp._dstPortLowerBound = _dpLB;};






                                if(servFlag & 0x04)
                                        servFlag &= ~0x04;
                                else servFlag &= ~0x08;
                        }
                        rtl8651_setAsicAclRule(aclStart, &rule);
                        aclStart++; count++;
                        if (aclStart > aclEnd)
                                return count;
                }
        }
        return count;
}

static uint32 _rtl8651_addAclForLanSideIpUnMacFilter(int8 isAdd, rtl8651_tblDrv_networkIntfTable_t *netif_t, uint32 aclStart, uint32 aclEnd)
{
        uint32 counter = 0;
        _rtl8651_tblDrvAclRule_t aclRule;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        rtl8651_tblDrv_macACEntry_t *mfRule;

        do {} while (0);

        if (aclStart > aclEnd)
                return 0;


        if (DrvTbl.macACInfo->enable == 0)
                return 0;

        for (mfRule = ((&DrvTbl.macACInfo->macAccessControl)->tqh_first); mfRule; mfRule = ((mfRule)->nextMAC.tqe_next)) {

                ether_addr_t macMask = { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } };






                if (memcmp(&(mfRule->macMask), &macMask, sizeof(ether_addr_t)) == 0) {

                        arp_t = _rtl8651_getArpEntryByMac(((void *)0), &(mfRule->mac), 0);


                        if (arp_t && (_rtl8651_getIPTableEntry(arp_t->ipAddr, 0, 0x02) != ((void *)0))) {
                                counter++;

                                if (isAdd == 1) {

                                        bzero(&aclRule, sizeof(_rtl8651_tblDrvAclRule_t));
                                        memcpy(&(aclRule.un_ty.SRCFILTER._srcMac), &(mfRule->mac), sizeof(ether_addr_t));
                                        memset(&(aclRule.un_ty.SRCFILTER._srcMacMask), 0xff, 6);
                                        aclRule.un_ty.SRCFILTER._ignoreL3L4 = 1;
                                        aclRule.ruleType_ = 0x07;
                                        aclRule.actionType_ = mfRule->actionType;
                                        rtl8651_setAsicAclRule(aclStart, &aclRule);
                                }
                        }
                }
        }
        return counter;

}

static uint32 _rtl8651_addAclForIpRangeRule(int8 isAdd, int8 insuff,_rtl8651_tblDrvAclRule_t *inputRule, uint32 aclStart, uint32 aclEnd)
{
        int i, msbDiff, srcIpRange;
        uint32 counter = 0;
        ipaddr_t lowIp, highIp, tmpIp, bitString;
        _rtl8651_tblDrvAclRule_t rule;

        do {} while (0);
        if (aclStart > aclEnd)
                return 0;

        rtl8651_memcpy(&rule, inputRule, sizeof(_rtl8651_tblDrvAclRule_t));


        if (inputRule->un_ty.L3L4._srcIpAddr == 0 && inputRule->un_ty.L3L4._srcIpAddrMask == 0) {
                lowIp = inputRule->un_ty.L3L4._dstIpAddr;
                highIp = inputRule->un_ty.L3L4._dstIpAddrMask;
                srcIpRange = 0;
        }
        else {
                lowIp = inputRule->un_ty.L3L4._srcIpAddr;
                highIp = inputRule->un_ty.L3L4._srcIpAddrMask;
                srcIpRange = 1;
        }
        if ((lowIp == 0 && highIp == 0) || (lowIp > highIp))
                return 0;





        bitString = lowIp ^ highIp;
        for (i = 31; i > 0 && (bitString >> i) == 0; i--);
        msbDiff = i;

        if (insuff) {
                if (isAdd == 1 && srcIpRange == 1) {
                        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
                        rule.un_ty.L3L4._srcIpAddrMask = convPrefix(32 - (msbDiff + 1));
                        rule.un_ty.L3L4._srcIpAddr = (lowIp & rule.un_ty.L3L4._srcIpAddrMask);
                        rule.ruleType_ = 0x01;
                        rule.actionType_ = 0x03;
                        rtl8651_setAsicAclRule(aclStart, &rule);
                }
                else if (isAdd == 1) {
                        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
                        rule.un_ty.L3L4._dstIpAddrMask = convPrefix(32 - (msbDiff + 1));
                        rule.un_ty.L3L4._dstIpAddr = (lowIp & rule.un_ty.L3L4._dstIpAddrMask);
                        rule.ruleType_ = 0x01;
                        rule.actionType_ = 0x03;
                        rtl8651_setAsicAclRule(aclStart, &rule);
                }

                return 1;
        }


        while(1) {
                if (isAdd == 1 && aclStart > aclEnd)
                        return counter;
                for (i = 0; i <= msbDiff && ((lowIp >> i) & 0x01) == 0; i++);
                if (i == msbDiff)
                        break;
                if (i == msbDiff + 1) {
                        if (lowIp - 1 + (0x01 << i) == highIp) {
                                if (isAdd == 1 && srcIpRange == 1) {
                                        rule.un_ty.L3L4._srcIpAddr = lowIp;
                                        rule.un_ty.L3L4._srcIpAddrMask = convPrefix(32 - i);
                                        rtl8651_setAsicAclRule(aclStart, &rule);
                                }
                                else if (isAdd == 1) {
                                        rule.un_ty.L3L4._dstIpAddr = lowIp;
                                        rule.un_ty.L3L4._dstIpAddrMask = convPrefix(32 - i);
                                        rtl8651_setAsicAclRule(aclStart, &rule);
                                }
                                aclStart++;
                        }
                        else {
                                if (isAdd == 1 && srcIpRange == 1) {
                                        rule.un_ty.L3L4._srcIpAddr = lowIp;
                                        rule.un_ty.L3L4._srcIpAddrMask = convPrefix(32 - i + 1);
                                        rtl8651_setAsicAclRule(aclStart, &rule);
                                }
                                else if (isAdd == 1) {
                                        rule.un_ty.L3L4._dstIpAddr = lowIp;
                                        rule.un_ty.L3L4._dstIpAddrMask = convPrefix(32 - i + 1);
                                        rtl8651_setAsicAclRule(aclStart, &rule);
                                }
                                aclStart++;
                        }
                        counter++;
                        break;
                }
                if (isAdd == 1 && srcIpRange == 1) {
                        rule.un_ty.L3L4._srcIpAddr = lowIp;
                        rule.un_ty.L3L4._srcIpAddrMask = convPrefix(32 - i);
                        rtl8651_setAsicAclRule(aclStart, &rule);
                }
                else if (isAdd == 1) {
                        rule.un_ty.L3L4._dstIpAddr = lowIp;
                        rule.un_ty.L3L4._dstIpAddrMask = convPrefix(32 - i);
                        rtl8651_setAsicAclRule(aclStart, &rule);
                }
                aclStart++;
                counter++;
                lowIp = lowIp + (0x01 << i);
        }


        while(1) {
                if (isAdd == 1 && aclStart > aclEnd)
                        return counter;
                for (i = 0; i <= msbDiff && ((highIp >> i) & 0x01) == 1; i++);
                if (i == msbDiff)
                        break;
                if (i == msbDiff + 1) {
                        if (highIp + 1 - (0x01 << i) == lowIp);
                        else {
                                tmpIp = highIp - (0x01 << (i - 1)) + 1;
                                if (isAdd == 1 && srcIpRange == 1) {
                                        rule.un_ty.L3L4._srcIpAddr = tmpIp;
                                        rule.un_ty.L3L4._srcIpAddrMask = convPrefix(32 - i + 1);
                                        rtl8651_setAsicAclRule(aclStart, &rule);
                                }
                                else if (isAdd == 1) {
                                        rule.un_ty.L3L4._dstIpAddr = tmpIp;
                                        rule.un_ty.L3L4._dstIpAddrMask = convPrefix(32 - i + 1);
                                        rtl8651_setAsicAclRule(aclStart, &rule);
                                }
                                aclStart++;
                                counter++;
                        }
                        break;
                }
                tmpIp = highIp - (0x01 << i) + 1;
                if (isAdd == 1 && srcIpRange == 1) {
                        rule.un_ty.L3L4._srcIpAddr = tmpIp;
                        rule.un_ty.L3L4._srcIpAddrMask = convPrefix(32 - i);
                        rtl8651_setAsicAclRule(aclStart, &rule);
                }
                else if (isAdd == 1) {
                        rule.un_ty.L3L4._dstIpAddr = tmpIp;
                        rule.un_ty.L3L4._dstIpAddrMask = convPrefix(32 - i);
                        rtl8651_setAsicAclRule(aclStart, &rule);
                }
                aclStart++;
                counter++;
                highIp = highIp - (0x01 << i);
        }

        return counter;
}

static int32 _rtl8651_addAclForSrcMacDstPortRule(rtl8651_tblDrv_networkIntfTable_t *netif_t, _rtl8651_tblDrvAclRule_t *inputRule, uint32 aclStart)
{
        rtl8651_tblDrv_arpEntry_t *arp_t;
        _rtl8651_tblDrvAclRule_t rule;
        ether_addr_t macAddr, zero_mac, max_mac;
        int8 isTcp;

        memset(&zero_mac, 0, sizeof(ether_addr_t));
        memset(&max_mac, 0xff, sizeof(ether_addr_t));
        memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
# 18415 "rtl8651_tblDrv.c"
        if (inputRule->ruleType_ == 0x04 && memcmp(&inputRule->un_ty.L3L4.is.tcp._l2srcMac, &zero_mac, sizeof(ether_addr_t)) && inputRule->un_ty.L3L4.is.tcp._dstPortUpperBound != 0 && inputRule->un_ty.L3L4.is.tcp._dstPortLowerBound != 0)
                isTcp = 1;
        else if (inputRule->ruleType_ == 0x05 && memcmp(&inputRule->un_ty.L3L4.is.udp._l2srcMac, &zero_mac, sizeof(ether_addr_t)) && inputRule->un_ty.L3L4.is.udp._dstPortUpperBound != 0 && inputRule->un_ty.L3L4.is.udp._dstPortLowerBound != 0)
                isTcp = 0;
        else
                return -1;


        macAddr = (isTcp ? inputRule->un_ty.L3L4.is.tcp._l2srcMac : inputRule->un_ty.L3L4.is.udp._l2srcMac);
        arp_t = _rtl8651_getArpEntryByMac(netif_t, &macAddr, 0);


        if (arp_t) {

                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = inputRule->ruleType_;
                rule.actionType_ = inputRule->actionType_;
                rule.un_ty.L3L4._srcIpAddr = arp_t->ipAddr;
                rule.un_ty.L3L4._srcIpAddrMask = 0xffffffff;
                if (isTcp) {
                        rule.un_ty.L3L4.is.tcp._srcPortUpperBound = inputRule->un_ty.L3L4.is.tcp._srcPortUpperBound;
                        rule.un_ty.L3L4.is.tcp._srcPortLowerBound = inputRule->un_ty.L3L4.is.tcp._srcPortLowerBound;
                        rule.un_ty.L3L4.is.tcp._dstPortUpperBound = inputRule->un_ty.L3L4.is.tcp._dstPortUpperBound;
                        rule.un_ty.L3L4.is.tcp._dstPortLowerBound = inputRule->un_ty.L3L4.is.tcp._dstPortLowerBound;
                }
                else {
                        rule.un_ty.L3L4.is.udp._srcPortUpperBound = inputRule->un_ty.L3L4.is.udp._srcPortUpperBound;
                        rule.un_ty.L3L4.is.udp._srcPortLowerBound = inputRule->un_ty.L3L4.is.udp._srcPortLowerBound;
                        rule.un_ty.L3L4.is.udp._dstPortUpperBound = inputRule->un_ty.L3L4.is.udp._dstPortUpperBound;
                        rule.un_ty.L3L4.is.udp._dstPortLowerBound = inputRule->un_ty.L3L4.is.udp._dstPortLowerBound;
                }
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        else {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                { memcpy(&((&rule)->un_ty.MAC._srcMac), &macAddr, sizeof(ether_addr_t)); memcpy(&((&rule)->un_ty.MAC._srcMacMask), &max_mac, sizeof(ether_addr_t)); memcpy(&((&rule)->un_ty.MAC._dstMac), &zero_mac, sizeof(ether_addr_t)); memcpy(&((&rule)->un_ty.MAC._dstMacMask), &zero_mac, sizeof(ether_addr_t)); (&rule)->un_ty.MAC._typeLen = 0; (&rule)->un_ty.MAC._typeLenMask = 0; (&rule)->ruleType_ = 0x00; (&rule)->actionType_ = 0x03;};
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 0;
}


static void _rtl8651_addL2PermitRule(uint32 aclIdx)
{
        _rtl8651_tblDrvAclRule_t rule;

        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
        rule.actionType_ = 0x01;
        rule.pktOpApp = 1;
        rule.ruleType_ = 0x00;
        rtl8651_setAsicAclRule(aclIdx, &rule);
}

void _rtl8651_arrangeAllACL(void) {
        rtl8651_tblDrv_vlanTable_t *vlanPtr;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        _rtl8651_tblDrvAclRule_t *trackAcl;
        uint32 i , algCount=0, aclIndex = 0, addCount=0, patchCount=0, natCount=0, dosCount=0, ipRangeCount = 0, mfCount = 0;
        uint32 inAclStart, inAclEnd, outAclStart, outAclEnd, inCount, outCount;
# 18487 "rtl8651_tblDrv.c"
        int8 enoughFlag;
# 18502 "rtl8651_tblDrv.c"
        _rtl8651_initACLDB();


        netIfPtr = &DrvTbl.netIface[0];
        for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++,netIfPtr++) {




                for (trackAcl = ((&netIfPtr->inAclHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next))
                {
                        trackAcl->aclIdx = 125 +4;
                }
        }

        {

                rtl8651_tblDrv_ipUnnumbered_t *ipUnnumber_t;

                rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_ACL_budget = (125 - 64);

                for((ipUnnumber_t) = (&DrvTbl.inuseList.ipUnnumber)->slh_first; (ipUnnumber_t); (ipUnnumber_t) = (ipUnnumber_t)->nextIpUnnumberEntry.sle_next)
                        ipUnnumber_t->ip_as_ACL_budget = 0;
        }





        if ( tunnel.valid == 1 )
                aclIndex = _rtl8651_acl_PPTP_L2TP(tunnel.wanVid , 0, 125 - 1);
# 18547 "rtl8651_tblDrv.c"
        netIfPtr = &DrvTbl.netIface[0];
        for(i=0; i<rtl8651_tblDrvPara.networkIntfTableSize; i++,netIfPtr++) {
                if (netIfPtr->valid == 0 || netIfPtr->linkLayerType == 0x00)
                        continue;

                if ( tunnel.valid == 1 && netIfPtr->vid == tunnel.wanVid )
                {




                        vlanPtr = &DrvTbl.vlan[(tunnel.loopBackVid& (8 -1))];
                }
                else
                {

                        vlanPtr = &DrvTbl.vlan[(netIfPtr->vid& (8 -1))];
                }


                inCount = outCount = 0;
                inAclStart = inAclEnd = outAclStart = outAclEnd = 0;

                inAclStart = aclIndex;





                if (tunnel.valid == 1 && netIfPtr->vid == tunnel.wanVid)
                {
                        addCount = _rtl8651_acl_PPTP_L2TP(vlanPtr->vid , aclIndex, 125 - 3);
                        aclIndex += addCount;
                        inCount += addCount;
                        if (addCount < 1)
                                goto noAclEntry_forIngress_;
                }
# 18596 "rtl8651_tblDrv.c"
                {
                        for (trackAcl = ((&netIfPtr->inRateLimitHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {
                                uint32 pktOp;






                                if (aclIndex >= (125 - 2))
                                        goto noAclEntry_forIngress_;

                                pktOp = trackAcl->pktOpApp;
                                trackAcl->pktOpApp = 6;
                                rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                trackAcl->pktOpApp = pktOp;
                                aclIndex++; inCount++;
                        }


                        for (trackAcl = ((&netIfPtr->mnqHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {
                                uint32 pktOp;

                                if (aclIndex >= (125 - 2))
                                        goto noAclEntry_forIngress_;

                                pktOp = trackAcl->pktOpApp;
                                trackAcl->pktOpApp = 6;
                                rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                trackAcl->pktOpApp = pktOp;
                                aclIndex++; inCount++;
                        }

                }
# 18656 "rtl8651_tblDrv.c"
                {
                        if (aclIndex >= (125 - 2))
                                goto noAclEntry_forIngress_;

                        enoughFlag = 1;
                        addCount = _rtl8651_tryToAddAclRuleForDns(aclIndex, 125 - 3, &enoughFlag);
                        aclIndex += addCount;
                        inCount += addCount;
                        if (enoughFlag == 0)
                                goto noAclEntry_forIngress_;
                }


                if(_urlFilter.urlFilterCount >= 0){
                        if(vlanPtr->internal){
                                _rtl8651_tblDrvAclRule_t rule;

                                if (aclIndex >= (125 - 2))
                                        goto noAclEntry_forIngress_;

                                bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
                                rule.actionType_ = 0x03;
                                rule.ruleType_ = 0x01;
                                rule.un_ty.L3L4.is.ip._httpFilter=rule.un_ty.L3L4.is.ip._httpFilterM=1;
                                rule.pktOpApp = 4;
                                rtl8651_setAsicAclRule(aclIndex, &rule);
                                _urlFilterAclRuleNum=aclIndex;
                                aclIndex++; inCount++;
                        }
                }else
                        _urlFilterAclRuleNum=-1;





                {
                        enoughFlag = 1;
                        addCount=_rtl8651_addAclRuleForSipBlock(vlanPtr->vid, aclIndex, 125 - 3, &enoughFlag);
                        aclIndex += addCount;

                        inCount += addCount;
                        if (enoughFlag == 0)
                                goto noAclEntry_forIngress_;
                }


                {
                        enoughFlag = 1;
                        addCount = _rtl8651_tryToAddAclRuleForDnsDomainBlocking(vlanPtr, aclIndex, 125 -3, &enoughFlag);
                        aclIndex += addCount;

                        inCount += addCount;
                        if (enoughFlag == 0)
                                goto noAclEntry_forIngress_;
                }






                if ( ( rtl8651_l2protoPassThrough & (1<<0) ) &&
                     rtl8651_drvDropUnknownPppoePADT )
                {
                        _rtl8651_tblDrvAclRule_t rule;
                        int32 retval;

                        if (aclIndex >= (125 - 2))
                                goto noAclEntry_forIngress_;


                        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
                        rule.ruleType_ = 0x00;
                        rule.actionType_ = 0x03;
                        rule.un_ty.MAC._typeLen = 0x8863;
                        rule.un_ty.MAC._typeLenMask = 0xffff;

                        retval = rtl8651_setAsicAclRule(aclIndex, &rule);
                        if (retval == 0)
                        {
                                aclIndex += 1;
                                inCount += 1;
                        }
                }
# 18783 "rtl8651_tblDrv.c"
                dosCount = _rtl8651_addAclRuleForDoS(netIfPtr->vid, 0, 125 - 3, 0);
                addCount = _rtl8651_addAclRuleForDoS(netIfPtr->vid, aclIndex, 125 - 3, 1);
                aclIndex += addCount;

                inCount += addCount;
                do {} while (0);
                do {} while (0);
                if (addCount < dosCount)
                        goto noAclEntry_forIngress_;



                algCount = _rtl8651_algToAclCount();
                addCount = _rtl8651_tryAddAlgToAcl(netIfPtr->vid, aclIndex, 125 - 3);
                aclIndex += addCount;

                inCount += addCount;
                do {} while (0);
                do {} while (0);
                if (addCount < algCount)
                        goto noAclEntry_forIngress_;



                if (vlanPtr->internal == 0 && softNaptIp) {
                        addCount = _rtl8651_addSoftNaptToAcl(aclIndex, 125 - 3);
                        aclIndex += addCount;

                        inCount += addCount;
                        do {} while (0);
                        if (addCount < 1) {
                                goto noAclEntry_forIngress_;
                        }
                }


                if (vlanPtr->internal == 1 && ((&DrvTbl.inuseList.policyRoute)->tqh_first)) {
                        enoughFlag = 1;
                        addCount = _rtl8651_addPolicyRouteToAcl(aclIndex, 125 - 3, &enoughFlag);
                        aclIndex += addCount;
                        inCount += addCount;
                        if (enoughFlag == 0)
                                goto noAclEntry_forIngress_;
                }



                if ((netIfPtr->linkLayerType == 0x02) || (netIfPtr->linkLayerType == 0x04))
                {
                        addCount = _rtl8651_addAclRuleToTrapPPPoEMulticastPkt(netIfPtr, aclIndex, 125 - 3);
                        aclIndex += addCount;
                        inCount += addCount;
                        do {} while (0);
                        if (addCount < 1)
                                goto noAclEntry_forIngress_;
                }


                if (netIfPtr->linkLayerType == 0x04 && (lanSideIpUnnumberedLan == netIfPtr || lanSideIpUnnumberedWan == netIfPtr)) {
                        natCount = _rtl8651_addAclForLanSideIpUnnumbered(0, netIfPtr, aclIndex, 125 -3);
                        if (natCount > 0) {
                                addCount = _rtl8651_addAclForLanSideIpUnnumbered(1, netIfPtr, aclIndex, 125 -3);
                                aclIndex += addCount;
                                inCount += addCount;
                                do {} while (0);
                                do {} while (0);
                                if (addCount < natCount)
                                        goto noAclEntry_forIngress_;
                        }
                }
# 18881 "rtl8651_tblDrv.c"
                for (trackAcl = ((&netIfPtr->inAclHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {
                        if (trackAcl->matchType_ == 0x00) {
                                if (aclIndex >= (125 - 2))
                                        goto noAclEntry_forIngress_;

                                if (trackAcl->isIPRange_ == 1)

                                {

                                        ipRangeCount = _rtl8651_addAclForIpRangeRule(0, 0, trackAcl, aclIndex, 125 - 3);
                                        if ((aclIndex + ipRangeCount) > (125 - 2) && netIfPtr->defAclAction == 0x01)

                                                addCount = _rtl8651_addAclForIpRangeRule(1, 1, trackAcl, aclIndex, 125 - 3);
                                        else
                                                addCount = _rtl8651_addAclForIpRangeRule(1, 0, trackAcl, aclIndex, 125 - 3);

                                        aclIndex += addCount;
                                        inCount += addCount;
                                        do {} while (0);
                                        if (aclIndex >= 125 - 2)
                                                goto noAclEntry_forIngress_;
# 18924 "rtl8651_tblDrv.c"
                                }

                                else if (_rtl8651_addAclForSrcMacDstPortRule(netIfPtr, trackAcl, aclIndex) == 0) {
                                        aclIndex++;
                                        inCount++;
                                }
                                else



                                {
                                        if (_rtl8651_multiple_dsid == 1) {
# 18962 "rtl8651_tblDrv.c"
                                                uint32 tmpPktOpApp = (trackAcl->pktOpApp & 0x7);
                                                uint32 tmpActionType = (trackAcl->actionType_ & 0xf);

                                                if (trackAcl->pktOpApp == 0) {

                                                        trackAcl->pktOpApp = 3;
                                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                        aclIndex++; inCount++;

                                                        if (aclIndex >= (125 - 2)) {
                                                                trackAcl->pktOpApp = tmpPktOpApp;
                                                                trackAcl->actionType_ = tmpActionType;
                                                                goto noAclEntry_forIngress_;
                                                        }


                                                        trackAcl->pktOpApp = 4;
                                                        trackAcl->actionType_=0x04;
                                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                        aclIndex++; inCount++;
                                                }
                                                else if (trackAcl->pktOpApp == 6) {

                                                        trackAcl->pktOpApp = 2;
                                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                        aclIndex++; inCount++;

                                                        if (aclIndex >= (125 - 2)) {
                                                                trackAcl->pktOpApp = tmpPktOpApp;
                                                                trackAcl->actionType_ = tmpActionType;
                                                                goto noAclEntry_forIngress_;
                                                        }


                                                        trackAcl->pktOpApp = 4;
                                                        trackAcl->actionType_=0x04;
                                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                        aclIndex++; inCount++;
                                                }
                                                else if (trackAcl->pktOpApp == 4) {

                                                        trackAcl->actionType_=0x04;
                                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                        aclIndex++; inCount++;
                                                }
                                                else {

                                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                        aclIndex++; inCount++;
                                                }
                                                trackAcl->pktOpApp = tmpPktOpApp;
                                                trackAcl->actionType_ = tmpActionType;
                                        }
                                        else {
                                                rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                aclIndex++; inCount++;
                                        }
                                }
                        }
                }






                addCount = _rtl8651_tryAddAclForMultipleNextHop(1, netIfPtr->vid, aclIndex, 125 -3);
                aclIndex += addCount;
                inCount += addCount;
                do {} while (0);
                do {} while (0);
                if (addCount < patchCount)
                        goto noAclEntry_forIngress_;
# 19051 "rtl8651_tblDrv.c"
                if (vlanPtr->internal == 0) {
                        addCount = _rtl8651_tryAddAclForWanSynTrap(aclIndex, 125 - 3);
                        aclIndex += addCount;
                        inCount += addCount;
                        do {} while (0);
                        do {} while (0);
                        if (addCount < 1)
                                goto noAclEntry_forIngress_;
                }




                addCount = _rtl8651_tryAddAclForPolicyBasedQos(netIfPtr, aclIndex, 125 - 3);
                aclIndex += addCount;
                inCount += addCount;
                do {} while (0);
                do {} while (0);
                if (addCount < ((&netIfPtr->policyQosHead)->tqh_count))
                        goto noAclEntry_forIngress_;


                for (trackAcl = ((&netIfPtr->mnqHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {
                        uint32 action;
                        uint32 pktOp;
                        if (aclIndex >= (125 - 2))
                                goto noAclEntry_forIngress_;



                        if (DrvTbl.rateLimit[trackAcl->rlIndex].mark == 1)
                        {

                                action = trackAcl->actionType_;
                                pktOp = trackAcl->pktOpApp;

                                trackAcl->actionType_ = 0x03;
                                trackAcl->pktOpApp = 6;

                                rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                _rtl8651_registerACLDB(aclIndex, _rtl8651_markDiffserv, &(DrvTbl.rateLimit[trackAcl->rlIndex].dscp));
                                aclIndex++; inCount++;
                                trackAcl->actionType_ = action;
                                trackAcl->pktOpApp = pktOp;
                        }
                        else
                        {

                                action = trackAcl->actionType_;
                                pktOp = trackAcl->pktOpApp;
                                trackAcl->actionType_ = 0x01;
                                trackAcl->pktOpApp = 6;
                                rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                aclIndex++; inCount++;
                                trackAcl->actionType_ = action;
                                trackAcl->pktOpApp = pktOp;
                        }
# 19116 "rtl8651_tblDrv.c"
                }
# 19137 "rtl8651_tblDrv.c"
                if (inCount > 0) {
                        if (netIfPtr->defAclAction == 0x02)
                                inAclEnd = aclIndex - 1;
                        else if (aclIndex < (125 - 2)) {
                                if (mnQ_enable==1 && vlanPtr->internal == 1 &&

                                    DrvTbl.rateLimit[32 -1].queueType == 3) {
                                        _rtl8651_tblDrvAclRule_t rule;
                                        bzero(&rule,sizeof(_rtl8651_tblDrvAclRule_t));
                                        rule.actionType_ = 0x0c;
                                        rule.ruleType_ = 0x01;
                                        rule.rlIndex = 32 - 1;
                                        rule.pktOpApp= 6;
                                        rtl8651_setAsicAclRule(aclIndex, &rule);
                                        aclIndex++;

                                        if (aclIndex >= (125 - 2))
                                                goto noAclEntry_forIngress_;
                                }
                                _rtl8651_setAsicAclDefaultRule(aclIndex, netIfPtr->defAclAction);
                        aclIndex++;
                                inAclEnd = aclIndex - 1;
                }
                        else
                                goto noAclEntry_forIngress_;

                }



                else {
                        switch(netIfPtr->defAclAction) {
                                case 0x01:
                                        inAclStart = inAclEnd = 125;
                                        break;
                                case 0x02:
                                        inAclStart = inAclEnd = 126;
                                        break;
                                case 0x03:
                                        inAclStart = inAclEnd = 127;
                                        break;
                                default: do {} while (0);
                        }
                }

                outAclStart = aclIndex;

                for (trackAcl = ((&netIfPtr->outRateLimitHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {
                        uint32 pktOp;

                        if (trackAcl->isRateLimitCounter_ == 1)
                                continue;

                        if (aclIndex >= (125 - 2))
                                goto noAclEntry_forEgress_;

                        pktOp = trackAcl->pktOpApp;
                        trackAcl->pktOpApp = 6;
                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                        trackAcl->pktOpApp = pktOp;
                        aclIndex++; outCount++;
                }



                if (netIfPtr->linkLayerType == 0x04 && lanSideIpUnnumberedWan == netIfPtr) {
                        mfCount = _rtl8651_addAclForLanSideIpUnMacFilter(0, netIfPtr, aclIndex, 125 - 3);
                        if (mfCount > 0) {
                                addCount = _rtl8651_addAclForLanSideIpUnMacFilter(1, netIfPtr, aclIndex, 125 - 3);
                                aclIndex += addCount;
                                outCount += addCount;
                                do {} while (0);
                                do {} while (0);
                                if (addCount < mfCount)
                                        goto noAclEntry_forEgress_;
                        }
                }


                for (trackAcl = ((&netIfPtr->outAclHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {
                        if (aclIndex >= (125 - 2))
                                goto noAclEntry_forEgress_;

                        if (trackAcl->isIPRange_ == 1)

                        {

                                ipRangeCount = _rtl8651_addAclForIpRangeRule(0, 0, trackAcl, aclIndex, 125 - 3);
                                if ((aclIndex + ipRangeCount) > (125 - 2))

                                        addCount = _rtl8651_addAclForIpRangeRule(1, 1, trackAcl, aclIndex, 125 - 3);
                                else
                                        addCount = _rtl8651_addAclForIpRangeRule(1, 0, trackAcl, aclIndex, 125 - 3);

                                aclIndex += addCount;
                                outCount += addCount;
                                do {} while (0);
                                if (aclIndex >= 125 - 2)
                                        goto noAclEntry_forEgress_;
# 19258 "rtl8651_tblDrv.c"
                        } else



                        {
                                if (_rtl8651_multiple_dsid == 1) {
# 19278 "rtl8651_tblDrv.c"
                                        if (trackAcl->dsid != 0 ) {
                                                if (trackAcl->pktOpApp == 0) {
                                                        trackAcl->pktOpApp = 3;
                                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                        aclIndex++; outCount++;
                                                }
# 19298 "rtl8651_tblDrv.c"
                                        }
                                        else {
                                                rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                                aclIndex++; outCount++;
                                        }
                                }
                                else {
                                        rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                        aclIndex++; outCount++;
                                }
                        }
                }


                {
                        for (trackAcl = ((&netIfPtr->outRateLimitHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {
                                if (trackAcl->isRateLimitCounter_ == 0)
                                        continue;
                                if (aclIndex >= (125 - 2))
                                        goto noAclEntry_forEgress_;

                                rtl8651_setAsicAclRule(aclIndex, trackAcl);
                                aclIndex++; outCount++;
                        }
                }




                if (outCount > 0) {
                        if (netIfPtr->defAclAction == 0x02)
                                outAclEnd = aclIndex - 1;
                        else if (aclIndex < (125 - 2)) {
                                _rtl8651_setAsicAclDefaultRule(aclIndex, netIfPtr->defAclAction);
                                outAclEnd = aclIndex;
                                aclIndex++;
                }
                        else
                                goto noAclEntry_forEgress_;
                }



                else {
                        switch(netIfPtr->defAclAction) {
                                case 0x01:
                                        outAclStart = outAclEnd = 125;
                                        break;
                                case 0x02:
                                        outAclStart = outAclEnd = 126;
                                        break;
                                case 0x03:
                                        outAclStart = outAclEnd = 127;
                                        break;
                                default: do {} while (0);
                        }
                }

                goto end__;




noAclEntry_forIngress_:

                _rtl8651_addL2PermitRule(125 - 2);
                                _rtl8651_setAsicAclDefaultRule((125 -1), 0x03);


                inAclEnd = 125 - 1;


                if (((&netIfPtr->outAclHead)->tqh_count) > 0) {
                        outAclStart = 125 - 2;
                        outAclEnd = 125 - 1;
                }
                else {
                        switch(netIfPtr->defAclAction) {
                                case 0x01:
                                        outAclStart = outAclEnd = 125;
                                        break;
                                case 0x02:
                                        outAclStart = outAclEnd = 126;
                                        break;
                                case 0x03:
                                        outAclStart = outAclEnd = 127;
                                        break;
                                default: do {} while (0);
                        }
                }
                goto end__;




noAclEntry_forEgress_:

                _rtl8651_addL2PermitRule(125 - 2);
                _rtl8651_setAsicAclDefaultRule((125 - 1), 0x03);


                outAclEnd = 125 - 1;

end__:

                vlanPtr->inAclStart = inAclStart;
                vlanPtr->inAclEnd = inAclEnd;


                vlanPtr->outAclStart = outAclStart;
                vlanPtr->outAclEnd = outAclEnd;

                RTL8651_SETASICVLAN(vlanPtr);
        }



        for(i=0, vlanPtr=DrvTbl.vlan; i<8; i++, vlanPtr++) {
                if (vlanPtr->valid == 0 || vlanPtr->fvlan_t == ((void *)0))
                        continue;

                vlanPtr->inAclStart = vlanPtr->fvlan_t->inAclStart;
                vlanPtr->inAclEnd = vlanPtr->fvlan_t->inAclEnd;
                vlanPtr->outAclStart = vlanPtr->fvlan_t->outAclStart;
                vlanPtr->outAclEnd = vlanPtr->fvlan_t->outAclEnd;
                RTL8651_SETASICVLAN(vlanPtr);
        }





                if ( ( rtl8651_l2protoPassThrough & (1<<0) ) &&
                     rtl8651_gPPPoEExternalVlanIndex != 8 &&
                     rtl8651_gPPPoEPassthruVlanID != (4096+1) )
                {
                        int32 retval;

                        vlanPtr = &DrvTbl.vlan[(rtl8651_gPPPoEPassthruVlanID& (8 -1))];
                        vlanPtr->inAclStart = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].inAclStart;
                        vlanPtr->inAclEnd = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].inAclEnd;
                        vlanPtr->outAclStart = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].outAclStart;
                        vlanPtr->outAclEnd = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].outAclEnd;
                        retval = RTL8651_SETASICVLAN( vlanPtr );
                        do {} while (0);
                }


}
# 19480 "rtl8651_tblDrv.c"
static int8
_rtl8651_sameAclRule(_rtl8651_tblDrvAclRule_t *rule1, rtl8651_tblDrvAclRule_t *rule2) {


        if (rule1->actionType_ != rule2->actionType_ || rule1->ruleType_ != rule2->ruleType_)
                return 0;

        switch(rule1->ruleType_) {
        case 0x00:
                 if (rule1->un_ty.MAC._typeLen != rule2->un_ty.MAC._typeLen || rule1->un_ty.MAC._typeLenMask != rule2->un_ty.MAC._typeLenMask)
                        return 0;
                 if (memcmp(&rule1->un_ty.MAC._dstMac, &rule2->un_ty.MAC._dstMac, sizeof(ether_addr_t)) ||
                         memcmp(&rule1->un_ty.MAC._dstMacMask, &rule2->un_ty.MAC._dstMacMask, sizeof(ether_addr_t)) ||
                         memcmp(&rule1->un_ty.MAC._srcMac, &rule2->un_ty.MAC._srcMac, sizeof(ether_addr_t)) ||
                         memcmp(&rule1->un_ty.MAC._srcMacMask, &rule2->un_ty.MAC._srcMacMask, sizeof(ether_addr_t)) )
                         return 0;
                 return 1;
        case 0x01:
                 if (rule1->un_ty.L3L4.is.ip._proto != rule2->un_ty.L3L4.is.ip._proto || rule1->un_ty.L3L4.is.ip._protoMask != rule2->un_ty.L3L4.is.ip._protoMask ||
                        rule1->un_ty.L3L4.is.ip.un._flag != rule2->un_ty.L3L4.is.ip.un._flag || rule1->un_ty.L3L4.is.ip._flagMask != rule2->un_ty.L3L4.is.ip._flagMask)
                        return 0;
                break;

        case 0x02:
                 if (rule1->un_ty.L3L4.is.icmp._type != rule2->un_ty.L3L4.is.icmp._type || rule1->un_ty.L3L4.is.icmp._typeMask != rule2->un_ty.L3L4.is.icmp._typeMask ||
                        rule1->un_ty.L3L4.is.icmp._code != rule2->un_ty.L3L4.is.icmp._code || rule1->un_ty.L3L4.is.icmp._codeMask != rule2->un_ty.L3L4.is.icmp._codeMask)
                        return 0;
                 break;

        case 0x03:
                 if(rule1->un_ty.L3L4.is.igmp._type != rule2->un_ty.L3L4.is.igmp._type || rule1->un_ty.L3L4.is.igmp._typeMask != rule2->un_ty.L3L4.is.igmp._typeMask)
                        return 0;
                 break;
        case 0x04:
                 if(rule1->un_ty.L3L4.is.tcp.un._flag != rule2->un_ty.L3L4.is.tcp.un._flag || rule1->un_ty.L3L4.is.tcp._flagMask != rule2->un_ty.L3L4.is.tcp._flagMask ||
                        rule1->un_ty.L3L4.is.tcp._srcPortUpperBound != rule2->un_ty.L3L4.is.tcp._srcPortUpperBound || rule1->un_ty.L3L4.is.tcp._srcPortLowerBound != rule2->un_ty.L3L4.is.tcp._srcPortLowerBound ||
                        rule1->un_ty.L3L4.is.tcp._dstPortUpperBound != rule2->un_ty.L3L4.is.tcp._dstPortUpperBound || rule1->un_ty.L3L4.is.tcp._dstPortLowerBound != rule2->un_ty.L3L4.is.tcp._dstPortLowerBound)
                        return 0;
                 break;
        case 0x05:
                printk("%d %d, %d %d ,%d %d ,%d %d \n",rule1->un_ty.L3L4.is.udp._srcPortUpperBound,rule2->un_ty.L3L4.is.udp._srcPortUpperBound
                        , rule1->un_ty.L3L4.is.udp._srcPortLowerBound, rule2->un_ty.L3L4.is.udp._srcPortLowerBound
                        ,rule1->un_ty.L3L4.is.udp._dstPortUpperBound , rule2->un_ty.L3L4.is.udp._dstPortUpperBound
                        , rule1->un_ty.L3L4.is.udp._dstPortLowerBound ,rule2->un_ty.L3L4.is.udp._dstPortLowerBound);

                 if(rule1->un_ty.L3L4.is.udp._srcPortUpperBound != rule2->un_ty.L3L4.is.udp._srcPortUpperBound || rule1->un_ty.L3L4.is.udp._srcPortLowerBound != rule2->un_ty.L3L4.is.udp._srcPortLowerBound ||
                        rule1->un_ty.L3L4.is.udp._dstPortUpperBound != rule2->un_ty.L3L4.is.udp._dstPortUpperBound || rule1->un_ty.L3L4.is.udp._dstPortLowerBound != rule2->un_ty.L3L4.is.udp._dstPortLowerBound)
                        return 0;
                 break;
        default: return 0;

        }

        if (rule1->un_ty.L3L4._srcIpAddr != rule2->un_ty.L3L4._srcIpAddr || rule1->un_ty.L3L4._srcIpAddrMask != rule2->un_ty.L3L4._srcIpAddrMask ||
                rule1->un_ty.L3L4._dstIpAddr != rule2->un_ty.L3L4._dstIpAddr || rule1->un_ty.L3L4._dstIpAddrMask != rule2->un_ty.L3L4._dstIpAddrMask ||
                rule1->un_ty.L3L4._tos != rule2->un_ty.L3L4._tos || rule1->un_ty.L3L4._tosMask != rule2->un_ty.L3L4._tosMask )
                return 0;
        return 1;
}


static int32
_rtl8651_addAclRule(uint32 sessionID, rtl8651_tblDrv_networkIntfTable_t *netif_t, int8 Ingress, rtl8651_tblDrvAclRule_t *rule, int8 flag)
{
        _rtl8651_tblDrvAclRule_t *aclRule;
        uint32 dsid;

        do {} while (0);

        if ( (rule->actionType_!=0x02) && (rule->actionType_!=0x01) &&
              (rule->actionType_!=0x04) && (rule->actionType_!=0x03) &&
              (rule->actionType_!=0x05) )
                return -1401;


        if (rule->actionType_ == 0x05 && Ingress == 0)
                return -1401;

        if (aclMode == 0x02)
                return -1402;
        if ((aclRule = ((&DrvTbl.freeList.aclRule)->tqh_first)) == ((void *)0))
                return -9;
        dsid=_rtl8651_SessionIDToDSID(sessionID);
        do { if (((aclRule)->nextRule.tqe_next) != ((void *)0)) (aclRule)->nextRule.tqe_next->nextRule.tqe_prev = (aclRule)->nextRule.tqe_prev; else (&DrvTbl.freeList.aclRule)->tqh_last = (aclRule)->nextRule.tqe_prev; *(aclRule)->nextRule.tqe_prev = (aclRule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_count--;} while (0);
        bzero(aclRule, sizeof(_rtl8651_tblDrvAclRule_t)-sizeof(aclRule->nextRule));
        rtl8651_memcpy(aclRule, rule,sizeof(rtl8651_tblDrvAclRule_t));
        aclRule->dsid = dsid;
        aclRule->isIPRange_ = (flag == 0x01)? 1: 0;
        aclRule->isRateLimitCounter_ = 0;





        aclRule->aclIdx = 125 +4;






        if ( _rtl8651_multiple_dsid == 1 && aclRule->actionType_==0x02) {
                if(_rtl8651_acl_drop_nolog[dsid] == 0)
                        _rtl8651_acl_drop_nolog[dsid] = 1;
        }

        if (Ingress == 1)
                do { (aclRule)->nextRule.tqe_next = ((void *)0); (aclRule)->nextRule.tqe_prev = (&netif_t->inAclHead)->tqh_last; *(&netif_t->inAclHead)->tqh_last = (aclRule); (&netif_t->inAclHead)->tqh_last = &(aclRule)->nextRule.tqe_next; (&netif_t->inAclHead)->tqh_count++;} while (0);
        else do { (aclRule)->nextRule.tqe_next = ((void *)0); (aclRule)->nextRule.tqe_prev = (&netif_t->outAclHead)->tqh_last; *(&netif_t->outAclHead)->tqh_last = (aclRule); (&netif_t->outAclHead)->tqh_last = &(aclRule)->nextRule.tqe_next; (&netif_t->outAclHead)->tqh_count++;} while (0);
        if ((((&netif_t->inAclHead)->tqh_count)+((&netif_t->outAclHead)->tqh_count)) == 1)
                aclMode = 0x01;

        _rtl8651_arrangeAllACL();

        return 0;
}


static int32
_rtl8651_delAclRule(uint32 sessionID, rtl8651_tblDrv_networkIntfTable_t *netif_t, int8 Ingress, rtl8651_tblDrvAclRule_t *rule)
{
        _rtl8651_tblDrvAclRule_t *delAcl;
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} *aclHead;

        uint32 dsid;


        do {} while (0);

        if (aclMode == 0x02)
                return -1402;
        dsid=_rtl8651_SessionIDToDSID(sessionID);
        if (Ingress == 1)
                aclHead = (struct _aclStruct *)&netif_t->inAclHead;
        else aclHead = (struct _aclStruct *)&netif_t->outAclHead;
        for ((delAcl) = (*(((struct _aclStruct *)(((aclHead))->tqh_last))->tqh_last)); (delAcl); (delAcl) = (*(((struct _aclStruct *)(((delAcl))->nextRule.tqe_prev))->tqh_last)))
                if (_rtl8651_sameAclRule(delAcl, rule) == 1)
                        break;
        if (delAcl == ((void *)0))
                return -3;
        do { if (((delAcl)->nextRule.tqe_next) != ((void *)0)) (delAcl)->nextRule.tqe_next->nextRule.tqe_prev = (delAcl)->nextRule.tqe_prev; else (aclHead)->tqh_last = (delAcl)->nextRule.tqe_prev; *(delAcl)->nextRule.tqe_prev = (delAcl)->nextRule.tqe_next; (aclHead)->tqh_count--;} while (0);
        delAcl->dsid = dsid;
        do { if (((delAcl)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(delAcl)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(delAcl)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (delAcl); (delAcl)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
        if ((((&netif_t->inAclHead)->tqh_count)+((&netif_t->outAclHead)->tqh_count)) == 0)
                aclMode = 0x00;
        _rtl8651_arrangeAllACL();
        return 0;
}
# 19641 "rtl8651_tblDrv.c"
_rtl8651_tblDrvAclRule_t *
_rtl8651_aclLookUp(uint32 dsid, rtl8651_tblDrv_networkIntfTable_t *netIfPtr, int8 Ingress, uint32 startIdx, int8 *ether_hdr, int8 *ip_hdr, int8 *defPermit, uint32 matchType, uint32 optLayer) {
        struct ether_header *ehdr = (struct ether_header *)ether_hdr;
        struct ip *iphdr = (struct ip *)ip_hdr;
        _rtl8651_tblDrvAclRule_t *rule;
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} *aclHead;
        struct icmp *icmphdr;
        struct igmp *igmphdr;
        struct tcphdr *tcphdr;
        struct udphdr *udphdr;
        ipaddr_t ip_s=0, ip_d=0;
        uint16 aclCount;



        do {} while (0);
        do {} while (0);

        if (netIfPtr == ((void *)0)) {

                if (defPermit != ((void *)0)) *defPermit = 1;
                return (_rtl8651_tblDrvAclRule_t *)((void *)0);
        }
        if (iphdr != (struct ip *)((void *)0)) {
                ip_s = ((uint32) (*((uint8*)(&iphdr->ip_src))<<24)|(*(((uint8*)(&iphdr->ip_src))+1)<<16)|(*(((uint8*)(&iphdr->ip_src))+2)<<8) | *(((uint8*)(&iphdr->ip_src))+3));
                ip_d = ((uint32) (*((uint8*)(&iphdr->ip_dst))<<24)|(*(((uint8*)(&iphdr->ip_dst))+1)<<16)|(*(((uint8*)(&iphdr->ip_dst))+2)<<8) | *(((uint8*)(&iphdr->ip_dst))+3));
        }
        if (Ingress == 1)
                aclHead = (struct _aclStruct *)&netIfPtr->inAclHead;
        else aclHead = (struct _aclStruct *)&netIfPtr->outAclHead;

        for (rule = ((aclHead)->tqh_first); rule; rule = ((rule)->nextRule.tqe_next)) {

                if (rule->aclIdx < startIdx)
                        continue;






                if (Ingress == 1 && rule->matchType_ != matchType)
                        continue;


                if (rule->pktOpApp != 0) {





                        if ((optLayer == 0) || (((0x01 << (optLayer - 2)) & rule->pktOpApp) == 0))
                                continue;
                }

                switch (rule->ruleType_)
                {
                case 0x00:
                        {
                         ether_addr_t srcMac, dstMac;

                         dstMac.octet[0]= ehdr->ether_dhost[0] & rule->un_ty.MAC._dstMacMask.octet[0];
                         dstMac.octet[1]= ehdr->ether_dhost[1] & rule->un_ty.MAC._dstMacMask.octet[1];
                         dstMac.octet[2]= ehdr->ether_dhost[2] & rule->un_ty.MAC._dstMacMask.octet[2];
                         dstMac.octet[3]= ehdr->ether_dhost[3] & rule->un_ty.MAC._dstMacMask.octet[3];
                         dstMac.octet[4]= ehdr->ether_dhost[4] & rule->un_ty.MAC._dstMacMask.octet[4];
                         dstMac.octet[5]= ehdr->ether_dhost[5] & rule->un_ty.MAC._dstMacMask.octet[5];
                         srcMac.octet[0]= ehdr->ether_shost[0] & rule->un_ty.MAC._srcMacMask.octet[0];
                         srcMac.octet[1]= ehdr->ether_shost[1] & rule->un_ty.MAC._srcMacMask.octet[1];
                         srcMac.octet[2]= ehdr->ether_shost[2] & rule->un_ty.MAC._srcMacMask.octet[2];
                         srcMac.octet[3]= ehdr->ether_shost[3] & rule->un_ty.MAC._srcMacMask.octet[3];
                         srcMac.octet[4]= ehdr->ether_shost[4] & rule->un_ty.MAC._srcMacMask.octet[4];
                         srcMac.octet[5]= ehdr->ether_shost[5] & rule->un_ty.MAC._srcMacMask.octet[5];
                         if (((ehdr->ether_type & rule->un_ty.MAC._typeLenMask) == rule->un_ty.MAC._typeLen) &&
                                (memcmp(dstMac.octet, rule->un_ty.MAC._dstMac.octet, 6) == 0) &&
                                (memcmp(srcMac.octet, rule->un_ty.MAC._srcMac.octet, 6) == 0) &&
                                (rule->dsid==dsid))
                                return (_rtl8651_tblDrvAclRule_t *)rule;
                        }
                        break;

                case 0x01:
                        {
                         if (iphdr == (struct ip *)((void *)0))
                                break;
                         if (((iphdr->ip_p & rule->un_ty.L3L4.is.ip._protoMask) != rule->un_ty.L3L4.is.ip._proto) ||
                                ((((iphdr->ip_off)>>13) & rule->un_ty.L3L4.is.ip._flagMask) != rule->un_ty.L3L4.is.ip.un._flag))
                                        break;
                        }
                        goto l3l4_shared;

                case 0x02:
                        {
                         if (iphdr == (struct ip *)((void *)0) || iphdr->ip_p != 1 || ((iphdr->ip_off) & 0x1fff))
                                break;

                         icmphdr = (struct icmp *)(ip_hdr + ((iphdr->ip_vhl & 0x0f)<<2));
                         if (((icmphdr->icmp_type & rule->un_ty.L3L4.is.icmp._typeMask) != rule->un_ty.L3L4.is.icmp._type) ||
                                ((icmphdr->icmp_code & rule->un_ty.L3L4.is.icmp._codeMask) != rule->un_ty.L3L4.is.icmp._code))
                                        break;
                        }
                        goto l3l4_shared;

                case 0x03:
                        {
                         if (iphdr == (struct ip *)((void *)0) || iphdr->ip_p != 2 || ((iphdr->ip_off) & 0x1fff))
                                break;

                         igmphdr = (struct igmp *)(ip_hdr + ((iphdr->ip_vhl & 0x0f)<<2));
                         if (((igmphdr->igmp_type & rule->un_ty.L3L4.is.igmp._typeMask) != rule->un_ty.L3L4.is.igmp._type))
                                        break;
                        }
                        goto l3l4_shared;

                case 0x04:
                        {

                        ether_addr_t srcMac;

                         srcMac.octet[0]= ehdr->ether_shost[0] & rule->un_ty.L3L4.is.tcp._l2srcMacMask.octet[0];
                         srcMac.octet[1]= ehdr->ether_shost[1] & rule->un_ty.L3L4.is.tcp._l2srcMacMask.octet[1];
                         srcMac.octet[2]= ehdr->ether_shost[2] & rule->un_ty.L3L4.is.tcp._l2srcMacMask.octet[2];
                         srcMac.octet[3]= ehdr->ether_shost[3] & rule->un_ty.L3L4.is.tcp._l2srcMacMask.octet[3];
                         srcMac.octet[4]= ehdr->ether_shost[4] & rule->un_ty.L3L4.is.tcp._l2srcMacMask.octet[4];
                         srcMac.octet[5]= ehdr->ether_shost[5] & rule->un_ty.L3L4.is.tcp._l2srcMacMask.octet[5];


                         if (iphdr == (struct ip *)((void *)0) || iphdr->ip_p != 6 || ((iphdr->ip_off) & 0x1fff))
                                break;


                         tcphdr = (struct tcphdr *)(ip_hdr + ((iphdr->ip_vhl & 0x0f)<<2));
                         if ( (memcmp(srcMac.octet, rule->un_ty.L3L4.is.tcp._l2srcMac.octet, 6) != 0) || ((tcphdr->th_flags & rule->un_ty.L3L4.is.tcp._flagMask) != rule->un_ty.L3L4.is.tcp.un._flag) ||
                                 !((tcphdr->th_sport)>=rule->un_ty.L3L4.is.tcp._srcPortLowerBound && (tcphdr->th_sport) <= rule->un_ty.L3L4.is.tcp._srcPortUpperBound) ||
                                 !((tcphdr->th_dport)>=rule->un_ty.L3L4.is.tcp._dstPortLowerBound && (tcphdr->th_dport) <= rule->un_ty.L3L4.is.tcp._dstPortUpperBound) )
                                        break;
                        }
                        goto l3l4_shared;

                case 0x05:
                        {

                        ether_addr_t srcMac;

                         srcMac.octet[0]= ehdr->ether_shost[0] & rule->un_ty.L3L4.is.udp._l2srcMacMask.octet[0];
                         srcMac.octet[1]= ehdr->ether_shost[1] & rule->un_ty.L3L4.is.udp._l2srcMacMask.octet[1];
                         srcMac.octet[2]= ehdr->ether_shost[2] & rule->un_ty.L3L4.is.udp._l2srcMacMask.octet[2];
                         srcMac.octet[3]= ehdr->ether_shost[3] & rule->un_ty.L3L4.is.udp._l2srcMacMask.octet[3];
                         srcMac.octet[4]= ehdr->ether_shost[4] & rule->un_ty.L3L4.is.udp._l2srcMacMask.octet[4];
                         srcMac.octet[5]= ehdr->ether_shost[5] & rule->un_ty.L3L4.is.udp._l2srcMacMask.octet[5];


                         if (iphdr == (struct ip *)((void *)0) || iphdr->ip_p != 17 || ((iphdr->ip_off) & 0x1fff))
                                break;

                         udphdr = (struct udphdr *)(ip_hdr + ((iphdr->ip_vhl & 0x0f)<<2));
                         if ((memcmp(srcMac.octet, rule->un_ty.L3L4.is.udp._l2srcMac.octet, 6) != 0) || !((udphdr->uh_sport)>=rule->un_ty.L3L4.is.udp._srcPortLowerBound && (udphdr->uh_sport)<=rule->un_ty.L3L4.is.udp._srcPortUpperBound) ||
                                 !((udphdr->uh_dport)>=rule->un_ty.L3L4.is.udp._dstPortLowerBound && (udphdr->uh_dport)<=rule->un_ty.L3L4.is.udp._dstPortUpperBound))
                                        break;
l3l4_shared:
                        if (((iphdr->ip_tos & rule->un_ty.L3L4._tosMask) == rule->un_ty.L3L4._tos) && (rule->dsid==dsid)) {
                                if (rule->isIPRange_ == 1) {

                                        if ((rule->un_ty.L3L4._srcIpAddr==0 && rule->un_ty.L3L4._srcIpAddrMask==0) ||
                                            (rule->un_ty.L3L4._srcIpAddr<=ip_s && rule->un_ty.L3L4._srcIpAddrMask>=ip_s)) {
                                                if ((rule->un_ty.L3L4._dstIpAddr==0 && rule->un_ty.L3L4._dstIpAddrMask==0) ||
                                                    (rule->un_ty.L3L4._dstIpAddr<=ip_d && rule->un_ty.L3L4._dstIpAddrMask>=ip_d))
                                                        return (_rtl8651_tblDrvAclRule_t *)rule;
                                        }
                                }
                                else {
                                        if ((( ip_s & rule->un_ty.L3L4._srcIpAddrMask) == rule->un_ty.L3L4._srcIpAddr) && ((ip_d & rule->un_ty.L3L4._dstIpAddrMask) == rule->un_ty.L3L4._dstIpAddr) )
                                                return (_rtl8651_tblDrvAclRule_t *)rule;
                                }
                        }







                        }
                        break;

                case 0x06:
                        {
                         if ((rule->un_ty.IFSEL._gidxSel & (1<<(ip_s&0x3)))
                                && (rule->dsid==dsid))
                                return (_rtl8651_tblDrvAclRule_t *)rule;
                        }
                        break;

                default: do {} while (0);
                }
        }







        if (defPermit != (int8 *)((void *)0)) {
                if (Ingress == 1) {
                        aclCount = ((&netIfPtr->inAclHead)->tqh_count);
                } else aclCount = ((&netIfPtr->outAclHead)->tqh_count);
                if (aclCount > 0) {
                        if (netIfPtr->defAclAction == 0x01)
                                *defPermit = 1;
                        else *defPermit = 0;
                } else *defPermit = 1;
        }
        return (_rtl8651_tblDrvAclRule_t *)((void *)0);
}
# 19877 "rtl8651_tblDrv.c"
int32 rtl8651a_addAclRule(uint32 SessionID,int8 * ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;
        if (rule == ((void *)0)) return -1400;
        if ((rule->matchType_ != 0x00) && (rule->matchType_ != 0x01))
                return -1403;
        if ((Ingress == 0) && (rule->pktOpApp != 0))
                return -1404;

        rtlglue_drvMutexLock();
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))))
                retval = _rtl8651_addAclRule(SessionID, netif_t, Ingress, rule, 0x00);
        else retval = -7;
        rtlglue_drvMutexUnlock();
        return retval;
}
# 19907 "rtl8651_tblDrv.c"
int32 rtl8651a_delAclRule(uint32 SessionID,int8 *ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;
        if (rule == ((void *)0)) return -1400;
        rtlglue_drvMutexLock();
        if ((netif_t = GET_NETWORK_INTERFACE(ifName, ((void *)0))) )
                retval = _rtl8651_delAclRule(SessionID, netif_t, Ingress, rule);
        else retval = -7;
        rtlglue_drvMutexUnlock();
        return retval;
}
# 19936 "rtl8651_tblDrv.c"
int32 rtl8651a_addAclRuleExt(uint32 sessionID,int8 * ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;
        if (rule == ((void *)0)) return -1400;

        rtlglue_drvMutexLock();
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))))
                retval = _rtl8651_addAclRule(sessionID, netif_t, Ingress, rule, 0x01);
        else retval = -7;
        rtlglue_drvMutexUnlock();
        return retval;
}
# 19964 "rtl8651_tblDrv.c"
int32 rtl8651a_delAclRuleExt(uint32 sessionID,int8 *ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;
        if (rule == ((void *)0)) return -1400;
        rtlglue_drvMutexLock();
        if ((netif_t = GET_NETWORK_INTERFACE(ifName, ((void *)0))) )
                retval = _rtl8651_delAclRule(sessionID, netif_t, Ingress, rule);
        else retval = -7;
        rtlglue_drvMutexUnlock();
        return retval;
}
# 19997 "rtl8651_tblDrv.c"
int32 rtl8651_addAclRuleByIndexing(uint16 rIdx, int8 *ifName, int8 Ingress, rtl8651_tblDrvAclRule_t *rule) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        _rtl8651_tblDrvAclRule_t *trackAcl, *addAcl;
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} *aclHead;
        int32 retval = 0;


        if ( rule == ((void *)0))
                return -1400;
        if ( (rule->actionType_!=0x02) && (rule->actionType_!=0x01) &&
             (rule->actionType_!=0x04) && (rule->actionType_!=0x03) &&
             (rule->actionType_!=0x05) )
                return -1401;
        rtlglue_drvMutexLock();

        if (aclMode == 0x01) {
                retval = -1402;
                goto out;
        }

        if ((addAcl = ((&DrvTbl.freeList.aclRule)->tqh_first)) == ((void *)0)) {
                retval = -9;
                goto out;
        }

        if ((netIfPtr = GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }
        if (Ingress == 1)
                aclHead = (struct _aclStruct *)&netIfPtr->inAclHead;
        else aclHead = (struct _aclStruct *)&netIfPtr->outAclHead;
        for (trackAcl = ((aclHead)->tqh_first); trackAcl; trackAcl = ((trackAcl)->nextRule.tqe_next)) {

                if ((trackAcl->aclIdx == rIdx)) { rtlglue_drvMutexUnlock(); return -2; };

                if (rIdx < trackAcl->aclIdx)
                        break;
        }
        do { if (((addAcl)->nextRule.tqe_next) != ((void *)0)) (addAcl)->nextRule.tqe_next->nextRule.tqe_prev = (addAcl)->nextRule.tqe_prev; else (&DrvTbl.freeList.aclRule)->tqh_last = (addAcl)->nextRule.tqe_prev; *(addAcl)->nextRule.tqe_prev = (addAcl)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_count--;} while (0);
        bzero(addAcl, sizeof(_rtl8651_tblDrvAclRule_t)-sizeof(addAcl->nextRule));
        rtl8651_memcpy(addAcl, rule, sizeof(rtl8651_tblDrvAclRule_t));
        addAcl->aclIdx = rIdx;
        if (trackAcl == (_rtl8651_tblDrvAclRule_t *) ((void *)0))
                do { (addAcl)->nextRule.tqe_next = ((void *)0); (addAcl)->nextRule.tqe_prev = (aclHead)->tqh_last; *(aclHead)->tqh_last = (addAcl); (aclHead)->tqh_last = &(addAcl)->nextRule.tqe_next; (aclHead)->tqh_count++;} while (0);
        else do { (addAcl)->nextRule.tqe_prev = (trackAcl)->nextRule.tqe_prev; (addAcl)->nextRule.tqe_next = (trackAcl); *(trackAcl)->nextRule.tqe_prev = (addAcl); (trackAcl)->nextRule.tqe_prev = &(addAcl)->nextRule.tqe_next; (aclHead)->tqh_count++;} while (0);
        if ((((&netIfPtr->inAclHead)->tqh_count)+((&netIfPtr->outAclHead)->tqh_count)) == 1)
                aclMode = 0x02;
        _rtl8651_arrangeAllACL();

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 20064 "rtl8651_tblDrv.c"
int32 rtl8651_delAclRuleByIndexing(uint16 rIdx, int8 *ifName, int8 Ingress) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        _rtl8651_tblDrvAclRule_t *delAcl;
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} *aclHead;
        int32 retval = 0;

        rtlglue_drvMutexLock();
        if (aclMode == 0x01) {
                retval = -1402;
                goto out;
        }

        if ((netIfPtr = GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }
        if (Ingress == 1)
                aclHead = (struct _aclStruct *)&netIfPtr->inAclHead;
        else aclHead = (struct _aclStruct *)&netIfPtr->outAclHead;
        for (delAcl = ((aclHead)->tqh_first); delAcl; delAcl = ((delAcl)->nextRule.tqe_next)) {
                if (delAcl->aclIdx == rIdx)
                        break;
        }
        if (delAcl == ((void *)0)) {
                retval = -3;
                goto out;
        }
        do { if (((delAcl)->nextRule.tqe_next) != ((void *)0)) (delAcl)->nextRule.tqe_next->nextRule.tqe_prev = (delAcl)->nextRule.tqe_prev; else (aclHead)->tqh_last = (delAcl)->nextRule.tqe_prev; *(delAcl)->nextRule.tqe_prev = (delAcl)->nextRule.tqe_next; (aclHead)->tqh_count--;} while (0);
        do { if (((delAcl)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(delAcl)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(delAcl)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (delAcl); (delAcl)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
        if ((((&netIfPtr->inAclHead)->tqh_count)+((&netIfPtr->outAclHead)->tqh_count)) == 0)
                aclMode = 0x00;
        _rtl8651_arrangeAllACL();

out:
        rtlglue_drvMutexUnlock();
        return 0;
}
# 20109 "rtl8651_tblDrv.c"
int32 rtl8651a_flushAclRule(uint32 SessionID,int8 *ifName, int8 Ingress) {
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
        _rtl8651_tblDrvAclRule_t *delAcl;
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} *aclHead;
        int32 retval = 0;
        uint32 dsid;


        rtlglue_drvMutexLock();
        dsid=_rtl8651_SessionIDToDSID(SessionID);

        if ((netIfPtr = GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }
        if (Ingress == 1)
                aclHead = (struct _aclStruct *)&netIfPtr->inAclHead;
        else aclHead = (struct _aclStruct *)&netIfPtr->outAclHead;

        for( delAcl = ((aclHead)->tqh_first);
             delAcl;
             )
        {
                if (delAcl->dsid==dsid)
                {

                        _rtl8651_tblDrvAclRule_t *next;
                        next = ((delAcl)->nextRule.tqe_next);
                        do { if (((delAcl)->nextRule.tqe_next) != ((void *)0)) (delAcl)->nextRule.tqe_next->nextRule.tqe_prev = (delAcl)->nextRule.tqe_prev; else (aclHead)->tqh_last = (delAcl)->nextRule.tqe_prev; *(delAcl)->nextRule.tqe_prev = (delAcl)->nextRule.tqe_next; (aclHead)->tqh_count--;} while (0);
                        do { if (((delAcl)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(delAcl)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(delAcl)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (delAcl); (delAcl)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                        delAcl = next;
                }
                else
                {
                        delAcl = ((delAcl)->nextRule.tqe_next);
                }
        }

        do {} while (0);
        _rtl8651_acl_drop_nolog[dsid]=0;
        _rtl8651_arrangeAllACL();

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 20167 "rtl8651_tblDrv.c"
int32 rtl8651a_setDefaultAcl(uint32 SessionID,int8 *ifName, int8 defAction) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;



        if (( (defAction != 0x03) && (defAction != 0x02) && (defAction != 0x01) && (defAction != 0x06) )) return -6;;






        rtlglue_drvMutexLock();

        netif_t = GET_NETWORK_INTERFACE(ifName, ((void *)0));
        if ((netif_t==((void *)0))) { rtlglue_drvMutexUnlock(); return -7; };
        netif_t->defAclAction = defAction;
        _rtl8651_arrangeAllACL();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 20199 "rtl8651_tblDrv.c"
int32 _rtl8651_getDefaultAcl(int8 *ifName, int8 * defAction) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;


        netif_t = GET_NETWORK_INTERFACE(ifName, ((void *)0));
        if ((netif_t==((void *)0))) return -7;;

        *defAction = netif_t->defAclAction;

        return 0;
}
# 20226 "rtl8651_tblDrv.c"
static uint32 _rtl8651_algToAclCount(void) {
        rtl8651_tblDrv_algEntry_t *trackAlgPtr;
        uint32 count = 0;

        for((trackAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (trackAlgPtr); (trackAlgPtr) = (trackAlgPtr)->nextAlgEntry.sle_next) {
                if (trackAlgPtr->toAsic == 1) continue;
                if (trackAlgPtr->tcpServer == 1) count++;
                if (trackAlgPtr->tcpClient == 1) count++;
                if (trackAlgPtr->udpServer == 1) count++;
                if (trackAlgPtr->udpClient == 1) count++;
        }
        return count;
}


static int32 _rtl8651_delAlgEntryFromAsic(rtl8651_tblDrv_algEntry_t *algPtr) {
        rtl8651_tblDrv_algAsicArrangementEntry_t *asicAlgPtr;
        int32 algIdx, count = 0;

        asicAlgPtr=&AsicTableUsage.alg[0];
        for(algIdx=0; algIdx<128; algIdx++, asicAlgPtr++)
                if (asicAlgPtr->valid == 1 &&
                        asicAlgPtr->port >= algPtr->startPort && asicAlgPtr->port <= algPtr->endPort) {
                        asicAlgPtr->valid = 0;
                        rtl8651_delAsicAlg(algIdx);
                count++;
        }
        algPtr->toAsic = 0;
        return count;
}

static int32 _rtl8651_addAlgEntryToAsic(rtl8651_tblDrv_algEntry_t *algPtr) {
        rtl8651_tblDrv_algAsicArrangementEntry_t *asicAlgPtr;
        uint16 port = algPtr->startPort;
        int32 algIdx;

        asicAlgPtr=&AsicTableUsage.alg[0];
        for(algIdx=0; algIdx<128&&port<=algPtr->endPort; algIdx++, asicAlgPtr++)
                if (asicAlgPtr->valid == 0) {
                        asicAlgPtr->port = port;
                        asicAlgPtr->valid = 1;
                        convert_setAsicAlg(algIdx, port);
                        port++;
                }
        algPtr->toAsic = 1;
        return (port - algPtr->startPort);
}


static void _rtl8651_arrangeAsicAlg(void) {
        rtl8651_tblDrv_algEntry_t *trackAlgPtr, *maxAlgEntry=((void *)0), *minAclEntry=((void *)0);
        uint32 count = 0, maxAlgCount, minAclCount, cnt;






        for((trackAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (trackAlgPtr); (trackAlgPtr) = (trackAlgPtr)->nextAlgEntry.sle_next) {
                if (trackAlgPtr->toAsic == 1) {
                        count += (trackAlgPtr->endPort-trackAlgPtr->startPort+1);
                        maxAlgEntry = trackAlgPtr;
                }
                else if (minAclEntry == ((void *)0))
                        minAclEntry = trackAlgPtr;
        }
# 20308 "rtl8651_tblDrv.c"
        if (minAclEntry == (rtl8651_tblDrv_algEntry_t *)((void *)0))
                return;


        minAclCount = (minAclEntry->endPort - minAclEntry->startPort + 1);
        if (maxAlgEntry == (rtl8651_tblDrv_algEntry_t *)((void *)0)) {
                do {} while (0);
                do {} while (0);
                if (minAclCount > 128)
                        return;
                cnt = _rtl8651_addAlgEntryToAsic(minAclEntry);
                do {} while (0);
        } else {
                do {} while (0);
                if (128 - count >= minAclCount) {
                        cnt = _rtl8651_addAlgEntryToAsic(minAclEntry);
                        do {} while (0);
                        return;
                }
                maxAlgCount = (maxAlgEntry->endPort - maxAlgEntry->startPort + 1);
                if (maxAlgCount > minAclCount) {

                        cnt = _rtl8651_delAlgEntryFromAsic(maxAlgEntry);
                        do {} while (0);
                        cnt = _rtl8651_addAlgEntryToAsic(minAclEntry);
                        do {} while (0);
                }
        }
}


rtl8651_tblDrv_algEntry_t *_rtl8651_getAlgEntry(int8 isTcp, int8 *isServer, int8 *isClient, uint16 sport, uint16 eport) {
        rtl8651_tblDrv_algEntry_t *tmpAlgEntry;
        uint32 flag = 0;


        if (isServer == 0 && isClient == 0)
                return (rtl8651_tblDrv_algEntry_t *)0;


        for((tmpAlgEntry) = (&DrvTbl.inuseList.alg)->slh_first; (tmpAlgEntry); (tmpAlgEntry) = (tmpAlgEntry)->nextAlgEntry.sle_next) {
                if (tmpAlgEntry->startPort == sport && tmpAlgEntry->endPort == eport) {
                        flag = (isTcp==1)? (tmpAlgEntry->tcpClient|tmpAlgEntry->tcpServer) :
                                                                (tmpAlgEntry->udpClient|tmpAlgEntry->udpServer);
                        if (flag) {
                                *isServer = (isTcp == 1)? tmpAlgEntry->tcpServer : tmpAlgEntry->udpServer;
                                *isClient = (isTcp == 1)? tmpAlgEntry->tcpClient : tmpAlgEntry->udpClient;
                                return tmpAlgEntry;
                        }
                }
        }
        return (rtl8651_tblDrv_algEntry_t *)0;
}
# 20378 "rtl8651_tblDrv.c"
int32 rtl8651_addALGRule(uint16 startPort, uint16 endPort, int8 isTcp, int8 isServer, int8 isClient) {
        rtl8651_tblDrv_algEntry_t *trackAlgPtr, *tmpAlgPtr, *algPtr;

        if ((isServer==0&&isClient==0)) return -1200;;
        if ((startPort>endPort)) return -1201;;
        rtlglue_drvMutexLock();

        for((trackAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (trackAlgPtr); (trackAlgPtr) = (trackAlgPtr)->nextAlgEntry.sle_next) {
                if (trackAlgPtr->startPort == startPort && trackAlgPtr->endPort == endPort)
                        break;
                if (( (trackAlgPtr->startPort <= startPort && trackAlgPtr->endPort >= startPort)|| (trackAlgPtr->startPort <= endPort && trackAlgPtr->endPort >= endPort) || (trackAlgPtr->startPort <= startPort && trackAlgPtr->endPort >= endPort) || (trackAlgPtr->startPort >= startPort && trackAlgPtr->endPort <= endPort) )) { rtlglue_drvMutexUnlock(); return -1202; };







        }

        if (trackAlgPtr == (rtl8651_tblDrv_algEntry_t *) ((void *)0)) {
                if ((DrvTbl.freeList.alg.slh_first==((void *)0))) { rtlglue_drvMutexUnlock(); return -9; };
                trackAlgPtr = ((&DrvTbl.freeList.alg)->slh_first);
                do { (&DrvTbl.freeList.alg)->slh_first = (&DrvTbl.freeList.alg)->slh_first->nextAlgEntry.sle_next; } while (0);
                trackAlgPtr->nextAlgEntry.sle_next = ((void *)0);

                algPtr = (rtl8651_tblDrv_algEntry_t *)((void *)0);
                for((tmpAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (tmpAlgPtr); (tmpAlgPtr) = (tmpAlgPtr)->nextAlgEntry.sle_next) {
                        if (tmpAlgPtr->endPort-tmpAlgPtr->startPort > endPort-startPort)
                                break;
                        algPtr = tmpAlgPtr;
                }
                if (algPtr == (rtl8651_tblDrv_algEntry_t *)((void *)0))
                        do { (trackAlgPtr)->nextAlgEntry.sle_next = (&DrvTbl.inuseList.alg)->slh_first; (&DrvTbl.inuseList.alg)->slh_first = (trackAlgPtr); } while (0);
                else do { (trackAlgPtr)->nextAlgEntry.sle_next = (algPtr)->nextAlgEntry.sle_next; (algPtr)->nextAlgEntry.sle_next = (trackAlgPtr); } while (0);
                trackAlgPtr->startPort = startPort;
                trackAlgPtr->endPort = endPort;
                trackAlgPtr->tcpServer = 0;
                trackAlgPtr->tcpClient = 0;
                trackAlgPtr->udpServer = 0;
                trackAlgPtr->udpClient = 0;
                trackAlgPtr->toAsic = 0;
                _rtl8651_arrangeAsicAlg();
        }


        if(isTcp == 1) {
                if (((isServer==1&&trackAlgPtr->tcpServer== 1) || (isClient==1&&trackAlgPtr->tcpClient== 1) )) { rtlglue_drvMutexUnlock(); return -2; };





                if(isServer == 1) trackAlgPtr->tcpServer = 1;
                if(isClient == 1) trackAlgPtr->tcpClient = 1;
        }
        else {
                do {} while (0);
                if (((isServer == 1 && trackAlgPtr->udpServer == 1) || (isClient == 1 && trackAlgPtr->udpClient == 1) )) { rtlglue_drvMutexUnlock(); return -2; };





                if(isServer == 1) trackAlgPtr->udpServer = 1;
                if(isClient == 1) trackAlgPtr->udpClient = 1;
        }
        for((tmpAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (tmpAlgPtr); (tmpAlgPtr) = (tmpAlgPtr)->nextAlgEntry.sle_next)
                if (tmpAlgPtr->toAsic == 0)
                        _rtl8651_arrangeAllACL();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 20467 "rtl8651_tblDrv.c"
int32 rtl8651_delALGRule(uint16 startPort, uint16 endPort, int8 isTcp, int8 isServer, int8 isClient) {
        rtl8651_tblDrv_algEntry_t *delAlgPtr;

        if ((isServer==0&&isClient==0)) return -1200;;
        if ((startPort>endPort)) return -1201;;
        rtlglue_drvMutexLock();
        for((delAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (delAlgPtr); (delAlgPtr) = (delAlgPtr)->nextAlgEntry.sle_next) {
                if (delAlgPtr->startPort == startPort && delAlgPtr->endPort == endPort)
                        break;
                if (( (delAlgPtr->startPort <= startPort && delAlgPtr->endPort >= startPort) || (delAlgPtr->startPort <= endPort && delAlgPtr->endPort >= endPort) || (delAlgPtr->startPort <= startPort && delAlgPtr->endPort >= endPort) || (delAlgPtr->startPort >= startPort && delAlgPtr->endPort <= endPort) )) { rtlglue_drvMutexUnlock(); return -3100; };







        }
        if ((delAlgPtr==((void *)0))) { rtlglue_drvMutexUnlock(); return -3; };
        if(isTcp == 1) {
                if (( (delAlgPtr->tcpServer == 0 && isServer == 1) || (delAlgPtr->tcpClient == 0 && isClient == 1) )) { rtlglue_drvMutexUnlock(); return -3; };





                if(isServer == 1) delAlgPtr->tcpServer = 0;
                if(isClient == 1) delAlgPtr->tcpClient = 0;
        }
        else {
                do {} while (0);
                if (( (delAlgPtr->udpServer == 0 && isServer == 1) || (delAlgPtr->udpClient == 0 && isClient == 1) )) { rtlglue_drvMutexUnlock(); return -3; };





                if(isServer == 1) delAlgPtr->udpServer = 0;
                if(isClient == 1) delAlgPtr->udpClient = 0;
        }
        if (delAlgPtr->tcpServer == 0 && delAlgPtr->tcpClient == 0 &&
                delAlgPtr->udpServer == 0 && delAlgPtr->udpClient == 0) {
                do { if ((&DrvTbl.inuseList.alg)->slh_first == (delAlgPtr)) { do { ((&DrvTbl.inuseList.alg))->slh_first = ((&DrvTbl.inuseList.alg))->slh_first->nextAlgEntry.sle_next; } while (0); } else { struct rtl8651_tblDrv_algEntry_s *curelm = (&DrvTbl.inuseList.alg)->slh_first; while( curelm->nextAlgEntry.sle_next != (delAlgPtr) ) curelm = curelm->nextAlgEntry.sle_next; curelm->nextAlgEntry.sle_next = curelm->nextAlgEntry.sle_next->nextAlgEntry.sle_next; } } while (0);
                do { (delAlgPtr)->nextAlgEntry.sle_next = (&DrvTbl.freeList.alg)->slh_first; (&DrvTbl.freeList.alg)->slh_first = (delAlgPtr); } while (0);
                _rtl8651_delAlgEntryFromAsic(delAlgPtr);
                _rtl8651_arrangeAsicAlg();
        }
        _rtl8651_arrangeAllACL();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 20530 "rtl8651_tblDrv.c"
typedef struct rtl8651_DoS_Table_s {
        int32 (*p_dosfunc)(uint16, uint32, uint32, int8);

        uint32 vlanMask;
        uint32 dostype;
} rtl8651_DoS_Table_t;
# 20545 "rtl8651_tblDrv.c"
rtl8651_DoS_Table_t rtl8651_Dos_Table[] =
{
        { _rtl8651_DoS_tcpSynFlood, 0x00, 0x00000001 },
        { _rtl8651_DoS_tcpFinFlood, 0x00, 0x00008000 },
        { _rtl8651_DoS_udpEchoChargen, 0x00, 0x00000080 },
        { _rtl8651_DoS_fullXmasScan, 0x00, 0x00000100 },
        { _rtl8651_DoS_fullSapuScan, 0x00, 0x00000200 },
        { _rtl8651_DoS_finScan, 0x00, 0x00000400 },
        { _rtl8651_DoS_synFinScan, 0x00, 0x00000800 },
        { _rtl8651_DoS_nullScan, 0x00, 0x00001000 },
        { _rtl8651_DoS_nmapXmasScan, 0x00, 0x00002000 },
        { _rtl8651_DoS_vecnaScan, 0x00, 0x00004000 },
        { _rtl8651_DoS_ipSpoofing, 0x00, 0x00000008 },
        { _rtl8651_DoS_udpFlood, 0x00, 0x00000004 },
        { _rtl8651_DoS_icmpFlood, 0x00, 0x00000002 },
        {_rtl8651_DoS_portScan, 0x00, 0x00010000},
        { ((void *)0), 0x00, 0x00 },
};


static int32 _rtl8651_DoS_tcpSynFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp.un.s._syn = 0x01;
                rule.un_ty.L3L4.is.tcp._flagMask = rule.un_ty.L3L4.is.tcp.un._flag;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_tcpFinFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp.un.s._fin = 0x01;
                rule.un_ty.L3L4.is.tcp._flagMask = rule.un_ty.L3L4.is.tcp.un._flag;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}


static int32 _rtl8651_DoS_icmpFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x02;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.icmp._type = 8;
                rule.un_ty.L3L4.is.icmp._typeMask = 0xff;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_udpFlood(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x01;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.ip._proto = 17;
                rule.un_ty.L3L4.is.ip._protoMask = 0xff;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_ipSpoofing(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        rtl8651_tblDrv_vlanTable_t *vlan_t = &DrvTbl.vlan[(vid& (8 -1))];
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        _rtl8651_tblDrvAclRule_t rule;
        int32 vidx, count = 0;





        if (vlan_t->internal == 1)
                return 0;
        do {} while (0);
        vlan_t = &DrvTbl.vlan[0];
        for(vidx=0; vidx<8; vidx++, vlan_t++) {
                if (vlan_t->valid == 0 || vlan_t->internal == 0 || vlan_t->netif_t == 0)
                        continue;

                netif_t = vlan_t->netif_t;
                for((ipintf_t) = (&netif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                        if (ipintf_t->lanSideExternal == 1)
                                continue;
                        if (wr == 1) {
                                { (&rule)->un_ty.L3L4._srcIpAddr = (ipintf_t->ipAddr.slh_first->ipAddr)&ipintf_t->ipMask; (&rule)->un_ty.L3L4._srcIpAddrMask = ipintf_t->ipMask; (&rule)->un_ty.L3L4._dstIpAddr = 0; (&rule)->un_ty.L3L4._dstIpAddrMask = 0; (&rule)->un_ty.L3L4._tos = 0; (&rule)->un_ty.L3L4._tosMask = 0; (&rule)->un_ty.L3L4.is.ip._proto = 0; (&rule)->un_ty.L3L4.is.ip._protoMask = 0; (&rule)->un_ty.L3L4.is.ip.un._flag = 0; (&rule)->un_ty.L3L4.is.ip._flagMask = 0; (&rule)->ruleType_ = 0x01; (&rule)->actionType_ = 0x03;};






                                rule.pktOpApp = 6;;
                                rtl8651_setAsicAclRule(aclStart, &rule);
                                aclStart++;
                                if (aclStart > aclEnd)
                                        return ++count;
                        }
                        count++;
                }
        }
        return count;
}

static int32 _rtl8651_DoS_udpEchoChargen(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;
        uint16 port[] = { 7, 17, 19 };
        int32 count=0, pidx;



        do {} while (0);
        if (wr == 1) {
                for(pidx=0; pidx<3; pidx++) {
                        { (&rule)->actionType_ = 0x03; (&rule)->ruleType_ = 0x05; (&rule)->un_ty.L3L4._dstIpAddr = 0; (&rule)->un_ty.L3L4._dstIpAddrMask = 0; (&rule)->un_ty.L3L4._srcIpAddr = 0; (&rule)->un_ty.L3L4._srcIpAddrMask = 0; (&rule)->un_ty.L3L4._tos = 0; (&rule)->un_ty.L3L4._tosMask = 0; (&rule)->un_ty.L3L4.is.udp._srcPortUpperBound = 0xffff; (&rule)->un_ty.L3L4.is.udp._srcPortLowerBound = 0x00; (&rule)->un_ty.L3L4.is.udp._dstPortUpperBound = port[pidx]; (&rule)->un_ty.L3L4.is.udp._dstPortLowerBound = port[pidx];};





                        rule.pktOpApp = 6;;
                        rtl8651_setAsicAclRule(aclStart, &rule);
                        aclStart++; count++;
                        if (aclStart > aclEnd)
                                return count;
                }
        }
        return 3;
}


static int32 _rtl8651_DoS_fullXmasScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._flagMask = 0xff;
                rule.un_ty.L3L4.is.tcp.un._flag = 0xff;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_fullSapuScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._flagMask = 0xff;
                rule.un_ty.L3L4.is.tcp.un.s._urg = 0x01;
                rule.un_ty.L3L4.is.tcp.un.s._ack = 0x01;
                rule.un_ty.L3L4.is.tcp.un.s._psh = 0x01;
                rule.un_ty.L3L4.is.tcp.un.s._syn = 0x01;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_finScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;


        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp.un.s._fin = 0x01;
                rule.un_ty.L3L4.is.tcp._flagMask = 0xff;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_synFinScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp.un.s._fin = 0x01;
                rule.un_ty.L3L4.is.tcp.un.s._syn = 0x01;
                rule.un_ty.L3L4.is.tcp._flagMask = 0xff;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_nullScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp.un._flag = 0x00;
                rule.un_ty.L3L4.is.tcp._flagMask = 0xff;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_nmapXmasScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;


        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp.un.s._fin = 0x01;
                rule.un_ty.L3L4.is.tcp.un.s._psh = 0x01;
                rule.un_ty.L3L4.is.tcp.un.s._urg = 0x01;
                rule.un_ty.L3L4.is.tcp._flagMask = 0xff;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_DoS_vecnaScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        _rtl8651_tblDrvAclRule_t rule;
        int32 i, count = 0;


        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp._flagMask = 0xff;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                for(i=0; i<5; i++) {
                        switch(i) {
                        case 0: rule.un_ty.L3L4.is.tcp.un.s._urg = 0x01; break;
                        case 1: rule.un_ty.L3L4.is.tcp.un.s._psh = 0x01; break;
                        case 2: rule.un_ty.L3L4.is.tcp.un.s._urg = 0x01; rule.un_ty.L3L4.is.tcp.un.s._fin = 0x01; break;
                        case 3: rule.un_ty.L3L4.is.tcp.un.s._psh = 0x01; rule.un_ty.L3L4.is.tcp.un.s._fin = 0x01; break;
                        case 4: rule.un_ty.L3L4.is.tcp.un.s._urg = 0x01; rule.un_ty.L3L4.is.tcp.un.s._psh = 0x01; break;
                        default: do {} while (0);
                        }
                        rule.pktOpApp = 6;;
                        rtl8651_setAsicAclRule(aclStart, &rule);
                        count++; aclStart++;
                        if (aclStart> aclEnd)
                                return count;
                        rule.un_ty.L3L4.is.tcp.un._flag = 0x00;
                }
        } else count = 5;
        return count;
}

static int32 _rtl8651_DoS_portScan(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr)
{
        _rtl8651_tblDrvAclRule_t rule;



        do {} while (0);
        if (wr == 1) {
                memset(&rule, 0, sizeof(_rtl8651_tblDrvAclRule_t));
                rule.ruleType_ = 0x04;
                rule.actionType_ = 0x03;
                rule.un_ty.L3L4.is.tcp.un.s._rst = 0x01;
                rule.un_ty.L3L4.is.tcp._flagMask = rule.un_ty.L3L4.is.tcp.un._flag;
                rule.un_ty.L3L4.is.tcp._srcPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._srcPortLowerBound = 0x00;
                rule.un_ty.L3L4.is.tcp._dstPortUpperBound = 0xffff;
                rule.un_ty.L3L4.is.tcp._dstPortLowerBound = 0x00;
                rule.pktOpApp = 6;;
                rtl8651_setAsicAclRule(aclStart, &rule);
        }
        return 1;
}

static int32 _rtl8651_addAclRuleForDoS(uint16 vid, uint32 aclStart, uint32 aclEnd, int8 wr) {
        rtl8651_DoS_Table_t *dos_t;
        int32 count=0, addCount=0;




        for(dos_t=&rtl8651_Dos_Table[0]; dos_t->p_dosfunc; dos_t++)
        {
                if (dos_t->vlanMask)
                {
                        int32 i;
                        rtl8651_tblDrv_vlanTable_t *vlanp;
                        int32 addAcl = 0;

                        for (i = 0 ; i < 8 ; i ++)
                        {
                                if (!((1<<i)&dos_t->vlanMask))
                                        continue;
                                vlanp = &DrvTbl.vlan[i];
                                if (vlanp->vid == vid)
                                {
                                        addAcl = 1;
                                        goto add;
                                }
                        }
add:
                        if (addAcl == 1)
                        {
                                addCount = (dos_t->p_dosfunc)(vid, aclStart, aclEnd, wr);
                                count+=addCount;
                                if (wr == 1) {
                                        aclStart += addCount;
                                        if (aclStart > aclEnd)
                                                return count;
                                }
                        }
                }
        }
        return count;
}






int32 _rtl8651_enableDoS(uint32 dostype, int8 enable, uint32 vlanMask) {
        rtl8651_DoS_Table_t *dos_t;
        uint32 i, mask, vlanBit;


        vlanBit = 0;
        for (i = 0 ; i < 8 ; i ++)
                vlanBit = (vlanBit << 1) + 1;
        mask = vlanMask & vlanBit;

        for(dos_t=&rtl8651_Dos_Table[0]; dos_t->p_dosfunc; dos_t++)
                if (dostype == dos_t->dostype) {
                        if ((enable == 1) && mask && (dos_t->vlanMask != mask))
                        {
                                dos_t->vlanMask = mask;
                                _rtl8651_arrangeAllACL();
                        }
                        if (((enable == 0) || (enable == 1 && !mask)) && (dos_t->vlanMask))
                        {
                                dos_t->vlanMask = 0;
                                _rtl8651_arrangeAllACL();
                        }
                        return 0;
                }
        return -1;
}



 void rtl8651_updatePortStatus(uint32 port, int8 linkUp) {




        rtlglue_drvMutexLock();

        if(linkUp == 0)
                _rtl8651_removeArpAndNaptFlowWhenLinkDown(port,((void *)0));

        rtlglue_drvMutexUnlock();
        return;
}






int32 _rtl8651_ipClassMonitoring(ipaddr_t dip, rtl8651_tblDrv_arpEntry_t *arp_t)
{
        ipClassABMonitorTable_t *entry_t;
        uint32 index;


        do {} while (0);

        entry_t = ipClassABMonitorTable;
        for(index=0; index<ipClassCount; index++, entry_t++) {
                if (dip == entry_t->dip) {
                        entry_t->value ++;

                        if(entry_t->value == (500 +1))
                                _rtl8651_ipClassTimeUpdate();
                        return 0;
                }
        }

        if (ipClassCount < 10) {
                entry_t = &ipClassABMonitorTable[ipClassCount++];
                entry_t->dip = dip;
                entry_t->arp_t = arp_t;
                entry_t->value = 1;
                return 0;
        }
        return -1;
}



void _rtl8651_ipClassTimeUpdate(void)
{
        rtl8651_tblDrv_routeTable_t *l3Entry_t;
        ipClassABMonitorTable_t *entry_t, *select_t;
        rtl865x_tblAsicDrv_routingParam_t asic_l3;
        rtl8651_tblDrv_filterDbTableEntry_t *macInfo;
        uint32 max_l3;
        uint32 index, count;
        int32 retval;



        if (ipClassCount == 0 || rtEntry == (8 -1))
                return;

        max_l3 = 8 - rtEntry - 1;
        count = 0;

        while (max_l3>0 && count<ipClassCount) {

                entry_t = select_t = ipClassABMonitorTable;
                for(index=0; index<ipClassCount; index++, entry_t++) {
                        if (entry_t->value > select_t->value)
                                select_t = entry_t;
                }

                if (select_t->value > 500) {
                        l3Entry_t = DrvTbl.route; max_l3 --;
                        while (cur_rt_t->valid) {
                                if (--cur_rt_t == DrvTbl.route)
                                        cur_rt_t = &DrvTbl.route[8 -2];
                        }
                        do {} while (0);
                        macInfo = select_t->arp_t->macInfo;
                        asic_l3.ipAddr = select_t->dip;
                        asic_l3.ipMask = 0xffffffff;
                        asic_l3.process = 0x01;
                        asic_l3.vidx = select_t->arp_t->vid;
                        asic_l3.nextHopRow = rtl8651_filterDbIndex(&macInfo->macAddr);
                        asic_l3.nextHopColumn = macInfo->asicPos;
                        retval = rtl8651_setAsicRouting( (cur_rt_t-DrvTbl.route), &asic_l3);
                        do {} while (0);
                        cur_rt_t->ipAddr = select_t->dip;
                        if (--cur_rt_t == DrvTbl.route)
                                cur_rt_t = &DrvTbl.route[8 -2];
                        select_t->value = 0;
                }
                else break;
                count ++;

        }


        ipClassCount = 0;
        bzero(ipClassABMonitorTable, sizeof(ipClassABMonitorTable_t)*ipClassCount);
}
# 21105 "rtl8651_tblDrv.c"
static uint32 _rtl8651_tryAddAclForPolicyBasedQos(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint32 aclStart, uint32 aclEnd)
{
        _rtl8651_tblDrvPolicy_t *policy_t;
        _rtl8651_tblDrvAclRule_t rule;
        uint32 count=0;

        do {} while (0);
        if (aclStart > aclEnd)
                return 0;
        bzero(&rule, sizeof(_rtl8651_tblDrvAclRule_t));
        for (policy_t = ((&netif_t->policyQosHead)->tqh_first); policy_t; policy_t = ((policy_t)->nextPolicy_t.tqe_next)) {
                switch(policy_t->proto)
                {
                case 0x02:
                        rule.ruleType_ = 0x04;
                        rule.un_ty.L3L4.is.tcp._srcPortUpperBound = policy_t->sport_end;
                        rule.un_ty.L3L4.is.tcp._srcPortLowerBound = policy_t->sport_start;
                        rule.un_ty.L3L4.is.tcp._dstPortUpperBound = policy_t->dport_end;
                        rule.un_ty.L3L4.is.tcp._dstPortLowerBound = policy_t->dport_start;
                        goto commL3;

                case 0x03:
                        rule.ruleType_ = 0x05;
                        rule.un_ty.L3L4.is.udp._srcPortUpperBound = policy_t->sport_end;
                        rule.un_ty.L3L4.is.udp._srcPortLowerBound = policy_t->sport_start;
                        rule.un_ty.L3L4.is.udp._dstPortUpperBound = policy_t->dport_end;
                        rule.un_ty.L3L4.is.udp._dstPortLowerBound = policy_t->dport_start;
                        goto commL3;

                case 0x01:
                        rule.ruleType_ = 0x01;
commL3:
                        rule.un_ty.L3L4._srcIpAddr = policy_t->sip;
                        rule.un_ty.L3L4._srcIpAddrMask= policy_t->sipMask;
                        rule.un_ty.L3L4._dstIpAddr = policy_t->dip;
                        rule.un_ty.L3L4._dstIpAddrMask= policy_t->dipMask;
                        break;

                default: do {} while (0);

                }
                rule.priority_ = 1;
                rule.actionType_ = 0x01;
                rtl8651_setAsicAclRule(aclStart, &rule);
                aclStart++; count++;
                if (aclStart > aclEnd)
                        return count;
        }
        return count;
}
# 21167 "rtl8651_tblDrv.c"
int32 rtl8651_setFlowControl(uint32 port, int8 enable)
{
        int32 retval;

        if (port >= 6 && port != 0x07)
                return -4;
        rtlglue_drvMutexLock();
        retval = rtl8651_setAsicFlowControlRegister(port, enable);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 21189 "rtl8651_tblDrv.c"
int32 rtl8651_setQueueScheduling(uint32 type, uint32 weight)
{
        int32 retval=-6;

        if (type != 0x01 || weight > 0x03)
                return -6;
        rtlglue_drvMutexLock();
        retval = rtl8651_setAsicHLQueueWeight(weight);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 21211 "rtl8651_tblDrv.c"
int32 rtl8651_setPortPriorityQueue(uint32 port, int8 highPriority)
{
        int32 retval = -6;

        if (port > 0x05)
                return -6;
        rtlglue_drvMutexLock();
        retval = rtl8651_setAsicPortPriority(port, highPriority);
        rtlglue_drvMutexUnlock();
        return retval;
}



int32 rtl8651_setDiffServDSCP(uint32 dscp, int8 highPriority)
{
        int32 retval = -1;

        if (dscp > 63)
                return -6;
        rtlglue_drvMutexLock();
        retval = rtl8651_setAsicDiffServReg(dscp, highPriority);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 21251 "rtl8651_tblDrv.c"
int32 rtl8651_addPolicyBasedQoS(int8 *ifName, rtl8651_tblDrvPolicy_t *policy_t, int8 highPriority)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        _rtl8651_tblDrvPolicy_t *qosPolicy_t;
        int32 retval = 0;

        if (policy_t == ((void *)0) || ifName == ((void *)0) || policy_t->proto < 0x01 || policy_t->proto > 0x03)
                return -6;
        if (highPriority == 0)
                return 0;
        rtlglue_drvMutexLock();
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -3;
                goto out;
        }
        if ((qosPolicy_t=((&DrvTbl.freeList.freePolicy)->tqh_first)) == ((void *)0)) {
                retval = -9;
                goto out;
        }
        bzero(qosPolicy_t, sizeof(_rtl8651_tblDrvPolicy_t)-sizeof(qosPolicy_t->nextPolicy_t));
        rtl8651_memcpy(qosPolicy_t, policy_t, sizeof(rtl8651_tblDrvPolicy_t));
        do { if (((qosPolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (qosPolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (qosPolicy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.freeList.freePolicy)->tqh_last = (qosPolicy_t)->nextPolicy_t.tqe_prev; *(qosPolicy_t)->nextPolicy_t.tqe_prev = (qosPolicy_t)->nextPolicy_t.tqe_next; } while (0);
        do { (qosPolicy_t)->nextPolicy_t.tqe_next = ((void *)0); (qosPolicy_t)->nextPolicy_t.tqe_prev = (&netif_t->policyQosHead)->tqh_last; *(&netif_t->policyQosHead)->tqh_last = (qosPolicy_t); (&netif_t->policyQosHead)->tqh_last = &(qosPolicy_t)->nextPolicy_t.tqe_next; (&netif_t->policyQosHead)->tqh_count++;} while (0);
        _rtl8651_arrangeAllACL();

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 21291 "rtl8651_tblDrv.c"
int32 rtl8651_delPolicyBasedQoS(int8 *ifName, rtl8651_tblDrvPolicy_t *policy_t)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        _rtl8651_tblDrvPolicy_t *qosPolicy_t;
        int32 retval = 0;

        rtlglue_drvMutexLock();
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -3;
                goto out;
        }
        for (qosPolicy_t = ((&netif_t->policyQosHead)->tqh_first); qosPolicy_t; qosPolicy_t = ((qosPolicy_t)->nextPolicy_t.tqe_next)) {
                if (!memcmp(qosPolicy_t, policy_t, sizeof(rtl8651_tblDrvPolicy_t)-sizeof(ipaddr_t))) {
                        do { if (((qosPolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (qosPolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (qosPolicy_t)->nextPolicy_t.tqe_prev; else (&netif_t->policyQosHead)->tqh_last = (qosPolicy_t)->nextPolicy_t.tqe_prev; *(qosPolicy_t)->nextPolicy_t.tqe_prev = (qosPolicy_t)->nextPolicy_t.tqe_next; (&netif_t->policyQosHead)->tqh_count--;} while (0);
                        do { if (((qosPolicy_t)->nextPolicy_t.tqe_next = (&DrvTbl.freeList.freePolicy)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freePolicy)->tqh_first->nextPolicy_t.tqe_prev = &(qosPolicy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.freeList.freePolicy)->tqh_last = &(qosPolicy_t)->nextPolicy_t.tqe_next; (&DrvTbl.freeList.freePolicy)->tqh_first = (qosPolicy_t); (qosPolicy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
                        break;
                }
        }
        _rtl8651_arrangeAllACL();
out:
        rtlglue_drvMutexUnlock();
        return retval;
}







int32 rtl8651_flushPolicyBasedQoS(void)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        _rtl8651_tblDrvPolicy_t *qosPolicy_t;
        int32 entry;

        rtlglue_drvMutexLock();
        netif_t = DrvTbl.netIface;
        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                while ((qosPolicy_t=((&netif_t->policyQosHead)->tqh_first))) {
                        do { if (((qosPolicy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (qosPolicy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (qosPolicy_t)->nextPolicy_t.tqe_prev; else (&netif_t->policyQosHead)->tqh_last = (qosPolicy_t)->nextPolicy_t.tqe_prev; *(qosPolicy_t)->nextPolicy_t.tqe_prev = (qosPolicy_t)->nextPolicy_t.tqe_next; (&netif_t->policyQosHead)->tqh_count--;} while (0);
                        do { if (((qosPolicy_t)->nextPolicy_t.tqe_next = (&DrvTbl.freeList.freePolicy)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freePolicy)->tqh_first->nextPolicy_t.tqe_prev = &(qosPolicy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.freeList.freePolicy)->tqh_last = &(qosPolicy_t)->nextPolicy_t.tqe_next; (&DrvTbl.freeList.freePolicy)->tqh_first = (qosPolicy_t); (qosPolicy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
                }
        }
        _rtl8651_arrangeAllACL();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 21356 "rtl8651_tblDrv.c"
static int32 _rtl8651_specifyNetworkIntfLinkLayerType(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint32 llType, uint16 vid)
{
        rtl8651_tblDrv_networkIntfTable_t *net_t=DrvTbl.netIface;
        rtl8651_tblDrvSession_t *psession_t;
        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t = &DrvTbl.vlan[(vid& (8 -1))];
        uint32 index;


        do {} while (0);


        if (vlan_t->macAddrNumber == 0)
                return -2014;

        if (vlan_t->vid != vid || vlan_t->valid == 0)
                return -5;

        if (netif_t->linkLayerType != 0)
                return -2514;
# 21385 "rtl8651_tblDrv.c"
        switch(llType) {

        case 0x01:

                if (vlan_t->promiscuous == 1)
                        return -2008;

                for(index=0; index<rtl8651_tblDrvPara.networkIntfTableSize; index++, net_t++) {
                        if (net_t->valid && net_t->vid == vid)
                                return -2514;
                }

                for(index=0, pppEntry_t=DrvTbl.pppoe; index<8; index++, pppEntry_t++)
                        if(pppEntry_t->valid == 1 && pppEntry_t->vid == vlan_t->vid)
                                return -2003;
                break;


        case 0x05:
        case 0x06:
        case 0x02:
                for(index=0; index<rtl8651_tblDrvPara.networkIntfTableSize; index++, net_t++) {
                        if (net_t->valid && net_t->linkLayerType!= llType&& net_t->vid == vid)
                                return -2514;
                }
                if (llType != 0x02)
                        break;
# 21420 "rtl8651_tblDrv.c"
                pppEntry_t = &DrvTbl.pppoe[8];
                for(index=0; index<8; index++, pppEntry_t++) {
                        if (pppEntry_t->valid && pppEntry_t->vid == vid)
                                return -3204;
                }
                if (netif_t->flag == 1)
                        break;

                for(index=0,pppEntry_t=DrvTbl.pppoe; index<8; index++,pppEntry_t++) {
                        if (pppEntry_t->valid == 1 && pppEntry_t->vid == vlan_t->vid) {
                                for (psession_t = ((&netif_t->sessionHead)->tqh_first); psession_t; psession_t = ((psession_t)->nextSession.tqe_next))
                                        if (psession_t->session_t == pppEntry_t)
                                                break;
                                if (psession_t != ((void *)0))
                                        continue;

                                do {} while (0);
                                psession_t = ((&DrvTbl.freeList.freeSession)->tqh_first);
                                do { if (((psession_t)->nextSession.tqe_next) != ((void *)0)) (psession_t)->nextSession.tqe_next->nextSession.tqe_prev = (psession_t)->nextSession.tqe_prev; else (&DrvTbl.freeList.freeSession)->tqh_last = (psession_t)->nextSession.tqe_prev; *(psession_t)->nextSession.tqe_prev = (psession_t)->nextSession.tqe_next; } while (0);
                                do { (psession_t)->nextSession.tqe_next = ((void *)0); (psession_t)->nextSession.tqe_prev = (&netif_t->sessionHead)->tqh_last; *(&netif_t->sessionHead)->tqh_last = (psession_t); (&netif_t->sessionHead)->tqh_last = &(psession_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count++;} while (0);
                                pppEntry_t->netif_t = netif_t;
                                psession_t->session_t = pppEntry_t;
                                psession_t->ip_t = ((void *)0);
                        }
                }
                break;

        default: do {} while (0);
        }


        netif_t->vid = vlan_t->vid;
        netif_t->linkLayerType = llType;
        netif_t->defAclAction = 0x01;




        vlan_t->netif_t = netif_t;

        return 0;


}

static int32 _rtl8651_removeNetworkIntfLinkLayerType(rtl8651_tblDrv_networkIntfTable_t *netif_t)
{
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        rtl8651_tblDrvSession_t *psession_t;
# 21479 "rtl8651_tblDrv.c"
        do {} while (0);
        vlan_t = &DrvTbl.vlan[(netif_t->vid& (8 -1))];


        if (netif_t->linkLayerType != 0x01) {
                while((psession_t=((&netif_t->sessionHead)->tqh_first))) {
                        do { if (((psession_t)->nextSession.tqe_next) != ((void *)0)) (psession_t)->nextSession.tqe_next->nextSession.tqe_prev = (psession_t)->nextSession.tqe_prev; else (&netif_t->sessionHead)->tqh_last = (psession_t)->nextSession.tqe_prev; *(psession_t)->nextSession.tqe_prev = (psession_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count--;} while (0);
                        do { if (((psession_t)->nextSession.tqe_next = (&DrvTbl.freeList.freeSession)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeSession)->tqh_first->nextSession.tqe_prev = &(psession_t)->nextSession.tqe_next; else (&DrvTbl.freeList.freeSession)->tqh_last = &(psession_t)->nextSession.tqe_next; (&DrvTbl.freeList.freeSession)->tqh_first = (psession_t); (psession_t)->nextSession.tqe_prev = &(&DrvTbl.freeList.freeSession)->tqh_first; } while (0);
                        psession_t->session_t->netif_t = ((void *)0);
                }
        }
        netif_t->linkLayerType = 0;
        netif_t->vid = 0;
        vlan_t->ipAttached = 0;
        vlan_t->netif_t = ((void *)0);
        RTL8651_SETASICVLAN(vlan_t);

        return 0;
}
# 21518 "rtl8651_tblDrv.c"
int32 rtl8651_specifyNetworkIntfLinkLayerType(int8 * ifName, uint32 llType, uint16 vid)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;

        if (llType < 0x01 || llType > 0x06) {
                return -2504;
        }
        if (vid < 1 || vid > 4094) {
                return -5;
        }
        rtlglue_drvMutexLock();
        if ((netif_t = GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }
        retval = _rtl8651_specifyNetworkIntfLinkLayerType(netif_t, llType, vid);

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 21554 "rtl8651_tblDrv.c"
int32 rtl8651_removeNetworkIntfLinkLayerType(int8 * ifName) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval;

        rtlglue_drvMutexLock();
        if ((netif_t = GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }

        if (netif_t->linkLayerType == 0) {
                retval = -2506;
                goto out;
        }
        if (netif_t->linkLayerType == 0x04) {
                retval = -2505;
                goto out;
        }

        if (DrvTbl.vlan[(netif_t->vid& (8 -1))].internal == 0) {
                retval = -2507;
                goto out;
        }
        if (((&netif_t->IpHead)->slh_first) || ((&netif_t->sessionHead)->tqh_first) ||((&netif_t->nextNat)->slh_first) ||
            ((&netif_t->inAclHead)->tqh_count) > 0 || ((&netif_t->outAclHead)->tqh_count) > 0) {
                retval = -2500;
                goto out;
        }
        retval = _rtl8651_removeNetworkIntfLinkLayerType(netif_t);

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 21596 "rtl8651_tblDrv.c"
static void _rtl8651_MiiForPptpL2tp(uint16 vid, rtl8651_tblDrv_vlanTable_t *vlan_t)
{
        uint16 lpvid = (vlan_t - DrvTbl.vlan) + (8<<8);
        int32 retval;

        if (tunnel.valid == 1)
                return;
        _rtl8651_addVlan(lpvid);
        vlan_t->internal = 0;
        vlan_t->ipAttached = 1;

        vlan_t->memberPortMask = (1<<0x7);
        vlan_t->untagPortMask = (1<<0x7);

        vlan_t->macAddrNumber = 1;
        vlan_t->macAddr = DrvTbl.vlan[(vid& (8 -1))].macAddr;
        RTL8651_SETASICVLAN(vlan_t);

        tunnel.valid = 1;


        tunnel.loopbackPort = 0x7;
        rtl8651_setEthernetPortLinkStatus(0x7, 1);


        tunnel.loopBackVid = lpvid;
        tunnel.wanPort = 0xff;
        tunnel.wanVid = vid;

        retval = _rtl8651_setPvid(tunnel.loopbackPort, tunnel.loopBackVid);
        do {} while (0);


        _rtl8651_arrangeMulticastPortStatus();

        _rtl8651_arrangeAllACL();
}





static int32 _rtl8651_freePPPEntry(rtl8651_tblDrv_pppTable_t *pppEntry_t)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrvSession_t *session_t;


        do {} while (0);
        pppEntry_t->valid = 0;

        netif_t = pppEntry_t->netif_t;
        session_t = pppEntry_t->session_t;
        do { if (((session_t)->nextSession.tqe_next) != ((void *)0)) (session_t)->nextSession.tqe_next->nextSession.tqe_prev = (session_t)->nextSession.tqe_prev; else (&netif_t->sessionHead)->tqh_last = (session_t)->nextSession.tqe_prev; *(session_t)->nextSession.tqe_prev = (session_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count--;} while (0);
        do { if (((session_t)->nextSession.tqe_next = (&DrvTbl.freeList.freeSession)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeSession)->tqh_first->nextSession.tqe_prev = &(session_t)->nextSession.tqe_next; else (&DrvTbl.freeList.freeSession)->tqh_last = &(session_t)->nextSession.tqe_next; (&DrvTbl.freeList.freeSession)->tqh_first = (session_t); (session_t)->nextSession.tqe_prev = &(&DrvTbl.freeList.freeSession)->tqh_first; } while (0);

        _rtl8651_dsid--;
        if (pppEntry_t->type == 0x01) {
                if (_rtl8651_pppoe_count>0){
                        _rtl8651_pppoe_count--;
                        if(_rtl8651_pppoe_count<=1)
                                _rtl8651_multiple_dsid=0;
                }
        }
        return 0;
}


static rtl8651_tblDrv_pppTable_t *
_rtl8651_allocatePPPEntry(uint32 type, uint32 sessionId, rtl8651_tblDrv_networkIntfTable_t *netif_t)
{
        rtl8651_tblDrv_pppTable_t *session_t;
        uint32 totalEntry, entry;

        do {} while (0);
        do {} while (0);

        totalEntry = (type==0x01)? 8: ((type==0x02)? rtl8651_tblDrvPara.pptpSize: rtl8651_tblDrvPara.l2tpSize);
        session_t = (type==0x01)? DrvTbl.pppoe: ((type==0x02)? DrvTbl.pptp: DrvTbl.l2tp);
        for(entry=0; entry<totalEntry; entry++, session_t++) {
                if (session_t->valid == 0) {
                        bzero(session_t, sizeof(rtl8651_tblDrv_pppTable_t));
                        session_t->sessionId = sessionId;
                        session_t->netif_t = netif_t;
                        session_t->vid = netif_t->vid;
                        session_t->session_t = ((void *)0);
                        session_t->type = type;
                        session_t->valid = 1;
                        session_t->initiated = 0;
                        session_t->mss = 1500 - 40 - 8;
                        session_t->dsid = _rtl8651_dsid++;

                        if (type == 0x01) {
                                _rtl8651_pppoe_count++;
                                if (_rtl8651_pppoe_count>1)
                                        _rtl8651_multiple_dsid=1;
                        }
                        return session_t;
                }
        }
        return (rtl8651_tblDrv_pppTable_t *)((void *)0);
}


rtl8651_tblDrv_pppTable_t *_rtl8651_getPPPInfo(uint32 sessionId, ipaddr_t ipaddr)
{
        rtl8651_tblDrv_pppTable_t *session_t=DrvTbl.pppoe;
        int32 entry, totalEntry;

        totalEntry = 8 + rtl8651_tblDrvPara.pptpSize + rtl8651_tblDrvPara.l2tpSize;
        for(entry=0; entry<totalEntry; entry++, session_t++) {
                if (session_t->valid == 0)
                        continue;
                if (ipaddr) {
                        if (session_t->session_t && session_t->session_t->ip_t && session_t->session_t->ip_t->ipAddr == ipaddr)
                                return session_t;
                }
                else if (session_t->sessionId == sessionId)
                        return session_t;
# 21723 "rtl8651_tblDrv.c"
        }
        return (rtl8651_tblDrv_pppTable_t *)((void *)0);
}



int32 _rtl8651_addSession(uint32 type, uint32 sessionId, int8 *ifName, uint16 vid)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t=((void *)0), *net_t = DrvTbl.netIface;
        rtl8651_tblDrvSession_t *ps_t, *session_t=((void *)0);
        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        int32 entry, handleCase, retval;
        uint8 llType;
# 21756 "rtl8651_tblDrv.c"
        if ((vid < 1 || vid > 4094)) return -5;;
        if ((ifName==((void *)0))) return -7;;


        vlan_t = &DrvTbl.vlan[(vid& (8 -1))];
        if (vlan_t->valid == 0) {
                return -5;
        }

        if (vlan_t->promiscuous == 1) {
                return -2800;
        }

        if (_rtl8651_getPPPInfo(sessionId, 0) != ((void *)0)) {
                return -2;
        }
        llType = (type==0x01)? 0x02: ((type==0x02)? 0x05: 0x06);
        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, net_t++) {
                if (!net_t->valid)
                        continue;
                if (!_strncmp(ifName, net_t->ifName, 16))
                        netif_t = net_t;
                for (ps_t = ((&net_t->sessionHead)->tqh_first); ps_t; ps_t = ((ps_t)->nextSession.tqe_next)) {
                        do {} while (0);
                        if (ps_t->session_t->sessionId == sessionId)
                                session_t = ps_t;
                }

                if (net_t->vid == vid && net_t->linkLayerType != llType)
                        return -5;
        }


        if (netif_t && netif_t->linkLayerType != llType) {
                return -2504;
        }

        if (netif_t && session_t && netif_t->vid!=session_t->session_t->netif_t->vid) {
                return -5;
        }
        if (netif_t && netif_t->vid != vid) {
                return -5;
        }
# 21814 "rtl8651_tblDrv.c"
        if (!netif_t && !session_t)
                handleCase = 1;
        else if (!netif_t && session_t)
                handleCase = 2;
        else if (netif_t && !session_t)
                handleCase = 3;
        else handleCase = 4;



        if (handleCase == 1 || handleCase == 3) {
                if (((&DrvTbl.freeList.freeSession)->tqh_first) == ((void *)0))
                        return -9;
        }

        if (!netif_t && (netif_t=_rtl8651_addNetworkInterface(ifName))) {
                netif_t->flag = 1;
                retval = _rtl8651_specifyNetworkIntfLinkLayerType(netif_t, llType, vid);
                do {} while (0);
        }

        if (session_t == ((void *)0)) {
                session_t = ((&DrvTbl.freeList.freeSession)->tqh_first);
                if ((pppEntry_t=_rtl8651_allocatePPPEntry(type, sessionId, netif_t)) != ((void *)0)) {
                        do { if (((session_t)->nextSession.tqe_next) != ((void *)0)) (session_t)->nextSession.tqe_next->nextSession.tqe_prev = (session_t)->nextSession.tqe_prev; else (&DrvTbl.freeList.freeSession)->tqh_last = (session_t)->nextSession.tqe_prev; *(session_t)->nextSession.tqe_prev = (session_t)->nextSession.tqe_next; } while (0);
                        session_t->session_t = pppEntry_t;
                        pppEntry_t->session_t = session_t;
                        session_t->ip_t = ((void *)0);
                }
                else {
                        if (handleCase == 1 || handleCase == 2)
                                netif_t->valid = 0;
                        return -9;
                }
        }




        do {} while (0);

        switch (handleCase)
        {
        case 1:
                do { (session_t)->nextSession.tqe_next = ((void *)0); (session_t)->nextSession.tqe_prev = (&netif_t->sessionHead)->tqh_last; *(&netif_t->sessionHead)->tqh_last = (session_t); (&netif_t->sessionHead)->tqh_last = &(session_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count++;} while (0);
                session_t->session_t->netif_t = netif_t;
                break;

        case 2:

                net_t = session_t->session_t->netif_t;
                if (((&netif_t->sessionHead)->tqh_count) <= 1) {
                        netif_t->valid = 0;
                        return -3202;
                }
                else {
                        do { if (((session_t)->nextSession.tqe_next) != ((void *)0)) (session_t)->nextSession.tqe_next->nextSession.tqe_prev = (session_t)->nextSession.tqe_prev; else (&net_t->sessionHead)->tqh_last = (session_t)->nextSession.tqe_prev; *(session_t)->nextSession.tqe_prev = (session_t)->nextSession.tqe_next; (&net_t->sessionHead)->tqh_count--;} while (0);
                        do { (session_t)->nextSession.tqe_next = ((void *)0); (session_t)->nextSession.tqe_prev = (&netif_t->sessionHead)->tqh_last; *(&netif_t->sessionHead)->tqh_last = (session_t); (&netif_t->sessionHead)->tqh_last = &(session_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count++;} while (0);
                        session_t->session_t->netif_t = netif_t;
                }
                break;

        case 3:
                if (((&netif_t->sessionHead)->tqh_first) > 0 && netif_t->flag == 1) {
                        do { if (((session_t)->nextSession.tqe_next = (&DrvTbl.freeList.freeSession)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeSession)->tqh_first->nextSession.tqe_prev = &(session_t)->nextSession.tqe_next; else (&DrvTbl.freeList.freeSession)->tqh_last = &(session_t)->nextSession.tqe_next; (&DrvTbl.freeList.freeSession)->tqh_first = (session_t); (session_t)->nextSession.tqe_prev = &(&DrvTbl.freeList.freeSession)->tqh_first; } while (0);
                        session_t->session_t->valid = 0;
                        return -3203;
                }
                else {
                        do { (session_t)->nextSession.tqe_next = ((void *)0); (session_t)->nextSession.tqe_prev = (&netif_t->sessionHead)->tqh_last; *(&netif_t->sessionHead)->tqh_last = (session_t); (&netif_t->sessionHead)->tqh_last = &(session_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count++;} while (0);
                        session_t->session_t->netif_t = netif_t;
                }
                break;

        case 4:
                if ((net_t=session_t->session_t->netif_t) == netif_t)
                        break;
                if (((&netif_t->sessionHead)->tqh_count) > 0){
                        return -3203;
                }
                if (((&net_t->sessionHead)->tqh_count) <= 1) {
                        return -3202;
                }
                do { (session_t)->nextSession.tqe_next = ((void *)0); (session_t)->nextSession.tqe_prev = (&netif_t->sessionHead)->tqh_last; *(&netif_t->sessionHead)->tqh_last = (session_t); (&netif_t->sessionHead)->tqh_last = &(session_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count++;} while (0);
                session_t->session_t->netif_t = netif_t;
                break;

        default: do {} while (0);

        }
        _rtl8651_updateDefaultRoute();



        {
                rtl8651_tblDrv_pppTable_t *session_t=DrvTbl.pppoe;
                rtl8651_tblDrv_vlanTable_t *vlanPtr;
                int32 entry;
                int32 bPppoeSessionExist = 0;


                for(entry=0; entry<8; entry++, session_t++)
                {
                        if (session_t->valid == 0)
                                continue;
                        else
                                bPppoeSessionExist = 1;
                }


                if ( RtkHomeGatewayChipRevisionID==0x1 && bPppoeSessionExist )
                {
                        uint32 i;

                        for( i = 0, vlanPtr = DrvTbl.vlan; i < 8; i++, vlanPtr++ )
                        {
                                if (vlanPtr->valid == 0 )
                                        continue;


                                if ( vlanPtr->internal )
                                {
                                        if ( vlanPtr->memberPortMask & 0x06 )
                                                rtl8651_setVlanPortUntag( vlanPtr->vid, 0x06, 0 );
                                        if ( vlanPtr->memberPortMask & 0x07 )
                                                rtl8651_setVlanPortUntag( vlanPtr->vid, 0x07, 0 );
                                        if ( vlanPtr->memberPortMask & 0x08 )
                                                rtl8651_setVlanPortUntag( vlanPtr->vid, 0x08, 0 );
                                }
                        }
                }
        }


        return 0;
}


static int32 _rtl8651_delSession(uint32 sessionId)
{
        rtl8651_tblDrv_pppTable_t *pppEntry_t;

        rtl8651_tblDrv_routeTable_t *l3_t=DrvTbl.route;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 entry, retval;


        if ((pppEntry_t=_rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0)) {
                return -3;
        }

        if (pppEntry_t->initiated == 1) {
                return -2805;
        }

        for(entry=0; entry<rtl8651_tblDrvPara.routingTableSize; entry++, l3_t++) {
                if (l3_t->valid == 0 || l3_t->nextHopType == 0x01)
                        continue;

                if (l3_t->un.nxthop.un1.session.session_t == pppEntry_t)
                        return -2806;
        }
        _rtl8651_freePPPEntry(pppEntry_t);
        netif_t = pppEntry_t->netif_t;

        if (netif_t->flag == 1) {
                retval = _rtl8651_removeNetworkIntfLinkLayerType(netif_t);
                do {} while (0);
                netif_t->valid = 0;
        }
        _rtl8651_updateDefaultRoute();



        {
                rtl8651_tblDrv_pppTable_t *session_t=DrvTbl.pppoe;
                rtl8651_tblDrv_vlanTable_t *vlanPtr;
                int32 entry;
                int32 bPppoeSessionExist = 0;


                for(entry=0; entry<8; entry++, session_t++)
                {
                        if (session_t->valid == 0)
                                continue;
                        else
                                bPppoeSessionExist = 1;
                }


                if ( RtkHomeGatewayChipRevisionID== 1 && bPppoeSessionExist == 0 )
                {
                        uint32 i;

                        for( i = 0, vlanPtr = DrvTbl.vlan; i < 8; i++, vlanPtr++ )
                        {
                                if (vlanPtr->valid == 0 )
                                        continue;


                                if ( vlanPtr->internal )
                                {
                                        if ( vlanPtr->memberPortMask & 0x06 )
                                                rtl8651_setVlanPortUntag( vlanPtr->vid, 0x06, 1 );
                                        if ( vlanPtr->memberPortMask & 0x07 )
                                                rtl8651_setVlanPortUntag( vlanPtr->vid, 0x07, 1 );
                                        if ( vlanPtr->memberPortMask & 0x08 )
                                                rtl8651_setVlanPortUntag( vlanPtr->vid, 0x08, 1 );
                                }
                        }
                }
        }


        return 0;
}


static int32 _rtl8651_bindSession(ipaddr_t ipAddr, uint32 sessionId)
{

        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        rtl8651_tblDrv_ipIntfIpAddrEntry_t *ip_t;
        rtl8651_tblDrv_ipIntfEntry_t *ipintf_t;
        int32 entry;



        if ((pppEntry_t = _rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0))
                return -3200;
# 22056 "rtl8651_tblDrv.c"
        {

                rtl8651_tblDrv_networkIntfTable_t *netif_t = DrvTbl.netIface;
                for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                        if (netif_t->valid == 0)
                                continue;
                        for((ipintf_t) = (&netif_t->IpHead)->slh_first; (ipintf_t); (ipintf_t) = (ipintf_t)->nextIp.sle_next) {
                                for((ip_t) = (&ipintf_t->ipAddr)->slh_first; (ip_t); (ip_t) = (ip_t)->nextIpAddr.sle_next)
                                        if (ip_t->ipAddr == ipAddr)
                                                goto found_;
                        }
                }
        }

        return -6;

found_:
# 22081 "rtl8651_tblDrv.c"
        pppEntry_t->session_t->ip_t = ip_t;
        return 0;
}


static void _rtl8651_unbindSession(rtl8651_tblDrv_ipIntfIpAddrEntry_t *ipAddr, rtl8651_tblDrv_pppTable_t *pppEntry_t)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t = DrvTbl.netIface;
        rtl8651_tblDrvSession_t *session_t;
        uint32 entry;


        do {} while (0);
        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 1) {
                        for (session_t = ((&netif_t->sessionHead)->tqh_first); session_t; session_t = ((session_t)->nextSession.tqe_next)) {
                                if (ipAddr && session_t->ip_t == ipAddr) {

                                        session_t->ip_t = ((void *)0);
                                        break;
                                }
                                if (pppEntry_t && pppEntry_t->session_t == session_t) {

                                        session_t->ip_t = ((void *)0);
                                        break;
                                }
                        }
                }
       }

}




static int32 _rtl8651_resetSessionProperty(rtl8651_tblDrv_pppTable_t *pppEntry_t)
{
        rtl8651_tblDrv_routeTable_t *l3Entry_t;
        uint32 entry;
        uint8 llType=0;


        do {} while (0);
        switch (pppEntry_t->type)
        {
        case 0x01:
                break;
        case 0x02: llType = 0x05; break;
        case 0x03: llType = 0x06; break;
        default: do {} while (0);
        }
        pppEntry_t->initiated = 0;


        for(entry=0, l3Entry_t=DrvTbl.route; entry<rtl8651_tblDrvPara.routingTableSize; entry++, l3Entry_t++) {
                if (l3Entry_t->valid == 0)
                        continue;
                if (l3Entry_t->netif_t->linkLayerType == llType && l3Entry_t->un.nxthop.un1.session.session_t == pppEntry_t) {


                        _rtl8651_updateL3Entry(l3Entry_t);
                }
        }
        return 0;
}


int32 _rtl8651_getSessionMac(uint32 sessionId, ether_addr_t *macAddr)
{
        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;

        if ((pppEntry_t=_rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0))
                return -2804;
        vlan_t = &DrvTbl.vlan[(pppEntry_t->vid& (8 -1))];
        if (vlan_t->macAddrNumber > 0) {
                *macAddr = vlan_t->macAddr;
                return 0;
        }
        else return -2014;
}
# 22186 "rtl8651_tblDrv.c"
int32 rtl8651_addSession(uint32 type, uint32 sessionId, int8 *ifName, uint16 vid)
{
        rtl8651_tblDrv_vlanTable_t *vlan_t=DrvTbl.vlan;
        int32 retval, entry;

        rtlglue_drvMutexLock();
        if (tunnel.valid == 1 && tunnel.wanVid != vid) {
                retval = -3205;
                goto out;
        }

        for(entry=0; entry<8; entry++, vlan_t++)
                if (vlan_t->valid == 0)
                        break;
        if (entry == 8)
                vlan_t = ((void *)0);
        if ((retval = _rtl8651_addSession(type, sessionId, ifName, vid)) == 0) {

                if (type == 0x02 || type == 0x03)
                        _rtl8651_MiiForPptpL2tp(vid, vlan_t);

        }

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22225 "rtl8651_tblDrv.c"
int32 rtl8651_delSession(uint32 sessionId)
{
        rtl8651_tblDrv_pppTable_t*pppEntry_t;
        int32 retval, entry;
        rtlglue_drvMutexLock();
        if ((retval = _rtl8651_delSession(sessionId)) == 0) {
                pppEntry_t = DrvTbl.pptp;
                for(entry=0; entry<rtl8651_tblDrvPara.pptpSize+rtl8651_tblDrvPara.l2tpSize; entry++, pppEntry_t++)
                        if (pppEntry_t->valid == 1)
                                break;
                if (entry == rtl8651_tblDrvPara.pptpSize+rtl8651_tblDrvPara.l2tpSize) {
                        tunnel.valid = 0;
                        DrvTbl.vlan[(tunnel.loopBackVid& (8 -1))].valid = 0;
                        rtl8651_delAsicVlan(tunnel.loopBackVid);
                }
        }
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22256 "rtl8651_tblDrv.c"
int32 rtl8651_bindSession(ipaddr_t ipAddr, uint32 sessionId)
{
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_bindSession(ipAddr, sessionId);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22275 "rtl8651_tblDrv.c"
int32 rtl8651_getSessionMac(uint32 sessionId, ether_addr_t *macAddr)
{
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_getSessionMac(sessionId, macAddr);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22321 "rtl8651_tblDrv.c"
int32 rtl8651_addPppoeSession(uint32 sessionId, uint16 vid)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval, entry;
        int8 *ifName=((void *)0);
        rtlglue_drvMutexLock();
        netif_t = DrvTbl.netIface;
        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid && netif_t->vid == vid && netif_t->flag == 0) {
                        ifName = netif_t->ifName;
                        break;
                }
        }
        retval = _rtl8651_addSession(0x01, sessionId, ifName, vid);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22348 "rtl8651_tblDrv.c"
int32 rtl8651_delPppoeSession(uint32 sessionId)
{
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_delSession(sessionId);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22372 "rtl8651_tblDrv.c"
int32 rtl8651_setPppoeSessionProperty(uint32 sessionId, uint16 sid, ether_addr_t * macAddr, uint32 port)
{
        rtl8651_tblDrv_pppTable_t *pppEntry_t, *tracker_t;
        rtl8651_tblDrv_routeTable_t *rt_t = DrvTbl.route;
        rtl865x_tblAsicDrv_pppoeParam_t asic_pppoe;
        int32 entry, retval=0;
        uint32 vidx;
        uint8 buf[24];


        if (sid == 0xffff) {
                return -2807;
        }
        rtlglue_drvMutexLock();

        if ((pppEntry_t=_rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0)) {
                retval = -2804;
                goto out;
        }
        if (pppEntry_t->type != 0x01) {
                retval = -6;
                goto out;
        }

        tracker_t = DrvTbl.pppoe;
        for(entry=0; entry<8; entry++, tracker_t++) {
                if (tracker_t->valid && tracker_t->sessionId == sessionId)
                        continue;
                if (tracker_t->initiated && tracker_t->un.pppoe.pppoeSessionId__ == sid &&
                    !memcmp(&tracker_t->macInfo->macAddr, macAddr, sizeof(ether_addr_t))) {
                        retval = -2808;
                        goto out;
                }
        }
# 22414 "rtl8651_tblDrv.c"
        if (pppEntry_t->initiated == 1) {
                retval = -2809;
                goto out;
        }
        vidx = (pppEntry_t->vid& (8 -1));
        if (_rtl8651_addVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[vidx].fid, pppEntry_t->vid, macAddr, 0x00, 1<<port)) {
                retval = -2810;
                goto out;
        }

         ether_ntoa_r(macAddr, buf);

        pppEntry_t->initiated = 1;
        pppEntry_t->un.pppoe.pppoeSessionId__ = sid;
        pppEntry_t->macInfo = _rtl8651_getVlanFilterDatabaseEntry(pppEntry_t->vid, macAddr);
        asic_pppoe.sessionId = sid;



        rtl8651_setAsicPppoe(pppEntry_t-DrvTbl.pppoe, &asic_pppoe);

        for(entry=0; entry<rtl8651_tblDrvPara.routingTableSize; entry++, rt_t++)
                if (rt_t->valid && rt_t->un.nxthop.un1.session.session_t == pppEntry_t)
                        _rtl8651_updateL3Entry(rt_t);
        _rtl8651_updateDefaultRoute();
        _rtl8651_updateNextHop_NHIDX(((void *)0), pppEntry_t);

 out:
        rtlglue_drvMutexUnlock();
        return retval;


}
# 22455 "rtl8651_tblDrv.c"
int32 rtl8651_resetPppoeSessionProperty(uint32 sessionId)
{
        rtl8651_tblDrv_routeTable_t *rt_t = DrvTbl.route;
        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        int32 retval = 0;
        uint32 vidx, entry;


        rtlglue_drvMutexLock();
        if ((pppEntry_t=_rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0)) {
                retval = -2804;
                goto out;
        }
        if (pppEntry_t->initiated== 0)
                goto out;
        pppEntry_t->initiated= 0;

        vidx = (pppEntry_t->vid& (8 -1));
        retval = _rtl8651_delVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[vidx].fid, &(pppEntry_t->macInfo->macAddr));
        do {} while (0);
        pppEntry_t->macInfo = ((void *)0);

        _rtl8651_unbindSession(((void *)0), pppEntry_t);
        for(entry=0; entry<rtl8651_tblDrvPara.routingTableSize; entry++, rt_t++)
                if (rt_t->valid && rt_t->un.nxthop.un1.session.session_t == pppEntry_t)
                        _rtl8651_updateL3Entry(rt_t);
        _rtl8651_updateDefaultRoute();
        _rtl8651_updateNextHop_NHIDX(((void *)0), pppEntry_t);

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22499 "rtl8651_tblDrv.c"
int32 rtl8651_bindPppoeSession(ipaddr_t ipAddr, uint32 sessionId)
{
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_bindSession(ipAddr, sessionId);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22516 "rtl8651_tblDrv.c"
int32 rtl8651_getPppoeSessionMac(uint32 sessionId, ether_addr_t * macAddr)
{
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_getSessionMac(sessionId, macAddr);
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22548 "rtl8651_tblDrv.c"
int32 rtl8651_setPptpProperty(uint32 sessionId, uint16 callId, uint16 peerCallId, ipaddr_t s_ipaddr, ipaddr_t gw_ipaddr)
{
        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        rtl8651_tblDrv_routeTable_t *rt_t;
        int32 retval = 0;
        uint32 portMask, entry;

        rtlglue_drvMutexLock();

        if ((pppEntry_t = _rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0)) {
                retval = -3200;
                goto out;
        }
        if ((arp_t=_rtl8651_getArpEntry(pppEntry_t->netif_t, s_ipaddr, 0)) == ((void *)0)) {
                if(gw_ipaddr && (arp_t = _rtl8651_getArpEntry(pppEntry_t->netif_t, gw_ipaddr, 0)) != ((void *)0));
                else {
                        retval = -2404;
                        goto out;
                }
        }
        if ((pppEntry_t->macInfo=arp_t->macInfo) == ((void *)0)) {
                retval = -2404;
                goto out;
        }
        retval = _rtl8651_addVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[(arp_t->vid& (8 -1))].fid,
                arp_t->vid, &arp_t->macInfo->macAddr, 0x00, arp_t->macInfo->memberPortMask);
        if (retval != 0) {
                retval = -2404;
                goto out;
        }
        pppEntry_t->initiated = 1;
        pppEntry_t->un.pptp.callId__ = callId;
        pppEntry_t->un.pptp.peerCallId__ = peerCallId;
        pppEntry_t->un.pptp.serverIp__ = s_ipaddr;
        pppEntry_t->un.pptp.defaultGwIp__ = gw_ipaddr;
        portMask = arp_t->macInfo->memberPortMask;
        do {} while (0);
        tunnel.wanPort = 0;
        while (portMask > 1) {
                portMask = portMask >> 1;
                tunnel.wanPort ++;
        }
        _rtl8651_updateNextHop_NHIDX(((void *)0), pppEntry_t);


        rt_t = DrvTbl.route;
        for(entry=0; entry<rtl8651_tblDrvPara.routingTableSize; entry++, rt_t++) {
                if (rt_t->valid == 0)
                        continue;
                if (rt_t->netif_t->linkLayerType == 0x05 && rt_t->un.nxthop.un1.session.session_t == pppEntry_t)
                        _rtl8651_updateL3Entry(rt_t);
        }
        _rtl8651_updateDefaultRoute();



        if (gw_ipaddr)
                _rtl8651_rmPPTPL2TPInterfaceRoute(gw_ipaddr);
        else
                _rtl8651_rmPPTPL2TPInterfaceRoute(s_ipaddr);


out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22625 "rtl8651_tblDrv.c"
int32 rtl8651_resetPptpProperty(uint32 sessionId)
{

        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        ipaddr_t pptpServerIp_tmp, pptpDefaultGwIp_tmp;
        int32 retval;
        rtlglue_drvMutexLock();
        if ((pppEntry_t = _rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0))
        {
                rtlglue_drvMutexUnlock();
                return -3200;
        }


        pptpServerIp_tmp = pppEntry_t->un.pptp.serverIp__;
        pptpDefaultGwIp_tmp = pppEntry_t->un.pptp.defaultGwIp__;


        pppEntry_t->initiated = 0;
        pppEntry_t->un.pptp.callId__ = 0;
        pppEntry_t->un.pptp.peerCallId__ = 0;
        pppEntry_t->un.pptp.serverIp__ = 0;
        pppEntry_t->un.pptp.defaultGwIp__ = 0;
        pppEntry_t->un.pptp.delta__ = 0;
        pppEntry_t->un.pptp.lastReceiveSeq__ = 0;
        if (pppEntry_t->type == 0x02)
                retval = _rtl8651_resetSessionProperty(pppEntry_t);
        else retval = -3200;
        if (tunnel.wanPort != 0xff) {
                uint32 mbrMask = (1<<tunnel.wanPort);
                pppEntry_t->macInfo->memberPortMask = mbrMask;
                _rtl8651_modifyVlanRefFilterDatabaseEntry(0, &pppEntry_t->macInfo->macAddr, &mbrMask, 0x00, ((void *)0), 0x01);
        }
        _rtl8651_delVlanRefFilterDatabaseEntry(
                        0x0001,
                        DrvTbl.vlan[(pppEntry_t->vid& (8 -1))].fid,
                        &pppEntry_t->macInfo->macAddr
        );
        _rtl8651_updateDefaultRoute();


        if (pptpDefaultGwIp_tmp)
                _rtl8651_addPPTPL2TPInterfaceRoute(pppEntry_t, pptpDefaultGwIp_tmp);
        else
                _rtl8651_addPPTPL2TPInterfaceRoute(pppEntry_t, pptpServerIp_tmp);
        _rtl8651_updateNextHop_NHIDX(((void *)0), pppEntry_t);
        tunnel.wanPort = 0xff;
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22697 "rtl8651_tblDrv.c"
int32 rtl8651_setL2tpProperty(uint32 sessionId, uint16 tunnelId, uint16 sid, ipaddr_t s_ipaddr, ipaddr_t gw_ipaddr)
{
        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        rtl8651_tblDrv_routeTable_t *rt_t;
        int32 retval = 0;
        uint32 portMask, entry;

        rtlglue_drvMutexLock();
        if ((pppEntry_t = _rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0)) {
                retval = -3200;
                goto out;
        }
        if ((arp_t=_rtl8651_getArpEntry(pppEntry_t->netif_t, s_ipaddr, 0)) == ((void *)0)) {
                if(gw_ipaddr && (arp_t = _rtl8651_getArpEntry(pppEntry_t->netif_t, gw_ipaddr, 0)) != ((void *)0));
                else {
                        retval = -2404;
                        goto out;
                }
        }
        if ((pppEntry_t->macInfo=arp_t->macInfo) == ((void *)0)) {
                retval = -2404;
                goto out;
        }
        retval = _rtl8651_addVlanRefFilterDatabaseEntry(0x0001, DrvTbl.vlan[(arp_t->vid& (8 -1))].fid,
                arp_t->vid, &arp_t->macInfo->macAddr, 0x00, arp_t->macInfo->memberPortMask);
        if (retval != 0) {
                retval = -2404;
                goto out;
        }
        pppEntry_t->initiated = 1;
        pppEntry_t->un.l2tp.tunnelId__ = tunnelId;
        pppEntry_t->un.l2tp.l2tpSessionId__ = sid;
        pppEntry_t->un.l2tp.serverIp__ = s_ipaddr;
        pppEntry_t->un.l2tp.defaultGwIp__ = gw_ipaddr;
        pppEntry_t->un.l2tp.l2tpOffset2__ = 0;
        portMask = arp_t->macInfo->memberPortMask;

        do {} while (0);
        tunnel.wanPort = 0;

        while (portMask > 1) {
                portMask = portMask >> 1;
                tunnel.wanPort ++;
        }
        _rtl8651_updateNextHop_NHIDX(((void *)0), pppEntry_t);


        rt_t = DrvTbl.route;
        for(entry=0; entry<rtl8651_tblDrvPara.routingTableSize; entry++, rt_t++) {
                if (rt_t->valid == 0)
                        continue;
                if (rt_t->netif_t->linkLayerType == 0x06 && rt_t->un.nxthop.un1.session.session_t == pppEntry_t)
                        _rtl8651_updateL3Entry(rt_t);
        }
        _rtl8651_updateDefaultRoute();



     if (gw_ipaddr)
                _rtl8651_rmPPTPL2TPInterfaceRoute(gw_ipaddr);
     else
                _rtl8651_rmPPTPL2TPInterfaceRoute(s_ipaddr);


out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 22776 "rtl8651_tblDrv.c"
int32 rtl8651_resetL2tpProperty(uint32 sessionId)
{
        rtl8651_tblDrv_pppTable_t *pppEntry_t;
        ipaddr_t l2tpServerIp_tmp, l2tpDefaultGwIp_tmp;
        int32 retval;

        rtlglue_drvMutexLock();
        if ((pppEntry_t = _rtl8651_getPPPInfo(sessionId, 0)) == ((void *)0))
        {
                rtlglue_drvMutexUnlock();
                return -3200;
        }

        l2tpServerIp_tmp = pppEntry_t->un.l2tp.serverIp__;
        l2tpDefaultGwIp_tmp = pppEntry_t->un.l2tp.defaultGwIp__;

        if (pppEntry_t->type == 0x03)
                retval = _rtl8651_resetSessionProperty(pppEntry_t);
        else retval = -3200;
        if (tunnel.wanPort != 0xff) {
                uint32 mbrMask = (1<<tunnel.wanPort);
                pppEntry_t->macInfo->memberPortMask = mbrMask;
                _rtl8651_modifyVlanRefFilterDatabaseEntry(0, &pppEntry_t->macInfo->macAddr, &mbrMask, 0x00, ((void *)0), 0x01);
        }
        _rtl8651_delVlanRefFilterDatabaseEntry(
                        0x0001,
                        DrvTbl.vlan[(pppEntry_t->vid& (8 -1))].fid,
                        &pppEntry_t->macInfo->macAddr
        );
        _rtl8651_updateDefaultRoute();

        if (l2tpDefaultGwIp_tmp)
                _rtl8651_addPPTPL2TPInterfaceRoute(pppEntry_t, l2tpDefaultGwIp_tmp);
        else
                _rtl8651_addPPTPL2TPInterfaceRoute(pppEntry_t, l2tpServerIp_tmp);
        _rtl8651_updateNextHop_NHIDX(((void *)0), pppEntry_t);
        tunnel.wanPort = 0xff;
        rtlglue_drvMutexUnlock();

        return retval;
}
# 22831 "rtl8651_tblDrv.c"
static void _rtl8651_updateIPTableEntry(rtl8651_tblDrv_ipEntry_t *entry_t)
{
        rtl865x_tblAsicDrv_extIntIpParam_t asic;
        int32 retval;

        if (rtl8651_getAsicExtIntIpTable((entry_t - DrvTbl.iptbl), &asic) == -1)
                return;
        asic.nhIndex = (entry_t->nextHop_t) ? entry_t->nextHop_t->entryIndex: 0;
        retval = rtl8651_setAsicExtIntIpTable((entry_t - DrvTbl.iptbl), &asic);
        do {} while (0);
}


static void _rtl8651_ipTbl_setDefNexthop(rtl8651_tblDrv_routeTable_t *rt_t)
{
        rtl8651_tblDrv_ipEntry_t *entry_t = DrvTbl.iptbl;
        int32 entry, retval;
        int8 flag;

        if (rt_t && rt_t->nextHopType != 0x01)
                return;
        for(entry=0; entry<16; entry++, entry_t++) {
                flag = (entry_t->type==0x00)? 0x04: 0x03;
                if (rt_t && entry_t->def_flag == 1) {
                        retval = _rtl8651_addNextHopEntry(flag, entry_t, rt_t->netif_t, rt_t->nextHop, 0, ((void *)0));
                        do {} while (0);
                }
                if (!rt_t && entry_t->def_flag == 1 && entry_t->nextHop_t) {
                        retval = _rtl8651_delNextHopEntry(flag, entry_t);
                        do {} while (0);
                }
        }
}


void _rtl8651_arrangeAlliptbl_patch(void)
{
        rtl8651_tblDrv_ipEntry_t *ipEntry_t = DrvTbl.iptbl;
        rtl865x_tblAsicDrv_extIntIpParam_t asic_ip;
        uint32 entry, validIpEntryNum = 0, regValue = 0, ipidx_candidate = 0;
        int32 retval;


        if (def_napt_t)
        {

                for (entry = 0; entry < 16; entry++, ipEntry_t++)
                {
                        retval = rtl8651_delAsicExtIntIpTable(entry);
                        do {} while (0);

                        if (ipEntry_t->valid == 1)
                        {
                                validIpEntryNum++;


                                if ((ipEntry_t->type == 0x00) && (ipEntry_t->extip == def_napt_t->extip))
                                        ipidx_candidate |= entry;

                                bzero(&asic_ip, sizeof(rtl865x_tblAsicDrv_extIntIpParam_t));
                                asic_ip.extIpAddr = ipEntry_t->extip;
                                asic_ip.intIpAddr = ipEntry_t->intip;
                                asic_ip.localPublic = (ipEntry_t->type == 0x02)? 1: 0;
                                asic_ip.nat = (ipEntry_t->type == 0x01)? 1: 0;
                                asic_ip.nhIndex = ipEntry_t->nextHop_t ? ipEntry_t->nextHop_t->entryIndex: 0;
                                retval = rtl8651_setAsicExtIntIpTable(entry, &asic_ip);
                                do {} while (0);
                        }
                }


                if (validIpEntryNum != 0 && DrvTbl.iptbl[ipidx_candidate].valid == 0)
                {
                        retval = rtl8651_getAsicExtIntIpTable((def_napt_t - DrvTbl.iptbl) , &asic_ip);
                        do {} while (0);
                        retval = rtl8651_setAsicExtIntIpTable(ipidx_candidate, &asic_ip);
                        do {} while (0);
                }


                for (entry = 0; entry < 16; entry++)
                        _gidxRegister[entry] = ipidx_candidate;

                for (entry = 0; entry < 8; entry++)
                        regValue |= (ipidx_candidate << (3 * entry));
                retval = rtl8651_setAsicGidxRegister(regValue);
                do {} while (0);
        }
}

static int32 _rtl8651_delIpEntry(int8 attr, ipaddr_t extip, ipaddr_t intip)
{
        rtl8651_tblDrv_ipEntry_t *ipEntry_t=DrvTbl.iptbl;
        int32 entry, retval;



        for(entry=0; entry<16; entry++, ipEntry_t++) {
                if (ipEntry_t->valid == 0 || ipEntry_t->extip!=extip)
                        continue;
                switch (attr)
                {
                case 0x02: goto found;
                case 0x01: if (ipEntry_t->intip == intip)
                                                                goto found;
                case 0x00:
                        if (ipEntry_t->nextHop_t && ipEntry_t->nextHop_t->nextHopType == 0x01) {
                                if (intip == 0) {
                                        if (ipEntry_t->def_flag != 1)
                                                break;
                                } else if (ipEntry_t->nextHop_t->nexthop != intip)
                                        break;
                        }
                        if (--ipEntry_t->ref_cnt == 0) {
                                _rtl8651_delNextHopEntry(0x04, ipEntry_t);
                                goto found;
                        }
                        return 0;

                default: do {} while (0);
                }
        }
found:

        if (entry == 16)
                return -3;

        ipEntry_t->valid = 0;
        retval = rtl8651_delAsicExtIntIpTable(entry);
        do {} while (0);

        if (attr == 0x02)
                localServerCount--;
        else if (attr == 0x01)
                natIpCount--;
        else naptIpCount--;
        if (naptIpCount+natIpCount+localServerCount == 0)
                rtl8651_setAsicOperationLayer(3);
        do {} while (0);
        _rtl8651_updateGidxRegister();
        _rtl8651_RearrangeHWTrafficCounter();


        _rtl8651_arrangeAlliptbl_patch();

        return 0;
}



rtl8651_tblDrv_ipEntry_t *
_rtl8651_addIpEntry(ipaddr_t extip, ipaddr_t intip, int8 attr, rtl8651_tblDrv_networkIntfTable_t *netif_t)
{
        rtl8651_tblDrv_ipEntry_t *ipEntry_t=((void *)0), *track_t = DrvTbl.iptbl;
        rtl865x_tblAsicDrv_extIntIpParam_t asic_ip;
        rtl8651_tblDrv_pppTable_t *ppp_t;

        int32 entry, retval;
# 23002 "rtl8651_tblDrv.c"
        for(entry=0; entry<16; entry++, track_t++) {
                if (track_t->valid == 0) {
                        if (ipEntry_t == ((void *)0)) ipEntry_t = track_t;






                        if (ipEntry_t && attr==0x02 && (ipEntry_t-DrvTbl.iptbl)<2)
                                ipEntry_t = ((void *)0);
                        continue;
                }

                if (attr == 0x00) {

                        if (track_t->extip == extip && track_t->nextHop_t) {
                                if (track_t->nextHop_t->nextHopType == 0x01) {
                                        if (intip == 0) {
                                                if (track_t->def_flag == 0)
                                                        continue;
                                        } else if (intip != track_t->nextHop_t->nexthop)
                                                        continue;
                                }
                                track_t->ref_cnt ++;
                                return track_t;
                        }
                } else if (track_t->extip == extip)
                        return ((void *)0);
# 23039 "rtl8651_tblDrv.c"
        }
        if (ipEntry_t == ((void *)0))
                return ((void *)0);


        ipEntry_t->extip = extip;
        ipEntry_t->intip = (attr==0x00)? 0 :intip;
        ipEntry_t->type = attr;
        ipEntry_t->valid = 1;
        ipEntry_t->ref_cnt = 1;
        ipEntry_t->def_flag = 0;
        ipEntry_t->nextHop_t = ((void *)0);

        if (attr == 0x00) {
                if (netif_t->linkLayerType == 0x01)
                        ppp_t = ((void *)0);
                else if ((ppp_t = _rtl8651_getPPPInfo(0, extip)) == ((void *)0)) {
                                ipEntry_t->valid = 0;
                                return ((void *)0);
                }
                if (_rtl8651_addNextHopEntry(0x04, ipEntry_t, netif_t, intip, extip, ppp_t) == -1) {
                        ipEntry_t->valid = 0;
                        return ((void *)0);
                }
        }



        bzero(&asic_ip, sizeof(rtl865x_tblAsicDrv_extIntIpParam_t));
        asic_ip.extIpAddr = extip;
        asic_ip.intIpAddr = ipEntry_t->intip;
        asic_ip.localPublic = (attr == 0x02)? 1: 0;
        asic_ip.nat = (attr == 0x01)? 1: 0;
        asic_ip.nhIndex = ipEntry_t->nextHop_t ? ipEntry_t->nextHop_t->entryIndex: 0;
        retval = rtl8651_setAsicExtIntIpTable((ipEntry_t - DrvTbl.iptbl), &asic_ip);
        do {} while (0);

        if (attr == 0x00)
                naptIpCount++;
        else if (attr == 0x02)
                localServerCount++;
        else if (attr == 0x01)
                natIpCount++;
        if (natIpCount+naptIpCount+localServerCount >= 1)
                rtl8651_setAsicOperationLayer(4);
        do {} while (0);
        _rtl8651_updateGidxRegister();
        _rtl8651_RearrangeHWTrafficCounter();


        _rtl8651_arrangeAlliptbl_patch();

        return ipEntry_t;
}


rtl8651_tblDrv_ipEntry_t *
_rtl8651_getIPTableEntry(ipaddr_t extip, ipaddr_t intip, uint8 attr)
{
        rtl8651_tblDrv_ipEntry_t *asic_t = DrvTbl.iptbl;
        uint32 entry=0;
# 23108 "rtl8651_tblDrv.c"
        for(entry=0; entry<16; entry++, asic_t++) {
                switch (attr)
                {
                case 0x00:
                        if ((asic_t->extip == extip)&&(asic_t->type==0x00))
                                return asic_t;
                        break;
                case 0x01:
                        if ((asic_t->extip == extip) && (asic_t->intip == intip)&&(asic_t->type==0x01))
                                return asic_t;
                        break;
                case 0x02:
                        if ((asic_t->extip == extip)&&(asic_t->type==0x02))
                                return asic_t;
                        break;
                case 0x03:
                        if (extip) {
                                if (extip == asic_t->extip)
                                        return asic_t;
                                        }
                        if (intip) {
                                if (intip == asic_t->intip)
                                        return asic_t;
                                }
                        break;
                default: do {} while (0);
                        }
        }
        return (rtl8651_tblDrv_ipEntry_t *)((void *)0);
}
# 23149 "rtl8651_tblDrv.c"
void inline _rtl8651_setASICMulticastPortStatus(void) {
        uint32 index;

        for (index=0; index<6 +rtl8651_totalExtPortNum; index++) {
                rtl8651_setAsicMulticastPortInternal(index, (rtl8651_externalMulticastPortMask&(1<<index))?0:1);
        }
}

void _rtl8651_arrangeMulticastPortStatus(void) {

        uint32 index;

        for (index=0; index<6 +rtl8651_totalExtPortNum; index++) {






                uint8 vlanCnt;
                uint8 i;
                rtl8651_tblDrv_vlanTable_t *vlanPtr;

                vlanCnt = 0;
                for(i=0,vlanPtr=&DrvTbl.vlan[0]; i<8; i++, vlanPtr++) {
                        if (!(vlanPtr->memberPortMask & (1<<index)) || !vlanPtr->valid)
                                continue;
                        vlanCnt ++;
                        if (vlanPtr->internal)
                                goto isInternal;
                }
                if (vlanCnt) {
                        rtl8651_externalMulticastPortMask |= (1<<index);
                } else {
        isInternal:
                        rtl8651_externalMulticastPortMask &= ~(1<<index);
                }
        }
        _rtl8651_setASICMulticastPortStatus();
}






int32 rtl8651_addExternalMulticastPort(uint32 extMPort)
{
        rtl8651_externalMulticastPortMask |= (1<<extMPort);
        _rtl8651_setASICMulticastPortStatus();

        return 0;
}






int32 rtl8651_delExternalMulticastPort(uint32 extMPort)
{
        rtl8651_externalMulticastPortMask &= ~(1<<extMPort);
        _rtl8651_setASICMulticastPortStatus();

        return 0;
}
# 23223 "rtl8651_tblDrv.c"
static inline void _rtl8651_patchPppoeWeak(rtl8651_tblDrv_mCast_t *mCast_t)
{
        uint8 idx;
        rtl8651_tblDrv_vlanTable_t * vptr;


        vptr = DrvTbl.vlan;
        for (idx = 0 ; idx < 8 ; idx ++, vptr ++) {
                if ((1<<idx) & mCast_t->vlanMask) {
                        rtl8651_tblDrv_networkIntfTable_t *netif;
                        do {} while (0);
                        if (((netif = _rtl8651_getNetworkIntfEntryByVid(vptr->vid)) != ((void *)0)) &&
                                (netif->linkLayerType == 0x02)) {
                                mCast_t->flag |= 0x01;
                                return;
                        }
                }
        }
        mCast_t->flag &= ~0x01;
}




typedef struct __rtl8651_mcastAsicDipUsage_s {
        ipaddr_t dip;
        uint8 refcnt;
        uint8 ipEntryIdx;
} __rtl8651_mcastAsicDipUsage_t;
void _rtl8651_arrangeAllMulticast(void)
{
        __rtl8651_mcastAsicDipUsage_t asicMcastEntryDip[64];
        int32 totalEmptyIpEntryCnt = 0;
        int32 totalWanToLanDipCnt = 0;
        int32 patchIpEntryIdx = 0;
        int32 idx;



        if (! ((RtkHomeGatewayChipName[strlen(RtkHomeGatewayChipName) - 1] == 'B') &&
                  (RtkHomeGatewayChipRevisionID >= 0x02) &&
                  (RtkHomeGatewayChipRevisionID <= 0x03)))
        {
                return;
        }




        for ( idx = 0 ; idx < 16 ; idx ++ )
        {
                rtl865x_tblAsicDrv_extIntIpParam_t dummy;
                if ( rtl8651_getAsicExtIntIpTable( idx, &dummy ) != 0 )
                {
                        totalEmptyIpEntryCnt ++;
                }
        }

        ;






        bzero(asicMcastEntryDip, (sizeof(__rtl8651_mcastAsicDipUsage_t) * 64));

        for ( idx = 0 ; idx < 64 ; idx ++ )
        {
                rtl8651_tblDrv_mCast_t *mCast_t;

                for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[idx])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next))
                {
                        if ( ( mCast_t->inAsic == 1 ) &&
                                ( mCast_t->ipEntry_t == ((void *)0) ))
                        {
                                int32 dipIdx;

                                for ( dipIdx = 0 ; dipIdx < 64 ; dipIdx ++ )
                                {
                                        if ( asicMcastEntryDip[dipIdx].dip == mCast_t->dip )
                                        {
                                                asicMcastEntryDip[dipIdx].refcnt ++;

                                                ;




                                                break;
                                        }
                                        if ( asicMcastEntryDip[dipIdx].dip == 0 )
                                        {
                                                break;
                                        }
                                }
                                if ( dipIdx >= 64 )
                                {
                                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 23321, "Total DIP count can NOT exceed ASIC multicast table size."); while(1);} while (0);;
                                } else
                                {
                                        if ( asicMcastEntryDip[dipIdx].dip == 0 )
                                        {
                                                asicMcastEntryDip[dipIdx].dip = mCast_t->dip;
                                                asicMcastEntryDip[dipIdx].refcnt = 1;
                                                totalWanToLanDipCnt ++;

                                                ;




                                        }
                                }
                                goto step2NextIdx;
                        }
                }
step2NextIdx:
                ;
        }
# 23354 "rtl8651_tblDrv.c"
        ;





        {
                __rtl8651_mcastAsicDipUsage_t *currMax = ((void *)0);
                int32 remainPatchCnt = ((totalEmptyIpEntryCnt>totalWanToLanDipCnt)?totalWanToLanDipCnt:totalEmptyIpEntryCnt);
# 23374 "rtl8651_tblDrv.c"
                while ( remainPatchCnt > 0 )
                {
                        currMax = ((void *)0);
                        for ( idx = 0 ; idx < 64 ; idx ++ )
                        {
                                if ( ( asicMcastEntryDip[idx].dip != 0 ) &&
                                        ( asicMcastEntryDip[idx].refcnt > 0 ))
                                {
                                        if ( ( currMax == ((void *)0) ) ||
                                                ( asicMcastEntryDip[idx].refcnt > currMax->refcnt ))
                                        {
                                                currMax = &asicMcastEntryDip[idx];
                                        }
                                }
                        }
                        if ( currMax == ((void *)0) )
                        {
                                do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 23391, "least one HW used DIP entry must be found. (make sure this at step 1)"); while(1);} while (0);;
                        } else
                        {
                                currMax->refcnt = 0;
                                remainPatchCnt --;
                        }
                }
        }




        {
                int32 ipEntryIdx = 0, nextPatchDipIdx = 0;
                int32 remainPatchCnt = ((totalEmptyIpEntryCnt>totalWanToLanDipCnt)?totalWanToLanDipCnt:totalEmptyIpEntryCnt);

                while ( remainPatchCnt > 0 )
                {
                        rtl865x_tblAsicDrv_extIntIpParam_t dummy;

                        if ( ipEntryIdx >= 16 )
                        {
                                do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 23413, "least one HW used DIP entry must be found. (make sure this at step 1)"); while(1);} while (0);;
                        }


                        if ( rtl8651_getAsicExtIntIpTable( ipEntryIdx, &dummy ) != 0 )
                        {
                                for ( idx = nextPatchDipIdx ; idx < 64 ; idx ++ )
                                {
                                        if ( ( asicMcastEntryDip[idx].dip != 0 ) &&
                                                ( asicMcastEntryDip[idx].refcnt == 0 ))
                                        {

                                                rtl865x_tblAsicDrv_extIntIpParam_t ipEntry_t;

                                                bzero(&ipEntry_t, sizeof(ipEntry_t));
                                                ipEntry_t.extIpAddr = asicMcastEntryDip[idx].dip;
                                                rtl8651_setInvalidAsicExtIntIpTable( ipEntryIdx, &ipEntry_t );
                                                asicMcastEntryDip[idx].ipEntryIdx = ipEntryIdx;

                                                ;





                                                nextPatchDipIdx = idx + 1;
                                                remainPatchCnt --;
                                                goto nextIpEntryPatch;
                                        }
                                }

                                do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 23444, "For all empty IP entry, we would always can find a DIP to patch. (make sure at step 1/2)."); while(1);} while (0);;
                        }
nextIpEntryPatch:
                        ipEntryIdx ++;
                }

                patchIpEntryIdx = ipEntryIdx;
        }




        {
                for ( idx = 0 ; idx < 64 ; idx ++ )
                {
                        rtl8651_tblDrv_mCast_t *mCast_t;

                        for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[idx])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next))
                        {
                                if ( ( mCast_t->inAsic == 1 ) &&
                                        ( mCast_t->ipEntry_t == ((void *)0) ) )
                                {
                                        int mcastDipIdx;

                                        for ( mcastDipIdx = 0 ; mcastDipIdx < 64 ; mcastDipIdx ++ )
                                        {

                                                if ( ( asicMcastEntryDip[mcastDipIdx].dip == mCast_t->dip ) &&
                                                        ( asicMcastEntryDip[mcastDipIdx].refcnt == 0 ))
                                                {
                                                        rtl865x_tblAsicDrv_multiCastParam_t asic_mcast;

                                                        ;







                                                        bzero(&asic_mcast, sizeof(asic_mcast));
                                                        rtl8651_memcpy(&asic_mcast, mCast_t, (uint32)&(((rtl8651_tblDrv_mCast_t *)0)->ipEntry_t));
                                                        asic_mcast.extIdx = asicMcastEntryDip[mcastDipIdx].ipEntryIdx;
                                                        rtl8651_setAsicIpMulticastTable(&asic_mcast);

                                                        break;
                                                }
                                        }

                                        ;






                                        if ( mcastDipIdx >= 64 )
                                        {
                                                rtl8651_tblDrv_mCast_t *swMcast_t = ((void *)0);
                                                rtl8651_tblDrv_mCast_t *select_t = ((void *)0);
                                                __rtl8651_mcastAsicDipUsage_t *swMcastPatch = ((void *)0);
                                                __rtl8651_mcastAsicDipUsage_t *selectPatch = ((void *)0);

                                                for (swMcast_t = ((&DrvTbl.inuseList.mCastTbl[idx])->tqh_first); swMcast_t; swMcast_t = ((swMcast_t)->nextMCast.tqe_next))
                                                {
                                                        if ( (swMcast_t != mCast_t) &&
                                                                (swMcast_t->cpu == 0) &&
                                                                ((swMcast_t->flag & 0x01) == 0))
                                                        {
                                                                swMcastPatch = ((void *)0);
                                                                if ( swMcast_t->ipEntry_t == ((void *)0) )
                                                                {
                                                                        for ( mcastDipIdx = 0 ; mcastDipIdx < 64 ; mcastDipIdx ++ )
                                                                        {
                                                                                if ( ( asicMcastEntryDip[mcastDipIdx].dip == mCast_t->dip ) &&
                                                                                        ( asicMcastEntryDip[mcastDipIdx].refcnt == 0 ))
                                                                                {
                                                                                        swMcastPatch = &(asicMcastEntryDip[mcastDipIdx]);
                                                                                        break;
                                                                                }
                                                                        }
                                                                        if ( swMcastPatch == ((void *)0) )
                                                                        {
                                                                                goto nextMcastIdxEntry;
                                                                        }
                                                                }
# 23538 "rtl8651_tblDrv.c"
                                                                if ( ( select_t == ((void *)0) ) ||
                                                                        ( swMcast_t->count > select_t->count ) )
                                                                {
                                                                        select_t = swMcast_t;
                                                                        selectPatch = swMcastPatch;
                                                                }

                                                        }
nextMcastIdxEntry:
                                                        ;
                                                }




                                                mCast_t->inAsic = 0;


                                                if ( select_t )
                                                {

                                                        rtl865x_tblAsicDrv_multiCastParam_t asic_mcast;

                                                        select_t->inAsic = 1;
                                                        select_t->age = 10;
                                                        bzero(&asic_mcast, sizeof(rtl865x_tblAsicDrv_multiCastParam_t));
                                                        rtl8651_memcpy(&asic_mcast, select_t, (uint32)&(((rtl8651_tblDrv_mCast_t *)0)->ipEntry_t));
                                                        if ( select_t->ipEntry_t )
                                                        {
                                                                asic_mcast.extIdx = (select_t->ipEntry_t - DrvTbl.iptbl);
                                                        } else
                                                        {
                                                                if ( selectPatch == ((void *)0) )
                                                                {
                                                                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 23572, "selectPatch must be found at above code."); while(1);} while (0);;
                                                                }
                                                                asic_mcast.extIdx = selectPatch->ipEntryIdx;
                                                        }
                                                        rtl8651_setAsicIpMulticastTable( &asic_mcast );

                                                        ;






                                                        do { if (((select_t)->nextMCast.tqe_next) != ((void *)0)) (select_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (select_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[idx])->tqh_last = (select_t)->nextMCast.tqe_prev; *(select_t)->nextMCast.tqe_prev = (select_t)->nextMCast.tqe_next; } while (0);
                                                        do { if (((select_t)->nextMCast.tqe_next = (&DrvTbl.inuseList.mCastTbl[idx])->tqh_first) != ((void *)0)) (&DrvTbl.inuseList.mCastTbl[idx])->tqh_first->nextMCast.tqe_prev = &(select_t)->nextMCast.tqe_next; else (&DrvTbl.inuseList.mCastTbl[idx])->tqh_last = &(select_t)->nextMCast.tqe_next; (&DrvTbl.inuseList.mCastTbl[idx])->tqh_first = (select_t); (select_t)->nextMCast.tqe_prev = &(&DrvTbl.inuseList.mCastTbl[idx])->tqh_first; } while (0);
                                                } else
                                                {
                                                        ;



                                                        rtl8651_delAsicIpMulticastTable( idx );
                                                }
                                        }


                                        goto step5NextIdx;
                                }
                        }
step5NextIdx:
                        ;
                }
        }





        if ( totalEmptyIpEntryCnt > totalWanToLanDipCnt )
        {
                int32 remainEmptyIpEntryCnt = totalEmptyIpEntryCnt - totalWanToLanDipCnt;
                int32 currPatchIpEntryIdx;

                for ( idx = 0 ; idx < 64 ; idx ++ )
                {
                        rtl8651_tblDrv_mCast_t *mCast_t = ((void *)0);
                        rtl8651_tblDrv_mCast_t *select_t = ((void *)0);

                        for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[idx])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next))
                        {
                                if ( mCast_t->inAsic == 1 )
                                {
                                        break;
                                }
                        }

                        if ( mCast_t )
                        {
                                continue;
                        }


                        currPatchIpEntryIdx = -1;
                        for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[idx])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next))
                        {
                                if ( ( mCast_t->cpu == 0 ) &&
                                        (( mCast_t->flag & 0x01) == 0 ))
                                {
                                        if ( ( select_t == ((void *)0) ) ||
                                                ( mCast_t->count > select_t->count) )
                                        {
                                                if ( select_t->ipEntry_t == ((void *)0) )
                                                {
                                                        int32 mcastDipIdx;


                                                        for ( mcastDipIdx = 0 ; mcastDipIdx < 64 ; mcastDipIdx ++ )
                                                        {
                                                                if ( ( asicMcastEntryDip[mcastDipIdx].dip == mCast_t->dip ) &&
                                                                        ( asicMcastEntryDip[mcastDipIdx].refcnt == 0 ))
                                                                {
                                                                        currPatchIpEntryIdx = asicMcastEntryDip[mcastDipIdx].ipEntryIdx;
                                                                        break;
                                                                }
                                                        }


                                                        if ( ( mcastDipIdx >= 64 ) &&
                                                                ( remainEmptyIpEntryCnt == 0 ))
                                                        {
                                                                continue;
                                                        }
                                                }

                                                select_t = mCast_t;
                                        }
                                }
                        }
# 23680 "rtl8651_tblDrv.c"
                        if ( select_t )
                        {
                                rtl865x_tblAsicDrv_multiCastParam_t asic_mcast;

                                ;







                                if ( select_t->ipEntry_t == ((void *)0) )
                                {

                                        if ( currPatchIpEntryIdx < 0 )
                                        {
                                                int32 ipEntryIdx;

                                                for ( ipEntryIdx = patchIpEntryIdx ; ipEntryIdx < 16 ; ipEntryIdx ++ )
                                                {
                                                        rtl865x_tblAsicDrv_extIntIpParam_t dummy;


                                                        if ( rtl8651_getAsicExtIntIpTable( ipEntryIdx, &dummy ) != 0 )
                                                        {
                                                                break;
                                                        }
                                                }
                                                if ( ipEntryIdx >= 16 )
                                                {
                                                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 23711, "There must have additional empty IP table. (make sure at start of step 6)"); while(1);} while (0);;
                                                } else
                                                {
                                                        rtl865x_tblAsicDrv_extIntIpParam_t ipEntry_t;

                                                        ;





                                                        bzero(&ipEntry_t, sizeof(ipEntry_t));
                                                        ipEntry_t.extIpAddr = select_t->dip;
                                                        rtl8651_setInvalidAsicExtIntIpTable( ipEntryIdx, &ipEntry_t );
                                                        currPatchIpEntryIdx = ipEntryIdx;
                                                        patchIpEntryIdx = ipEntryIdx + 1;
                                                        remainEmptyIpEntryCnt --;
                                                }
                                        }
                                }


                                select_t->inAsic = 1;
                                select_t->age = 10;
                                bzero( &asic_mcast, sizeof( rtl865x_tblAsicDrv_multiCastParam_t ) );
                                rtl8651_memcpy(&asic_mcast, select_t, (uint32)&(((rtl8651_tblDrv_mCast_t *)0)->ipEntry_t));
                                if ( select_t->ipEntry_t )
                                {
                                        asic_mcast.extIdx = (select_t->ipEntry_t - DrvTbl.iptbl);
                                } else
                                {
                                        asic_mcast.extIdx = currPatchIpEntryIdx;
                                }
                                rtl8651_setAsicIpMulticastTable( &asic_mcast );
                                do { if (((select_t)->nextMCast.tqe_next) != ((void *)0)) (select_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (select_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[idx])->tqh_last = (select_t)->nextMCast.tqe_prev; *(select_t)->nextMCast.tqe_prev = (select_t)->nextMCast.tqe_next; } while (0);
                                do { if (((select_t)->nextMCast.tqe_next = (&DrvTbl.inuseList.mCastTbl[idx])->tqh_first) != ((void *)0)) (&DrvTbl.inuseList.mCastTbl[idx])->tqh_first->nextMCast.tqe_prev = &(select_t)->nextMCast.tqe_next; else (&DrvTbl.inuseList.mCastTbl[idx])->tqh_last = &(select_t)->nextMCast.tqe_next; (&DrvTbl.inuseList.mCastTbl[idx])->tqh_first = (select_t); (select_t)->nextMCast.tqe_prev = &(&DrvTbl.inuseList.mCastTbl[idx])->tqh_first; } while (0);

                        }
                }
        }

}



static void _rtl8651_arrangeMulticast(uint32 entryIndex)
{
        rtl865x_tblAsicDrv_multiCastParam_t asic_mcast;
        rtl8651_tblDrv_mCast_t *mCast_t, *select_t=((void *)0);
        int32 retval;

        for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entryIndex])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                if ((mCast_t->cpu == 0) && !(mCast_t->flag & 0x01)) {
                        if (select_t) {
                                if (mCast_t->count > select_t->count)
                                        select_t = mCast_t;
                        } else select_t = mCast_t;
                }
                mCast_t->inAsic = 0;
        }
        if (select_t) {
                select_t->inAsic = 1;
                select_t->age = 10;
                bzero(&asic_mcast, sizeof(rtl865x_tblAsicDrv_multiCastParam_t));
                rtl8651_memcpy(&asic_mcast, select_t, (uint32)&(((rtl8651_tblDrv_mCast_t *)0)->ipEntry_t));
                if (select_t->ipEntry_t)
                        asic_mcast.extIdx = (select_t->ipEntry_t - DrvTbl.iptbl);
                retval = rtl8651_setAsicIpMulticastTable(&asic_mcast);
                do {} while (0);
                do { if (((select_t)->nextMCast.tqe_next) != ((void *)0)) (select_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (select_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[entryIndex])->tqh_last = (select_t)->nextMCast.tqe_prev; *(select_t)->nextMCast.tqe_prev = (select_t)->nextMCast.tqe_next; } while (0);
                do { if (((select_t)->nextMCast.tqe_next = (&DrvTbl.inuseList.mCastTbl[entryIndex])->tqh_first) != ((void *)0)) (&DrvTbl.inuseList.mCastTbl[entryIndex])->tqh_first->nextMCast.tqe_prev = &(select_t)->nextMCast.tqe_next; else (&DrvTbl.inuseList.mCastTbl[entryIndex])->tqh_last = &(select_t)->nextMCast.tqe_next; (&DrvTbl.inuseList.mCastTbl[entryIndex])->tqh_first = (select_t); (select_t)->nextMCast.tqe_prev = &(&DrvTbl.inuseList.mCastTbl[entryIndex])->tqh_first; } while (0);



                _rtl8651_arrangeAllMulticast();

        }
        else rtl8651_delAsicIpMulticastTable(entryIndex);
}




void _rtl8651_timeUpdateMulticast(uint32 secPassed)
{

        rtl8651_tblDrv_mCast_t *mCast_t, *tmp_t;
        uint32 entry;




        for (entry=0; entry< rtl8651_tblDrvPara.mCastTblSize; entry ++)
        {
                int32 idx;
                rtl865x_tblAsicDrv_multiCastParam_t mAsicCast_t;
                for ( idx = 0 ; idx < 64 ; idx ++ )
                {
                        if (rtl8651_getAsicIpMulticastTable(idx, &mAsicCast_t) == 0)
                        {
                                if ( (mAsicCast_t.mbr & rtl8651_externalMulticastPortMask) &&
                                        (mAsicCast_t.age > 10))
                                {
                                        rtl8651_tblDrv_ipEntry_t *ipEntry_t;
                                        ipEntry_t = &DrvTbl.iptbl[mAsicCast_t.extIdx];
                                        if ((mAsicCast_t.extIdx < 16) && ipEntry_t->valid)
                                        {
                                                rtl8651_tblDrv_networkIntfTable_t *netif_t;
                                                if (((netif_t = _rtl8651_getIpInfo( ipEntry_t->extip,
                                                                                                                ((void *)0),
                                                                                                                ((void *)0),
                                                                                                                ((void *)0))) != ((void *)0)) &&
                                                        (netif_t->valid))
                                                {
                                                        if (netif_t->linkLayerType == 0x01)
                                                        {




                                                                ;




                                                                _rtl8651_recordTraffic( 0 , 1 );
                                                        } else
                                                        {

                                                                rtl8651_tblDrvSession_t *psession_t;
                                                                for (psession_t = ((&netif_t->sessionHead)->tqh_first); psession_t; psession_t = ((psession_t)->nextSession.tqe_next))
                                                                {
                                                                        if (psession_t->session_t && psession_t->session_t->valid == 1)
                                                                        {
                                                                                ;




                                                                                _rtl8651_recordTraffic(_rtl8651_SessionIDToDSID(psession_t->session_t->sessionId), 1 );
                                                                        }
                                                                }
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }


        for (entry=0; entry< rtl8651_tblDrvPara.mCastTblSize; entry++) {
                mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first);
                while (mCast_t) {
                        if (mCast_t->inAsic == 1) {

                                if (mCast_t->age <= secPassed) {
                                        mCast_t->age = 35;
                                        _rtl8651_arrangeMulticast(entry);
                                } else mCast_t->age -= secPassed;
                        } else {

                                if (mCast_t->age <= secPassed) {
                                        tmp_t = ((mCast_t)->nextMCast.tqe_next);
                                        do { if (((mCast_t)->nextMCast.tqe_next) != ((void *)0)) (mCast_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = (mCast_t)->nextMCast.tqe_prev; *(mCast_t)->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_next; } while (0);
                                        do { if (((mCast_t)->nextMCast.tqe_next = (&DrvTbl.freeList.freeMultiCast)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMultiCast)->tqh_first->nextMCast.tqe_prev = &(mCast_t)->nextMCast.tqe_next; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(mCast_t)->nextMCast.tqe_next; (&DrvTbl.freeList.freeMultiCast)->tqh_first = (mCast_t); (mCast_t)->nextMCast.tqe_prev = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);
                                        mCast_t = tmp_t;
                                        continue;
                                } else mCast_t->age -= secPassed;
                        }
                        mCast_t->count = 0;
                        mCast_t = ((mCast_t)->nextMCast.tqe_next);
                }
        }
}

int32 _rtl8651_addMulticast(ipaddr_t mAddr, ipaddr_t sip, uint16 svid, uint16 sport, uint32 dvidMask, uint32 mbr, ipaddr_t extIp, int8 toCpu, uint8 flag)
{

        rtl8651_tblDrv_mCast_t *mCast_t, *empty_t;
        uint32 entry = rtl8651_ipMulticastTableIndex(sip, mAddr);


        for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                if (mCast_t->sip==sip && mCast_t->dip==mAddr && mCast_t->svid==svid && mCast_t->port==sport)
                        break;
        }
        if (mCast_t == ((void *)0)) {
                if ((empty_t=((&DrvTbl.freeList.freeMultiCast)->tqh_first)) == ((void *)0))
                        return -1;
                do { if (((empty_t)->nextMCast.tqe_next) != ((void *)0)) (empty_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (empty_t)->nextMCast.tqe_prev; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = (empty_t)->nextMCast.tqe_prev; *(empty_t)->nextMCast.tqe_prev = (empty_t)->nextMCast.tqe_next; } while (0);
                do { (empty_t)->nextMCast.tqe_next = ((void *)0); (empty_t)->nextMCast.tqe_prev = (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last; *(&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = (empty_t); (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = &(empty_t)->nextMCast.tqe_next; } while (0);
                mCast_t = empty_t;
                mCast_t->sip = sip;
                mCast_t->dip = mAddr;
                mCast_t->svid = svid;
                mCast_t->port = sport;
                mCast_t->vlanMask = 0;
                mCast_t->mbr = 0;
                mCast_t->count = 0;
                mCast_t->inAsic = 0;
        }
        mCast_t->ipEntry_t = (extIp)?_rtl8651_getIPTableEntry(extIp, 0, 0x03):((void *)0);
        mCast_t->vlanMask |= dvidMask;
        mCast_t->mbr |= mbr;
        mCast_t->age = 35;
        mCast_t->cpu = (toCpu==1? 1: 0);
        mCast_t->flag = flag;
        if (extIp)
                mCast_t->flag |= 0x02;
        else
                mCast_t->flag &= ~0x02;

        _rtl8651_patchPppoeWeak(mCast_t);
        _rtl8651_arrangeMulticast(entry);
        return 0;
}

int32 _rtl8651_addMulticastMember(ipaddr_t mcast_addr, uint32 vlanMask, uint32 mbr)
{

        rtl8651_tblDrv_mCast_t *mCast_t;
        uint32 entry, idx = 0, srcVlanMask, mbr_add;

        do {} while (0);

        for (entry=0; entry< rtl8651_tblDrvPara.mCastTblSize; entry++) {
                for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                        if (mCast_t->dip != mcast_addr)
                                continue;


                srcVlanMask = 1<<(mCast_t->svid& (8 -1));
                mbr_add = mbr;
                if (srcVlanMask == vlanMask) {
                        mbr_add = mbr & ~(1<<mCast_t->port);
                        if (mbr_add == 0)
                                continue;
                }


                        if (mCast_t->flag & 0x04)
                        {
                                do {} while (0);
                                mCast_t->flag &= ~0x04;
                                mCast_t->mbr = 0;
                                mCast_t->vlanMask = 0;


                                mCast_t->flag &= ~0x02;
                                mCast_t->ipEntry_t = 0;
                        }

                        mCast_t->mbr |= mbr_add;
                        mCast_t->vlanMask |= vlanMask;

                        _rtl8651_patchPppoeWeak(mCast_t);
                        _rtl8651_arrangeMulticast(entry);
                        idx = entry;
                }
        }

        if (idx) {
                return 0;
        }
        return -1;
}

int32 _rtl8651_delMulticast(ipaddr_t mcast_addr, uint32 vlanMask, uint32 mbr)
{

        rtl8651_tblDrv_mCast_t *mCast_t, *temp_t;
        uint32 entry;






        for(entry=0; entry<rtl8651_tblDrvPara.mCastTblSize; entry++) {

                if (!mbr && !vlanMask) {
                        mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first);
                        while (mCast_t) {
                                if (!mcast_addr || mCast_t->dip == mcast_addr) {
                                        temp_t = ((mCast_t)->nextMCast.tqe_next);
                                        do { if (((mCast_t)->nextMCast.tqe_next) != ((void *)0)) (mCast_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = (mCast_t)->nextMCast.tqe_prev; *(mCast_t)->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_next; } while (0);
                                        do { if (((mCast_t)->nextMCast.tqe_next = (&DrvTbl.freeList.freeMultiCast)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMultiCast)->tqh_first->nextMCast.tqe_prev = &(mCast_t)->nextMCast.tqe_next; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(mCast_t)->nextMCast.tqe_next; (&DrvTbl.freeList.freeMultiCast)->tqh_first = (mCast_t); (mCast_t)->nextMCast.tqe_prev = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);
                                        mCast_t = temp_t;
                                }
                                else mCast_t = ((mCast_t)->nextMCast.tqe_next);
                        }
                        _rtl8651_arrangeMulticast(entry);
                        continue;
                }

again:
                for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                        if (mcast_addr && mCast_t->dip != mcast_addr)
                                continue;
                        if (vlanMask) {

                                do {} while (0);

                                if ((mCast_t->vlanMask & vlanMask) == 0) {

                                        continue;
                                }

                                {
                                        uint32 other_vlanMask;

                                        other_vlanMask = mCast_t->vlanMask & ~vlanMask;


                                        if (other_vlanMask)
                                        {
                                                rtl8651_tblDrv_vlanTable_t * vptr;
                                                uint32 idx;

                                                vptr = DrvTbl.vlan;
                                                for (idx = 0 ; idx < 8 ; idx ++, vptr ++) {

                                                        if ((1<<idx) & other_vlanMask) {

                                                                if ((mbr & mCast_t->mbr) & vptr->memberPortMask)
                                                                        goto remove_entry;
                                                        }

                                                        if ((1<<idx) & vlanMask) {
                                                                if (((mCast_t->mbr & ~mbr) & vptr->memberPortMask) == 0) {
                                                                        mCast_t->vlanMask &= ~vlanMask;
                                                                }
                                                        }
                                                }
                                        }

remove_mbr:
                                        mCast_t->mbr &= ~mbr;
                                        if (mCast_t->mbr == 0) {
remove_entry:
                                                do { if (((mCast_t)->nextMCast.tqe_next) != ((void *)0)) (mCast_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = (mCast_t)->nextMCast.tqe_prev; *(mCast_t)->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_next; } while (0);
                                                do { if (((mCast_t)->nextMCast.tqe_next = (&DrvTbl.freeList.freeMultiCast)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMultiCast)->tqh_first->nextMCast.tqe_prev = &(mCast_t)->nextMCast.tqe_next; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(mCast_t)->nextMCast.tqe_next; (&DrvTbl.freeList.freeMultiCast)->tqh_first = (mCast_t); (mCast_t)->nextMCast.tqe_prev = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);
                                                _rtl8651_arrangeMulticast(entry);
                                                goto again;
                                        }
                                }

                        }else
                        {
                                goto remove_mbr;
                        }
                        _rtl8651_patchPppoeWeak(mCast_t);
                }
                _rtl8651_arrangeMulticast(entry);
        }

        return 0;
}


rtl8651_tblDrv_mCast_t *_rtl8651_findMCast(ipaddr_t mAddr, ipaddr_t sip, uint16 svid, uint16 sport)
{
        rtl8651_tblDrv_mCast_t *mCast_t;
        uint32 entry = rtl8651_ipMulticastTableIndex(sip, mAddr);

        for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                if (mCast_t->dip==mAddr && mCast_t->sip==sip && mCast_t->svid==svid && mCast_t->port==sport)
                {

                        if (mCast_t->inAsic == 0) {

                                mCast_t->age = 35;
                                mCast_t->count ++;
                                if (mCast_t->count > 300) {

                                        if ((mCast_t->cpu == 0) && !(mCast_t->flag & 0x01)) {
                                                _rtl8651_arrangeMulticast(entry);
                                        }
                                }

                        }

                        return mCast_t;
                }
        }
        return (rtl8651_tblDrv_mCast_t *)((void *)0);
}

int32 _rtl8651_delMulticastUpStream(ipaddr_t mcast_addr, ipaddr_t sip, uint16 svid, uint16 sport)
{

        rtl8651_tblDrv_mCast_t *mCast_t;
        uint32 entry;
        for(entry=0; entry<rtl8651_tblDrvPara.mCastTblSize; entry++) {
                for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                        if ((!mcast_addr || mCast_t->dip == mcast_addr) && (!sip || mCast_t->sip==sip) && (!svid || mCast_t->svid==svid) && mCast_t->port==sport) {
                                do { if (((mCast_t)->nextMCast.tqe_next) != ((void *)0)) (mCast_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = (mCast_t)->nextMCast.tqe_prev; *(mCast_t)->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_next; } while (0);
                                do { if (((mCast_t)->nextMCast.tqe_next = (&DrvTbl.freeList.freeMultiCast)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMultiCast)->tqh_first->nextMCast.tqe_prev = &(mCast_t)->nextMCast.tqe_next; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(mCast_t)->nextMCast.tqe_next; (&DrvTbl.freeList.freeMultiCast)->tqh_first = (mCast_t); (mCast_t)->nextMCast.tqe_prev = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);
                                _rtl8651_arrangeMulticast(entry);
                                return 0;
                        }
                }
        }
        return -1;
}


int32 _rtl8651_setMGroupAttribute(ipaddr_t groupIp, int8 toCpu)
{
        rtl8651_tblDrv_mCast_t *mCast_t;
        uint32 entry;

        for(entry=0; entry<rtl8651_tblDrvPara.mCastTblSize; entry++) {
                for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                        if (mCast_t->dip == groupIp)
                                mCast_t->cpu = (toCpu==1? 1: 0);
                }
                _rtl8651_arrangeMulticast(entry);
        }
        return 0;
}

int32 _rtl8651_delMulticastByVid(uint32 vid)
{
        rtl8651_tblDrv_vlanTable_t * svlan = &DrvTbl.vlan[(vid& (8 -1))];
        uint32 sportMask = svlan->memberPortMask;
        uint16 sport;


        sport = 0;
        while (sportMask) {
                if (sportMask & 1)
                        _rtl8651_delMulticastUpStream(0, 0, vid, sport);
                sportMask = sportMask >> 1;
                sport ++;
        }

        _rtl8651_delMulticast(0, (1<<(vid & (8 -1))), svlan->memberPortMask);

        return -1;
}

int32 _rtl8651_delMulticastByPort(uint32 port)
{
        uint32 portMask = 1<<port;
        uint32 vlanMask = 0;


        _rtl8651_delMulticastUpStream(0, 0, 0, port);


        {
                uint8 i;
                rtl8651_tblDrv_vlanTable_t *vlanPtr;
                for(i=0,vlanPtr=&DrvTbl.vlan[0]; i<8; i++, vlanPtr++) {
                        if (vlanPtr->memberPortMask == portMask)
                                vlanMask |= 1<<i;
                }
        }


        {
                rtl8651_tblDrv_mCast_t *mCast_t;
                uint32 entry;

                for(entry=0; entry<rtl8651_tblDrvPara.mCastTblSize; entry++) {
        again:
                        for (mCast_t = ((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next)) {
                                if (!(mCast_t->mbr & portMask))
                                        continue;
                                {
                                        uint32 mask = mCast_t->vlanMask & vlanMask;
                                        if (mask) {
                                                uint32 tmp = (~mask) + 1;
                                                if (mask != (mask & tmp))
                                                        goto remove;
                                        }
                                }
                                mCast_t->mbr &= ~portMask;
                                mCast_t->vlanMask&= ~vlanMask;
                                if ((mCast_t->mbr == 0) || (mCast_t->vlanMask == 0)) {
        remove:
                                        do { if (((mCast_t)->nextMCast.tqe_next) != ((void *)0)) (mCast_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = (mCast_t)->nextMCast.tqe_prev; *(mCast_t)->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_next; } while (0);
                                        do { if (((mCast_t)->nextMCast.tqe_next = (&DrvTbl.freeList.freeMultiCast)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMultiCast)->tqh_first->nextMCast.tqe_prev = &(mCast_t)->nextMCast.tqe_next; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(mCast_t)->nextMCast.tqe_next; (&DrvTbl.freeList.freeMultiCast)->tqh_first = (mCast_t); (mCast_t)->nextMCast.tqe_prev = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);
                                        _rtl8651_arrangeMulticast(entry);
                                        goto again;
                                }
                                _rtl8651_patchPppoeWeak(mCast_t);
                        }
                        _rtl8651_arrangeMulticast(entry);
                }
        }

        return -1;
}







int32 _rtl8651_isMacAccessControlPermit(ether_addr_t *sMac)
{
        rtl8651_tblDrv_macACEntry_t *aclRule;
        ether_addr_t mac;
        int32 index;


        if (DrvTbl.macACInfo->enable == 0)
                return 1;

        for (aclRule = ((&DrvTbl.macACInfo->macAccessControl)->tqh_first); aclRule; aclRule = ((aclRule)->nextMAC.tqe_next)) {
                for(index=0; index<6; index++)
                        mac.octet[index] = (sMac->octet[index] & aclRule->macMask.octet[index]);
                if (memcmp(&mac, &aclRule->mac, 6) == 0) {
                        if (aclRule->actionType == 0x01)
                                return 1;
                        else return 0;
                }
        }

        return (int32)DrvTbl.macACInfo->def_permit;
}


void _rtl8651_arrangeNATbyMacAccessControl(void)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t = DrvTbl.netIface;
        rtl8651_tblDrv_natEntry_t *nat_t;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        uint32 entry;

        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                for((nat_t) = (&netif_t->nextNat)->slh_first; (nat_t); (nat_t) = (nat_t)->nextNatEntry.sle_next) {
                        if ((arp_t=_rtl8651_getArpEntry(((void *)0), nat_t->localIp, 0)) &&
                             _rtl8651_isMacAccessControlPermit(&arp_t->macInfo->macAddr)==0 )
                                _rtl8651_delIpEntry(0x01, nat_t->globalIp, nat_t->localIp);
                        else _rtl8651_addIpEntry(nat_t->globalIp, nat_t->localIp, 0x01, netif_t);
                }
        }
}


void _rtl8651_arrangeSPbyMacAccessControl(void)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t = DrvTbl.netIface;
        rtl8651_tblDrv_serverPortAsicArrangementEntry_t *asic_t;
        rtl8651_tblDrv_naptServerPortEntry_t *sp_t;
        rtl8651_tblDrv_arpEntry_t *arp_t;
        uint32 entry, index;

        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                for((sp_t) = (&netif_t->nextNaptServerPort)->slh_first; (sp_t); (sp_t) = (sp_t)->nextServerPort.sle_next) {

                        arp_t=_rtl8651_getArpEntry(((void *)0), sp_t->localIp, 0);

                        if ( (arp_t) && (_rtl8651_isMacAccessControlPermit(&arp_t->macInfo->macAddr)==0 ))
                        {
                                if (sp_t->toAsic == 1) {
                                        AsicTableUsage.serverPort[sp_t->asicTablePos].valid = 0;
                                        rtl8651_delAsicServerPortTable(sp_t->asicTablePos);
                                        sp_t->toAsic = 0;
                                }
                        }
                        else {
                                if ( sp_t->toAsic == 0 &&
                                     sp_t->localPort==sp_t->endLocalPort &&

                                     sp_t->tcp &&
                                     sp_t->udp



                                     )
                                {
                                        asic_t=&AsicTableUsage.serverPort[0];
                                        for(index=0; index<16; index++,asic_t++) {
                                                if(asic_t->valid == 0) {
                                                        sp_t->toAsic = 1;
                                                        sp_t->asicTablePos = index;
                                                        asic_t->valid = 1;
                                                        asic_t->servPort_t = sp_t;
                                                        convert_setAsicServerPortTable(index, sp_t->globalIp, sp_t->globalPort, sp_t->localIp, sp_t->localPort);
                                                        break;
                                                }
                                        }
                                }
                        }
                }
        }
}
# 24322 "rtl8651_tblDrv.c"
int32 rtl8651_addMacAccessControl(ether_addr_t *sMac, ether_addr_t *macMask, int8 isPermit)
{
        rtl8651_tblDrv_macACEntry_t *aclRule;

        int32 retval = 0, index;

        if (sMac == ((void *)0) || macMask == ((void *)0))
                return -6;
        rtlglue_drvMutexLock();
        if ((aclRule=((&DrvTbl.freeList.freeMacAccessControl)->tqh_first)) == ((void *)0)) {
                retval = -9;
                goto out;
        }
        bzero(aclRule, (uint32)&(((rtl8651_tblDrv_macACEntry_t *)0)->nextMAC) );
        aclRule->actionType = (isPermit==1)? 0x01: 0x02;
        aclRule->macMask = *macMask;
        for(index=0; index<6; index++)
                aclRule->mac.octet[index] = (sMac->octet[index] & macMask->octet[index]);
        do { if (((aclRule)->nextMAC.tqe_next) != ((void *)0)) (aclRule)->nextMAC.tqe_next->nextMAC.tqe_prev = (aclRule)->nextMAC.tqe_prev; else (&DrvTbl.freeList.freeMacAccessControl)->tqh_last = (aclRule)->nextMAC.tqe_prev; *(aclRule)->nextMAC.tqe_prev = (aclRule)->nextMAC.tqe_next; (&DrvTbl.freeList.freeMacAccessControl)->tqh_count--;} while (0);
        do { if (((aclRule)->nextMAC.tqe_next = (&DrvTbl.macACInfo->macAccessControl)->tqh_first) != ((void *)0)) (&DrvTbl.macACInfo->macAccessControl)->tqh_first->nextMAC.tqe_prev = &(aclRule)->nextMAC.tqe_next; else (&DrvTbl.macACInfo->macAccessControl)->tqh_last = &(aclRule)->nextMAC.tqe_next; (&DrvTbl.macACInfo->macAccessControl)->tqh_first = (aclRule); (aclRule)->nextMAC.tqe_prev = &(&DrvTbl.macACInfo->macAccessControl)->tqh_first; (&DrvTbl.macACInfo->macAccessControl)->tqh_count++;} while (0);
        _rtl8651_arrangeNATbyMacAccessControl();
        _rtl8651_arrangeSPbyMacAccessControl();

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 24361 "rtl8651_tblDrv.c"
int32 rtl8651_delMacAccessControl(ether_addr_t *sMac, ether_addr_t *macMask)
{
        rtl8651_tblDrv_macACEntry_t *aclRule;

        int32 retval = -3, index;
        ether_addr_t mac;

        if (sMac == ((void *)0) || macMask == ((void *)0))
                return -6;
        rtlglue_drvMutexLock();
        for (aclRule = ((&DrvTbl.macACInfo->macAccessControl)->tqh_first); aclRule; aclRule = ((aclRule)->nextMAC.tqe_next)) {
                for(index=0; index<6; index++)
                        mac.octet[index] = sMac->octet[index] & macMask->octet[index];
                if (!memcmp(&mac, &aclRule->mac, 6) && !memcmp(macMask, &aclRule->macMask, 6) ) {
                        do { if (((aclRule)->nextMAC.tqe_next) != ((void *)0)) (aclRule)->nextMAC.tqe_next->nextMAC.tqe_prev = (aclRule)->nextMAC.tqe_prev; else (&DrvTbl.macACInfo->macAccessControl)->tqh_last = (aclRule)->nextMAC.tqe_prev; *(aclRule)->nextMAC.tqe_prev = (aclRule)->nextMAC.tqe_next; (&DrvTbl.macACInfo->macAccessControl)->tqh_count--;} while (0);
                        do { if (((aclRule)->nextMAC.tqe_next = (&DrvTbl.freeList.freeMacAccessControl)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMacAccessControl)->tqh_first->nextMAC.tqe_prev = &(aclRule)->nextMAC.tqe_next; else (&DrvTbl.freeList.freeMacAccessControl)->tqh_last = &(aclRule)->nextMAC.tqe_next; (&DrvTbl.freeList.freeMacAccessControl)->tqh_first = (aclRule); (aclRule)->nextMAC.tqe_prev = &(&DrvTbl.freeList.freeMacAccessControl)->tqh_first; (&DrvTbl.freeList.freeMacAccessControl)->tqh_count++;} while (0);
                        _rtl8651_arrangeNATbyMacAccessControl();
                        _rtl8651_arrangeSPbyMacAccessControl();
                        retval = 0;
                        break;
                }
        }
        rtlglue_drvMutexUnlock();
        return retval;
}
# 24394 "rtl8651_tblDrv.c"
int32 rtl8651_flushMacAccessControl(void)
{
        rtl8651_tblDrv_macACEntry_t *aclRule;


        rtlglue_drvMutexLock();
        while ((aclRule=((&DrvTbl.macACInfo->macAccessControl)->tqh_first))) {
                do { if (((aclRule)->nextMAC.tqe_next) != ((void *)0)) (aclRule)->nextMAC.tqe_next->nextMAC.tqe_prev = (aclRule)->nextMAC.tqe_prev; else (&DrvTbl.macACInfo->macAccessControl)->tqh_last = (aclRule)->nextMAC.tqe_prev; *(aclRule)->nextMAC.tqe_prev = (aclRule)->nextMAC.tqe_next; (&DrvTbl.macACInfo->macAccessControl)->tqh_count--;} while (0);
                do { if (((aclRule)->nextMAC.tqe_next = (&DrvTbl.freeList.freeMacAccessControl)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMacAccessControl)->tqh_first->nextMAC.tqe_prev = &(aclRule)->nextMAC.tqe_next; else (&DrvTbl.freeList.freeMacAccessControl)->tqh_last = &(aclRule)->nextMAC.tqe_next; (&DrvTbl.freeList.freeMacAccessControl)->tqh_first = (aclRule); (aclRule)->nextMAC.tqe_prev = &(&DrvTbl.freeList.freeMacAccessControl)->tqh_first; (&DrvTbl.freeList.freeMacAccessControl)->tqh_count++;} while (0);
        }
        _rtl8651_arrangeNATbyMacAccessControl();
        _rtl8651_arrangeSPbyMacAccessControl();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 24418 "rtl8651_tblDrv.c"
int32 rtl8651_setMacAccessControlDefaultPermit(int8 isPermit)
{
        rtlglue_drvMutexLock();
        DrvTbl.macACInfo->def_permit = (isPermit==1)? 1: 0;
        _rtl8651_arrangeNATbyMacAccessControl();
        _rtl8651_arrangeSPbyMacAccessControl();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 24436 "rtl8651_tblDrv.c"
int32 rtl8651_enableMacAccessControl(int8 enable)
{
        rtlglue_drvMutexLock();
        DrvTbl.macACInfo->enable = (enable==1)? 1: 0;
        _rtl8651_arrangeNATbyMacAccessControl();
        _rtl8651_arrangeSPbyMacAccessControl();
        rtlglue_drvMutexUnlock();
        return 0;
}
# 24455 "rtl8651_tblDrv.c"
int32 rtl8651_installMTUCallBackFunction(int32 (*p_handler)(struct rtl_pktHdr *))
{
        rtlglue_drvMutexLock();
        p_mtuHandler = p_handler;
        rtlglue_drvMutexUnlock();
        return 0;
}
# 24473 "rtl8651_tblDrv.c"
void rtl8651_setPppoeMtu(uint32 pppObjId,uint16 mtu)
{
        rtl8651_tblDrv_pppTable_t *ppp_t;
        rtl8651_tblDrv_networkIntfTable_t *netif_t, *net_t=((void *)0);
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        uint16 minMtu, entry;

        rtlglue_drvMutexLock();

        pppoe_mss[pppObjId]=mtu-40;

        ppp_t = _rtl8651_getPppoeSessionByDsid(pppObjId);
        if (ppp_t) {

                ppp_t->mss = mtu - 40;
                do {} while (0);





                if (ppp_t->netif_t->mtu > mtu)
                        ppp_t->netif_t->mtu = mtu;


                net_t = ppp_t->netif_t;
                minMtu = mtu;
                netif_t = DrvTbl.netIface;
                for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                        if (netif_t->valid == 0 || netif_t->vid != ppp_t->vid)
                                continue;
                        if (netif_t->mtu < minMtu) {
                                minMtu = netif_t->mtu;
                                net_t = netif_t;
                        }
                }
                vlan_t = &DrvTbl.vlan[(ppp_t->vid& (8 -1))];
                if ((net_t->linkLayerType == 0x02)
                        || (net_t->linkLayerType == 0x04 && vlan_t->internal == 0))
                        vlan_t->mtu = minMtu + 8;
                else vlan_t->mtu = minMtu;

                RTL8651_SETASICVLAN(vlan_t);
        }

        rtlglue_drvMutexUnlock();
}
# 24531 "rtl8651_tblDrv.c"
void rtl8651_setMtu(uint16 mtu)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        int32 entry;

        rtlglue_drvMutexLock();
        rtl8651_mss=mtu-40;
        netif_t = DrvTbl.netIface;

        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                vlan_t = &DrvTbl.vlan[(netif_t->vid& (8 -1))];
                netif_t->mtu = mtu;
                vlan_t->mtu = mtu;
                RTL8651_SETASICVLAN(vlan_t);
        }
        rtlglue_drvMutexUnlock();
}







void rtl8651_getMtu(uint16 * mtu)
{
        * mtu = rtl8651_mss + 40;
}
# 24572 "rtl8651_tblDrv.c"
int32 rtl8651_setNetMtu(int8 *ifName, uint16 mtu)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t, *net_t;
        rtl8651_tblDrv_vlanTable_t *vlan_t;
        rtl8651_tblDrvSession_t *ppp_t;
        int32 retval=0, entry;

        rtlglue_drvMutexLock();
# 24590 "rtl8651_tblDrv.c"
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }
        netif_t->mtu = mtu;
        vlan_t = &DrvTbl.vlan[(netif_t->vid& (8 -1))];


        if (netif_t->linkLayerType != 0x01) {
                for (ppp_t = ((&netif_t->sessionHead)->tqh_first); ppp_t; ppp_t = ((ppp_t)->nextSession.tqe_next)) {
                        if (ppp_t->session_t) {
                                ppp_t->session_t->mss = mtu - 40;
                                pppoe_mss[_rtl8651_SessionIDToDSID(ppp_t->session_t->sessionId)] = mtu -40;
                        }
                }
        }



        if (vlan_t->internal == 0)
                rtl8651_mss=mtu-40;

        net_t = netif_t;

        netif_t = DrvTbl.netIface;
        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 0 || netif_t->vid != vlan_t->vid)
                        continue;
                if (netif_t->mtu < mtu)
                        mtu = netif_t->mtu;
        }
        if ((net_t->linkLayerType == 0x02)
                || (net_t->linkLayerType == 0x04 && vlan_t->internal == 0))
                vlan_t->mtu = mtu + 8;
        else vlan_t->mtu = mtu;
        RTL8651_SETASICVLAN(vlan_t);

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 24642 "rtl8651_tblDrv.c"
int32 rtl8651_getNetMtu(int8 *ifName, uint16 *mtu)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval = 0;

        if (!ifName || !mtu)
                return -6;
        rtlglue_drvMutexLock();
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }
        *mtu = netif_t->mtu;
out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 24722 "rtl8651_tblDrv.c"
static int32 _rtl8651_delRateLimitGroup(uint32 GroupId)
{
        rtl8651_tblDrv_rateLimit_t *rl_t;
        int32 entry;

        do {} while (0);

        for(entry=0, rl_t=DrvTbl.rateLimit; entry<32; entry++, rl_t++) {
                if (rl_t->groupId == GroupId) {
                        if (rl_t->ref_count > 0) {
                                return -3402;
                        }
                        rl_t->groupId = 0;
                        rtl8651_delAsicRateLimitTable((rl_t - DrvTbl.rateLimit));
                        return 0;
                }
        }
        return -3;
}


static int32 _rtl8651_delRateLimitRule(rtl8651_tblDrvAclRule_t *rule, uint32 GroupId)
{
        _rtl8651_tblDrvAclRule_t *rl_rule;
        rtl8651_tblDrv_rateLimit_t *rl_t;
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;};
        int32 entry;


        rl_t = DrvTbl.rateLimit;
        for(entry=0; entry<32; entry++, rl_t++)
                {

                if (rl_t->groupId == GroupId)
                        break;
                }
        if (entry == 32)
                return -3403;
        if (rule->actionType_ == 0x02) {
                if (rl_t->isByteCount == 1)
                        rule->actionType_ = 0x0c;
                else rule->actionType_ = 0x0a;
        }
        else {
                if (rl_t->isByteCount == 1)
                        rule->actionType_ = 0x0d;
                else rule->actionType_ = 0x0b;
        }

        if (rule->isEgressRateLimitRule_)
        {

                for ((rl_rule) = (*(((struct _aclStruct *)(((&rl_t->netif_t->outRateLimitHead))->tqh_last))->tqh_last)); (rl_rule); (rl_rule) = (*(((struct _aclStruct *)(((rl_rule))->nextRule.tqe_prev))->tqh_last))) {

                        if (_rtl8651_sameAclRule(rl_rule, rule) == 1) {
                                rl_t->ref_count --;
                                do { if (((rl_rule)->nextRule.tqe_next) != ((void *)0)) (rl_rule)->nextRule.tqe_next->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_prev; else (&rl_t->netif_t->outRateLimitHead)->tqh_last = (rl_rule)->nextRule.tqe_prev; *(rl_rule)->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_next; (&rl_t->netif_t->outRateLimitHead)->tqh_count--;} while (0);
                                do { if (((rl_rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rl_rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rl_rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rl_rule); (rl_rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                                _rtl8651_arrangeAllACL();
                                return 0;
                        }
                }
        }
        else
        {

                for ((rl_rule) = (*(((struct _aclStruct *)(((&rl_t->netif_t->inRateLimitHead))->tqh_last))->tqh_last)); (rl_rule); (rl_rule) = (*(((struct _aclStruct *)(((rl_rule))->nextRule.tqe_prev))->tqh_last))) {

                        if (_rtl8651_sameAclRule(rl_rule, rule) == 1) {
                                rl_t->ref_count --;
                                do { if (((rl_rule)->nextRule.tqe_next) != ((void *)0)) (rl_rule)->nextRule.tqe_next->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_prev; else (&rl_t->netif_t->inRateLimitHead)->tqh_last = (rl_rule)->nextRule.tqe_prev; *(rl_rule)->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_next; (&rl_t->netif_t->inRateLimitHead)->tqh_count--;} while (0);
                                do { if (((rl_rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rl_rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rl_rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rl_rule); (rl_rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                                _rtl8651_arrangeAllACL();
                                return 0;
                        }
                }
        }
        return -3;
}






static int32 _rtl8651_addRateLimitGroup(uint32 *GroupId, int8 *ifName, uint32 rate, uint32 burst, int8 isByteCount, int32 ratio, int8 queueType)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_rateLimit_t *rl_t, *freeEntry_t;
        rtl865x_tblAsicDrv_rateLimitParam_t asic_rl;
        int32 entry;



        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0))
                return -7;
# 24826 "rtl8651_tblDrv.c"
        rl_t = DrvTbl.rateLimit;
        freeEntry_t = ((void *)0);
        for(entry=0; entry<32; entry++, rl_t++) {
                if (freeEntry_t == ((void *)0) && rl_t->groupId == 0) {
                        freeEntry_t = rl_t;
                        break;
                }
                if (rl_t->groupId == *GroupId) {


                        *GroupId = entry;
                        return 0;
                }

        }
        if (freeEntry_t == ((void *)0))
                return -9;


        if (RtkHomeGatewayChipName[strlen(RtkHomeGatewayChipName) - 1] == 'B' && RtkHomeGatewayChipRevisionID >= 0x02)
        {
# 24855 "rtl8651_tblDrv.c"
                freeEntry_t->queueType = queueType;
                freeEntry_t->groupId = *GroupId;

                if (ratio == 0)
                {

                        int i, val = 1, max = 0, remain;
                        for (i = 1; i <= 7; i++)
                        {
                                remain = (rate*i) % 10000;
                                remain = (remain > 5000) ? (remain - 5000) : (5000 - remain);

                                if (remain > max)
                                {
                                        max = remain;
                                        val = i;
                                }
                        }

                        freeEntry_t->addToken = ((rate*val)%10000) > 5000? (rate*val)/10000+1 : (rate*val)/10000;
                        freeEntry_t->interval = val;
                }
                else
                {
                        freeEntry_t->addToken = 0;
                        freeEntry_t->interval = 0x3f;
                }

                freeEntry_t->maxToken = (ratio == 0) ? (rate < 15360 ? 15360: rate) : 0;
                freeEntry_t->isByteCount = isByteCount;
                freeEntry_t->netif_t = netif_t;
                freeEntry_t->ref_count = 0;
                freeEntry_t->ratio = ratio;
        }

        else
        {
# 24922 "rtl8651_tblDrv.c"
                        freeEntry_t->queueType = queueType;
                        freeEntry_t->groupId = *GroupId;
                        freeEntry_t->addToken = (ratio == 0) ? ((rate * 5) / 3) : 0 ;
                        freeEntry_t->interval = (ratio == 0) ? 1: 0x3f;
                        freeEntry_t->maxToken = (ratio == 0) ? ((burst * 5) / 3) : 0 ;
                        freeEntry_t->isByteCount = isByteCount;
                        freeEntry_t->netif_t = netif_t;
                        freeEntry_t->ref_count = 0;
                        freeEntry_t->ratio = ratio;

        }


        bzero(&asic_rl, sizeof(rtl865x_tblAsicDrv_rateLimitParam_t));
        asic_rl.maxToken = freeEntry_t->maxToken;
        asic_rl.refill_number = freeEntry_t->addToken;
        asic_rl.t_intervalUnit = freeEntry_t->interval;
        asic_rl.t_remainUnit = freeEntry_t->interval;
        asic_rl.token = freeEntry_t->addToken;
        rtl8651_setAsicRateLimitTable((freeEntry_t - DrvTbl.rateLimit), &asic_rl);



        *GroupId = entry;

        return 0;
}

int32 _rtl8651_addRateLimitRule(rtl8651_tblDrvAclRule_t *rule, uint32 GroupId, uint8 isCounter)
{
        rtl8651_tblDrv_rateLimit_t *rl_t;
        _rtl8651_tblDrvAclRule_t *rl_rule;
        int32 retval=0, entry;



        if ( rule == ((void *)0) || !GroupId ||
            (rule->actionType_!=0x02 && rule->actionType_!=0x04))
                return -6;

        rl_t = DrvTbl.rateLimit;
        for(entry=0; entry<32; entry++, rl_t++)
                if (rl_t->groupId == GroupId)
                        break;
        if (entry == 32) {
                retval = -3403;
                goto out;
        }
        if ((rl_rule=((&DrvTbl.freeList.aclRule)->tqh_first)) == ((void *)0)) {
                retval = -9;
                goto out;
        }
        do { if (((rl_rule)->nextRule.tqe_next) != ((void *)0)) (rl_rule)->nextRule.tqe_next->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_prev; else (&DrvTbl.freeList.aclRule)->tqh_last = (rl_rule)->nextRule.tqe_prev; *(rl_rule)->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_count--;} while (0);
        bzero(rl_rule, sizeof(_rtl8651_tblDrvAclRule_t));
        rtl8651_memcpy(rl_rule, rule, sizeof(rtl8651_tblDrvAclRule_t));


        if (rule->isEgressRateLimitRule_)
        {
                do { (rl_rule)->nextRule.tqe_next = ((void *)0); (rl_rule)->nextRule.tqe_prev = (&rl_t->netif_t->outRateLimitHead)->tqh_last; *(&rl_t->netif_t->outRateLimitHead)->tqh_last = (rl_rule); (&rl_t->netif_t->outRateLimitHead)->tqh_last = &(rl_rule)->nextRule.tqe_next; (&rl_t->netif_t->outRateLimitHead)->tqh_count++;} while (0);
                rl_rule->isRateLimitCounter_ = (isCounter == 1)? 1: 0;
        }
        else
        {
                do { (rl_rule)->nextRule.tqe_next = ((void *)0); (rl_rule)->nextRule.tqe_prev = (&rl_t->netif_t->inRateLimitHead)->tqh_last; *(&rl_t->netif_t->inRateLimitHead)->tqh_last = (rl_rule); (&rl_t->netif_t->inRateLimitHead)->tqh_last = &(rl_rule)->nextRule.tqe_next; (&rl_t->netif_t->inRateLimitHead)->tqh_count++;} while (0);
        }

        rl_rule->rlIndex = (rl_t - DrvTbl.rateLimit);







        if (rule->actionType_ == 0x02) {
                if (rl_t->isByteCount == 1)
                        rl_rule->actionType_ = 0x0c;
                else rl_rule->actionType_ = 0x0a;
        }
        else {
                if (rl_t->isByteCount == 1)
                        rl_rule->actionType_ = 0x0d;
                else rl_rule->actionType_ = 0x0b;
        }
        rl_t->ref_count ++;
        _rtl8651_arrangeAllACL();

out:
        return retval;
}

int32 _rtl8651_flushRateLimitGroup(int8* ifName, uint8 flushCtrlGroup)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        _rtl8651_tblDrvAclRule_t *rl_rule;
        uint32 GroupId;
        int32 retval=0;

        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }

        while ((rl_rule=((&netif_t->inRateLimitHead)->tqh_first))) {
                GroupId = DrvTbl.rateLimit[rl_rule->rlIndex].groupId;





                if (flushCtrlGroup == 0 && GroupId < 100)
                        continue;

                _rtl8651_delRateLimitRule((rtl8651_tblDrvAclRule_t *)rl_rule, GroupId);
                _rtl8651_delRateLimitGroup(GroupId);
        }


        while ((rl_rule=((&netif_t->outRateLimitHead)->tqh_first))) {
                GroupId = DrvTbl.rateLimit[rl_rule->rlIndex].groupId;





                if (flushCtrlGroup == 0 && GroupId < 100)
                        continue;

                _rtl8651_delRateLimitRule((rtl8651_tblDrvAclRule_t *)rl_rule, GroupId);
                _rtl8651_delRateLimitGroup(GroupId);
        }

out:
        return retval;;
}


int32 rtl8651_addRateLimitGroup(uint32 GroupId, int8 *ifName, uint32 rate, uint32 burst, int8 isByteCount)
{
        int32 retval;

        if (ifName == ((void *)0) || GroupId < 100)
                return -6;
        rtlglue_drvMutexLock();
        retval = _rtl8651_addRateLimitGroup(&GroupId, ifName, rate, burst, isByteCount, 0, 0);
        rtlglue_drvMutexUnlock();
        return retval;
}

int32 rtl8651_delRateLimitGroup(uint32 GroupId)
{
        int32 retval;
        if (GroupId == 0)
                return -6;
        rtlglue_drvMutexLock();
        retval = _rtl8651_delRateLimitGroup(GroupId);
        rtlglue_drvMutexUnlock();
        return retval;
}


int32 rtl8651_addRateLimitRule(rtl8651_tblDrvAclRule_t *rule, uint32 GroupId)
{
        int32 retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_addRateLimitRule(rule, GroupId, 0);
        rtlglue_drvMutexUnlock();

        return retval;
}


int32 rtl8651_delRateLimitRule(rtl8651_tblDrvAclRule_t *rule, uint32 GroupId)
{
        int32 retval;
        if (rule == ((void *)0) || (rule->actionType_ != 0x02 && rule->actionType_!=0x04) || !GroupId)
                return -6;
        rtlglue_drvMutexLock();
        retval = _rtl8651_delRateLimitRule(rule, GroupId);
        rtlglue_drvMutexUnlock();
        return retval;
}


int32 rtl8651_flushRateLimitGroup(int8* ifName)
{
        int32 retval;
        rtlglue_drvMutexLock();
        retval = _rtl8651_flushRateLimitGroup(ifName, 0);
        rtlglue_drvMutexUnlock();
        return retval;;
}
# 25138 "rtl8651_tblDrv.c"
void printRateLine(char * dispString, uint32 rate) {
        if(rate > 125000)
                printk("\t%s is %3u.%03u Mbps\n", dispString, rate/125000, (rate%125000)/125);
        else if(rate > 125)
                printk("\t%s is %3u.%03u Kbps\n", dispString, rate/125, (rate%125));
        else
                printk("\t%s is     %3u  bps\n", dispString, rate);
}

void printRateString(uint32 rate) {
        if(rate > 125000)
                printk(" %3u.%03u Mbps ", rate/125000, (rate%125000)/125);
        else if(rate > 125)
                printk(" %3u.%03u Kbps ", rate/125, (rate%125));
        else
                printk("     %3u  bps ", rate);
}

void _rtl8651_mnQueueTimer(void)
{
        rtl865x_tblAsicDrv_rateLimitParam_t asic_rl, asic_rl1 = { 0, 0, 0x3F, 0x3F, 0};
        rtl8651_tblDrv_rateLimit_t *rl_t;
        uint32 entry;



        static uint32 updateState = 0;

        uint32 mVRate,
                        nAvailableRate,
                        nConsumedRate,
                        nRatioSummary,
                        nConsumedRatio,
                        nQueueNeedProcessedNumber;

        if (mnQ_enable == 0)
                return;


        for(entry=0, rl_t = DrvTbl.rateLimit; entry<32; entry++, rl_t++) {
                if (rl_t->queueType) {
                        rtl8651_getAsicRateLimitTable(entry, &asic_rl);
                        if(rl_t->lastConfigToken < 1518 || asic_rl.token < 1518)
                                rl_t->eagerCounter = 1<<(7 +3);
                        else
                                rl_t->eagerCounter = ((rl_t->eagerCounter<<7) - rl_t->eagerCounter) >> 7;
                        if(rl_t->lastConfigToken > 0xFFFFFF)
                                asic_rl.token += (rl_t->lastConfigToken - 0xFFFFFF);
                        else if(rl_t->lastConfigToken < asic_rl.token) {





                                asic_rl.token = rl_t->lastConfigToken;
                        }

                        rl_t->accumulatedToken += (rl_t->lastConfigToken -asic_rl.token);

                        rl_t->lastConfigToken = asic_rl.token + rl_t->sliceIncrementToken;
                        if(updateState==0)
                                rl_t->lastConfigToken += (rl_t->rateMappedToken%100);
                        if(rl_t->lastConfigToken > rl_t->maxToken)
                                rl_t->lastConfigToken = rl_t->maxToken;

                        if(rl_t->lastConfigToken > 0xFFFFFF) {
                                asic_rl1.maxToken = 0xFFFFFF;
                                asic_rl1.token = 0xFFFFFF;
                        } else {
                                asic_rl1.maxToken = rl_t->lastConfigToken;
                                asic_rl1.token = rl_t->lastConfigToken;
                        }
                        rtl8651_setAsicRateLimitTable(entry, &asic_rl1);
# 25221 "rtl8651_tblDrv.c"
                }
        }

        if(++updateState >= 100) {

                mnqueue_ctrl.mVRate = mnqueue_ctrl.mEVRate = mnqueue_ctrl.nVRate = 0;
                mnqueue_ctrl.eagerNQueueNumber = 0;
                nRatioSummary = nQueueNeedProcessedNumber = 0;
                for(entry=0, rl_t = DrvTbl.rateLimit; entry<32; entry++, rl_t++) {

                        if (rl_t->queueType) {
                                rl_t->vRate = (((rl_t->vRate << 3) - rl_t->vRate)>>3) + (rl_t->accumulatedToken>>3);






                        }

                        if (rl_t->queueType== 1) {
                                mnqueue_ctrl.mVRate += rl_t->vRate;
                                mnqueue_ctrl.mEVRate += rl_t->rateMappedToken;
                        }
                        else if (rl_t->queueType == 2 || rl_t->queueType == 3) {
                                mnqueue_ctrl.nVRate += rl_t->vRate;
                                if(rl_t->eagerCounter)
                                        mnqueue_ctrl.eagerNQueueNumber++;
                                rl_t->nQueueNeedProcess = 1;
                                nRatioSummary += rl_t->ratio;
                                nQueueNeedProcessedNumber++;
                        }
                        rl_t->accumulatedToken = 0;
                }

                mVRate = mnqueue_ctrl.mVRate + (mnqueue_ctrl.mVRate>>2);
                mVRate = (mVRate > mnqueue_ctrl.mEVRate)? mnqueue_ctrl.mEVRate: mVRate;
                nAvailableRate = mnqueue_ctrl.wanBandwidth > mVRate?mnqueue_ctrl.wanBandwidth - mVRate: 0;
                mnqueue_ctrl.nAvailableRate = nAvailableRate;


                for(entry=0, rl_t = DrvTbl.rateLimit; entry<32; entry++, rl_t++)
                        if (rl_t->queueType == 2 || rl_t->queueType == 3) {
                                rl_t->rateMappedToken = nAvailableRate * rl_t->ratio / nRatioSummary;
                                if(rl_t->eagerCounter == 0 && rl_t->vRate > rl_t->rateMappedToken) {
                                        rl_t->eagerCounter = 1<<7;
                                        mnqueue_ctrl.eagerNQueueNumber++;
                                }
                        }


                if(mnqueue_ctrl.eagerNQueueNumber >0 && mnqueue_ctrl.eagerNQueueNumber <= mnqueue_ctrl.nQueueNumber) {
                        nConsumedRate = nConsumedRatio = 0;
                        for(entry=0, rl_t = DrvTbl.rateLimit; entry<32; entry++, rl_t++)
                                if (rl_t->eagerCounter == 0 && (rl_t->queueType == 2 || rl_t->queueType == 3)) {
                                        if(rl_t->vRate + (rl_t->vRate>>4) < rl_t->rateMappedToken)
                                                rl_t->rateMappedToken = rl_t->vRate + (rl_t->vRate>>4);
                                        if(rl_t->rateMappedToken < 200)
                                                rl_t->rateMappedToken = 200;
                                        rl_t->maxToken = rl_t->rateMappedToken > 15360? rl_t->rateMappedToken : 15360;
                                        nConsumedRate += rl_t->rateMappedToken;
                                        nConsumedRatio += rl_t->ratio;
                                        rl_t->nQueueNeedProcess = 0;
                                        rl_t->sliceIncrementToken = rl_t->rateMappedToken /100;
                                }
                        nAvailableRate = (nAvailableRate>nConsumedRate)?(nAvailableRate-nConsumedRate):0;
                        nRatioSummary -= nConsumedRatio;
                }

                if (nRatioSummary)
                        for(entry=0, rl_t = DrvTbl.rateLimit; entry<32; entry++, rl_t++) {
                                if (rl_t->nQueueNeedProcess == 1 && (rl_t->queueType == 2 || rl_t->queueType == 3)) {
                                        rl_t->rateMappedToken = nAvailableRate * rl_t->ratio / nRatioSummary;
                                        if(rl_t->rateMappedToken < 200)
                                                rl_t->rateMappedToken = 200;
                                        rl_t->maxToken = rl_t->rateMappedToken > 15360? rl_t->rateMappedToken : 15360;
                                        rl_t->nQueueNeedProcess = 0;
                                        rl_t->sliceIncrementToken = rl_t->rateMappedToken /100;
                                }
                        }
                updateState = 0;
        }
}

void _rtl8651_mnQueue_init(void) {
        rtl8651_tblDrv_rateLimit_t *rl_t;
        uint32 entry, mRatioSummary, nRatioSummary;

        mnqueue_ctrl.nQueueNumber = 0;
        for(entry=0, rl_t = DrvTbl.rateLimit, mRatioSummary = nRatioSummary = 0; entry<32; entry++, rl_t++) {
                if (rl_t->queueType == 1)
                        mRatioSummary += rl_t->ratio;
                else if (rl_t->queueType == 2 || rl_t->queueType == 3) {
                        nRatioSummary += rl_t->ratio;
                        mnqueue_ctrl.nQueueNumber++;
                }
                rl_t->vRate = rl_t->accumulatedToken = rl_t->eagerCounter = 0;
        }
        for(entry=0, rl_t = DrvTbl.rateLimit; entry<32; entry++, rl_t++) {
                if (rl_t->queueType == 1) {
                        rl_t->rateMappedToken = rl_t->ratio * mnqueue_ctrl.wanBandwidth / 100;
                        rl_t->maxToken = rl_t->rateMappedToken > 15360? rl_t->rateMappedToken : 15360;
                } else if (rl_t->queueType == 2 || rl_t->queueType == 3) {
                        rl_t->rateMappedToken = (100 - mRatioSummary)*mnqueue_ctrl.wanBandwidth/100 * rl_t->ratio/nRatioSummary;
                        rl_t->maxToken = rl_t->rateMappedToken > 15360? rl_t->rateMappedToken : 15360;
                }
                rl_t->sliceIncrementToken = rl_t->rateMappedToken /100;
        }

}

void rtl8651_dumpMNQueueSystemInfo(void) {
        rtl8651_tblDrv_rateLimit_t *rl_t;
        uint32 entry;
        printk("MNQueue System information:\n");
        printk("\tWAN bandwidth %u ", mnqueue_ctrl.wanBandwidth);
        if(mnqueue_ctrl.wanBandwidth > 125000)
                printk("(%3u.%03u Mbps)", mnqueue_ctrl.wanBandwidth/125000, (mnqueue_ctrl.wanBandwidth%125000)/125);
        else if(mnqueue_ctrl.wanBandwidth > 125)
                printk("(%3u.%03u Kbps", mnqueue_ctrl.wanBandwidth/125, (mnqueue_ctrl.wanBandwidth%125));
        else
                printk("(%3u      bps)", mnqueue_ctrl.wanBandwidth);
        printk("\n\tM queue rate %u ", mnqueue_ctrl.mVRate);
        if(mnqueue_ctrl.mVRate > 125000)
                printk("(%3u.%03u Mbps)", mnqueue_ctrl.mVRate/125000, (mnqueue_ctrl.mVRate%125000)/125);
        else if(mnqueue_ctrl.mVRate > 125)
                printk("(%3u.%03u Kbps", mnqueue_ctrl.mVRate/125, (mnqueue_ctrl.mVRate%125));
        else
                printk("(%3u      bps)", mnqueue_ctrl.mVRate);
        printk("\n\tM queue expect rate %u ", mnqueue_ctrl.mEVRate);
        if(mnqueue_ctrl.mEVRate > 125000)
                printk("(%3u.%03u Mbps)", mnqueue_ctrl.mEVRate/125000, (mnqueue_ctrl.mEVRate%125000)/125);
        else if(mnqueue_ctrl.mEVRate > 125)
                printk("(%3u.%03u Kbps", mnqueue_ctrl.mEVRate/125, (mnqueue_ctrl.mEVRate%125));
        else
                printk("(%3u      bps)", mnqueue_ctrl.mEVRate);
        printk("\n\tN queue rate %u ", mnqueue_ctrl.nVRate);
        if(mnqueue_ctrl.nVRate > 125000)
                printk("(%3u.%03u Mbps)", mnqueue_ctrl.nVRate/125000, (mnqueue_ctrl.nVRate%125000)/125);
        else if(mnqueue_ctrl.nVRate > 125)
                printk("(%3u.%03u Kbps", mnqueue_ctrl.nVRate/125, (mnqueue_ctrl.nVRate%125));
        else
                printk("(%3u      bps)", mnqueue_ctrl.nVRate);
        printk("\n\tN queue available bandwidth %u ", mnqueue_ctrl.nAvailableRate);
        if(mnqueue_ctrl.nAvailableRate > 125000)
                printk("(%3u.%03u Mbps)", mnqueue_ctrl.nAvailableRate/125000, (mnqueue_ctrl.nAvailableRate%125000)/125);
        else if(mnqueue_ctrl.nAvailableRate > 125)
                printk("(%3u.%03u Kbps", mnqueue_ctrl.nAvailableRate/125, (mnqueue_ctrl.nAvailableRate%125));
        else
                printk("(%3u      bps)", mnqueue_ctrl.nAvailableRate);
        printk("\n");
        printk("Eager queue number %u total N queue number %u\n", mnqueue_ctrl.eagerNQueueNumber, mnqueue_ctrl.nQueueNumber);
        for(entry=0, rl_t = DrvTbl.rateLimit; entry<32; entry++, rl_t++)
                if (rl_t->queueType) {
                        printk("Group %u maxToken %u, rateMappedToken %u, vRate %u\n", entry, rl_t->maxToken, rl_t->rateMappedToken, rl_t->vRate);
                        printk("\tlastConfigToken %u, sliceIncrementToken %u\n", rl_t->lastConfigToken, rl_t->sliceIncrementToken);
                        printk("\taccumulatedToken %u, groupId %u, queueType %u\n", rl_t->accumulatedToken, rl_t->groupId, rl_t->queueType);
                        printk("\tref_count %u, ratio %u, eagerCounter %u\n", rl_t->ref_count, rl_t->ratio, rl_t->eagerCounter);
                        if(rl_t->vRate > 125000)
                                printk("\tvirtual rate is %3u.%03u Mbps ", rl_t->vRate/125000, (rl_t->vRate%125000)/125);
                        else if(rl_t->vRate > 125)
                                printk("\tvirtual rate is %3u.%03u Kbps ", rl_t->vRate/125, (rl_t->vRate%125));
                        else
                                printk("\tvirtual rate is %3u      bps ", rl_t->vRate);
                        if(rl_t->rateMappedToken > 125000)
                                printk("Allowed rate is %3u.%03u Mbps\n", rl_t->rateMappedToken/125000, (rl_t->rateMappedToken%125000)/125);
                        else if(rl_t->rateMappedToken > 125)
                                printk("Allowed rate is %3u.%03u Kbps\n", rl_t->rateMappedToken/125, (rl_t->rateMappedToken%125));
                        else
                                printk("Allowed rate is %3u      bps\n", rl_t->rateMappedToken);
                }

}

static void _rtl8651_flushMNQueue(void) {
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        _rtl8651_tblDrvAclRule_t *rl_rule;
        int32 entry;

        netif_t = DrvTbl.netIface;
        for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                if (netif_t->valid == 0)
                        continue;
                while( (rl_rule = ((&netif_t->mnqHead)->tqh_first)) ) {
                        DrvTbl.rateLimit[rl_rule->rlIndex].groupId = 0;
                        rtl8651_delAsicRateLimitTable(rl_rule->rlIndex);
                        DrvTbl.rateLimit[rl_rule->rlIndex].ratio = 0;
                        do { if (((rl_rule)->nextRule.tqe_next) != ((void *)0)) (rl_rule)->nextRule.tqe_next->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_prev; else (&netif_t->mnqHead)->tqh_last = (rl_rule)->nextRule.tqe_prev; *(rl_rule)->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_next; (&netif_t->mnqHead)->tqh_count--;} while (0);
                        do { if (((rl_rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rl_rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rl_rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rl_rule); (rl_rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                }
        }
        _rtl8651_arrangeAllACL();
}


static int32 _rtl8651_delFlowFromMNQueue(rtl8651_tblDrvAclRule_t *rule, uint32 GroupId)
{
        _rtl8651_tblDrvAclRule_t *rl_rule;
        rtl8651_tblDrv_rateLimit_t *rl_t;
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;};
        int32 entry;


        rl_t = DrvTbl.rateLimit;

        for(entry=0; entry<32; entry++, rl_t++)
                if (rl_t->groupId == GroupId)
                        break;
        if (entry == 32)
                return -3403;
        if (rule->actionType_ == 0x02) {
                if (rl_t->isByteCount == 1)
                        rule->actionType_ = 0x0c;
                else rule->actionType_ = 0x0a;
        }
        else {
                if (rl_t->isByteCount == 1)
                        rule->actionType_ = 0x0d;
                else rule->actionType_ = 0x0b;
        }



        for ((rl_rule) = (*(((struct _aclStruct *)(((&rl_t->netif_t->mnqHead))->tqh_last))->tqh_last)); (rl_rule); (rl_rule) = (*(((struct _aclStruct *)(((rl_rule))->nextRule.tqe_prev))->tqh_last))) {
                if (_rtl8651_sameAclRule(rl_rule, rule) == 1) {
                        rl_t->ref_count --;
                        do { if (((rl_rule)->nextRule.tqe_next) != ((void *)0)) (rl_rule)->nextRule.tqe_next->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_prev; else (&rl_t->netif_t->mnqHead)->tqh_last = (rl_rule)->nextRule.tqe_prev; *(rl_rule)->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_next; (&rl_t->netif_t->mnqHead)->tqh_count--;} while (0);
                        do { if (((rl_rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rl_rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rl_rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rl_rule); (rl_rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                        _rtl8651_arrangeAllACL();

                        if (rl_t->ref_count == 0) {
                                rl_t->groupId = 0;
                                rl_t->queueType = 0;
                                rtl8651_delAsicRateLimitTable(entry);
                        }
                        return 0;
                }
        }

        _rtl8651_mnQueue_init();

        return -3;
}


static int32 _rtl8651_addFlowToMNQueue(int8 *ifName, rtl8651_tblDrvAclRule_t *rule, uint32 ratio, uint32 qidx, int8 isMqueue)
{
        rtl8651_tblDrv_rateLimit_t *default_rl_t = &DrvTbl.rateLimit[32 -1], *rl_t;
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        _rtl8651_tblDrvAclRule_t *rl_rule;
        int32 retval=0;
        uint32 flowRatio, queueType;
        uint32 entry, mRatioSummary;


        if (rule == ((void *)0))
                return 0;


        if (default_rl_t->queueType!= 3)
                return -6;
        if (rule->actionType_!=0x02 && rule->actionType_!=0x04)
                return -6;
        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0))
                return -7;


        if ((rl_rule=((&DrvTbl.freeList.aclRule)->tqh_first)) == ((void *)0))
                return -9;

        if(isMqueue == 1) {
                for(entry=0, rl_t = DrvTbl.rateLimit, mRatioSummary = 0; entry<32; entry++, rl_t++) {
                        if (rl_t->queueType == 1)
                                mRatioSummary += rl_t->ratio;
                }
                if(mRatioSummary + ratio > 100)
                {
                        return -6;
                }
        }
        flowRatio = (isMqueue==1) ?(ratio * mnqueue_ctrl.wanBandwidth / 100) : 0;

        queueType = (isMqueue==1)? 1: 2;

        if ((retval=_rtl8651_addRateLimitGroup(&qidx, ifName, flowRatio, flowRatio, 1, ratio, queueType)) != 0)
                return retval;

        do { if (((rl_rule)->nextRule.tqe_next) != ((void *)0)) (rl_rule)->nextRule.tqe_next->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_prev; else (&DrvTbl.freeList.aclRule)->tqh_last = (rl_rule)->nextRule.tqe_prev; *(rl_rule)->nextRule.tqe_prev = (rl_rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_count--;} while (0);
        bzero(rl_rule, sizeof(_rtl8651_tblDrvAclRule_t));
        rtl8651_memcpy(rl_rule, rule, sizeof(rtl8651_tblDrvAclRule_t));
        do { (rl_rule)->nextRule.tqe_next = ((void *)0); (rl_rule)->nextRule.tqe_prev = (&netif_t->mnqHead)->tqh_last; *(&netif_t->mnqHead)->tqh_last = (rl_rule); (&netif_t->mnqHead)->tqh_last = &(rl_rule)->nextRule.tqe_next; (&netif_t->mnqHead)->tqh_count++;} while (0);
        if (rule->actionType_ == 0x02)
                rl_rule->actionType_ = 0x0c;
        else rl_rule->actionType_ = 0x0d;
        rl_rule->rlIndex = qidx;
        if (isMqueue == 1)
                rl_rule->priority_ = 1;
        mnQ_enable = 1;


        rl_t = &DrvTbl.rateLimit[qidx];


        rl_t->ref_count++;
        rl_t->mark = 0;

        _rtl8651_mnQueue_init();


        _rtl8651_arrangeAllACL();

        return 0;
}

int32 rtl8651_addFlowToUnlimitedQueue(int8 *ifName, rtl8651_tblDrvAclRule_t *rule, uint32 ratio, uint32 queueID)
{
        int32 retval;

        if (ifName == ((void *)0) || ratio == 0 || ratio > 100 || queueID < 100)
                return -6;
        rtlglue_drvMutexLock();
        retval = _rtl8651_addFlowToMNQueue(ifName, rule, ratio, queueID, 1);
        rtlglue_drvMutexUnlock();
        return retval;
}



int32 rtl8651_addFlowToLimitedQueue(int8 *ifName, rtl8651_tblDrvAclRule_t *rule, uint32 ratio, uint32 queueID)
{
        int32 retval;

        if (ifName == ((void *)0) || ratio == 0 || ratio > 100 || queueID < 100)
                return -6;
        rtlglue_drvMutexLock();
        retval = _rtl8651_addFlowToMNQueue(ifName, rule, ratio, queueID, 0);
        rtlglue_drvMutexUnlock();

        return retval;
}

int32 rtl8651_delFlowFromMNQueue(rtl8651_tblDrvAclRule_t *rule, uint32 GroupId)
{
        int32 retval;
        if (rule == ((void *)0) || (rule->actionType_ != 0x02 && rule->actionType_!=0x04) || !GroupId)
                return -6;
        rtlglue_drvMutexLock();
        retval = _rtl8651_delFlowFromMNQueue(rule, GroupId);
        rtlglue_drvMutexUnlock();
        return retval;
}

int32 rtl8651_getMNQueueEntry(rtl8651_tblDrvAclRule_t *rule,uint32 GroupId,uint32 index)
{
        rtl8651_tblDrv_rateLimit_t *rl_t;
        int32 entry;


        for(entry=0, rl_t=DrvTbl.rateLimit; entry<32; entry++, rl_t++) {
                if (rl_t->groupId == GroupId) {

                        _rtl8651_tblDrvAclRule_t asic_acl;
                        rtl865x_tblAsicDrv_vlanParam_t asic_vlan;
                        uint32 start, end,match_idx=0;
                        uint16 vid;


                        memset(rule,0,sizeof(*rule));

                        for(vid=0; vid<4095; vid++ )
                        {

                                if (rtl8651_getAsicVlan(vid, &asic_vlan) == -1)
                                        continue;

                                if(!asic_vlan.internal) continue;


                                start = asic_vlan.inAclStart; end = asic_vlan.inAclEnd;
                                for( ; start<=end; start++)
                                {
                                        if (rtl8651_getAsicAclRule(start, &asic_acl) == -1)
                                        do {} while (0);

                                        if(asic_acl.actionType_!=12) continue;

                                        if(entry!=asic_acl.rlIndex) continue;

                                        if(match_idx==index)
                                        {
                                                memcpy((void*)rule,(void*)&asic_acl,sizeof(*rule));
                                                return 0;
                                        }
                                        match_idx++;
                                }
                        }
                }
        }
        return -3;

}



int32 rtl8651_setUpstreamBandwidth(int8 *ifName, uint32 bps)
{
        rtl8651_tblDrv_rateLimit_t *default_rl_t = &DrvTbl.rateLimit[32 -1];
        rtl865x_tblAsicDrv_rateLimitParam_t asic_rl = { 0, 0, 0x3f, 0x3f, 0 };
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        int32 retval=0;






        if (bps > (100 * 1000*1000) )
                return -6;
        rtlglue_drvMutexLock();

        if ((netif_t=GET_NETWORK_INTERFACE(ifName, ((void *)0))) == ((void *)0)) {
                retval = -7;
                goto out;
        }

        if (bps == 0) {
                mnQ_enable = 0;
                default_rl_t->groupId = 0;
                _rtl8651_flushMNQueue();
                goto out;
        }

        mnqueue_ctrl.wanBandwidth = (bps >> 3);


        if (default_rl_t->queueType!= 0 && default_rl_t->queueType!= 3) {
                retval = -6;
                goto out;
        }
        if (default_rl_t->queueType== 0) {
                bzero(default_rl_t, sizeof(rtl8651_tblDrv_rateLimit_t));
                default_rl_t->queueType= 3;
                rtl8651_setAsicRateLimitTable(32 -1, &asic_rl);
        }
        default_rl_t->ratio = 1;

        _rtl8651_mnQueue_init();

        mnQ_enable = 1;
        rtl8651_setAsicHLQueueWeight(0x03);
        _rtl8651_arrangeAllACL();

out:
        rtlglue_drvMutexUnlock();
        return retval;
}
# 25685 "rtl8651_tblDrv.c"
int32 rtl8651_setDscpToMNQueue(uint32 queueID, uint32 queueDSCP)
{
        rtl8651_tblDrv_rateLimit_t *rl_t;
        uint32 entry;

        rtlglue_drvMutexLock();

        for(entry=0, rl_t=DrvTbl.rateLimit; entry<32; entry++, rl_t++) {
                if (rl_t->groupId == queueID) {
                        rl_t->dscp = (uint16) queueDSCP;
                        rl_t->mark = 1;


                        _rtl8651_arrangeAllACL();

                        rtlglue_drvMutexUnlock();
                        return 0;
                }
        }

        rtlglue_drvMutexUnlock();
        return -1;
}
# 25717 "rtl8651_tblDrv.c"
int _rtl8651_markDiffservPkt(_rtl8651_tblDrvAclRule_t *rule, struct ip *pip)
{
        uint8 dscp = DrvTbl.rateLimit[rule->rlIndex].dscp;
        uint8 oldTos;

        oldTos = pip->ip_tos;
        pip->ip_tos = dscp;
        do { int32 accumulate; accumulate = ((oldTos) - (dscp)); do { accumulate += ((pip->ip_sum)); if (accumulate < 0) { accumulate = -accumulate; accumulate = (accumulate >> 16) + (accumulate & 0xffff); accumulate += accumulate >> 16; (pip->ip_sum) = ((uint16) ~accumulate); } else { accumulate = (accumulate >> 16) + (accumulate & 0xffff); accumulate += accumulate >> 16; (pip->ip_sum) = ((uint16) accumulate); } } while (0); } while(0);

        return 0;
}
# 25736 "rtl8651_tblDrv.c"
_rtl8651_tblDrvAclRule_t * _rtl8651_matchDiffservACL(uint32 dsid, struct ip *iphdr)
{
        struct _aclStruct { struct _rtl8651_tblDrvAclRule_s *tqh_first; struct _rtl8651_tblDrvAclRule_s **tqh_last; int tqh_count;} *aclHead;
        struct tcphdr *tcphdr;
        _rtl8651_tblDrvAclRule_t *rule;
        ipaddr_t ip_s, ip_d;




       if (iphdr == (struct ip *)((void *)0) || iphdr->ip_p != 6 || (((uint16)(iphdr->ip_off)) & (0x1fff|0x2000)))
                return (_rtl8651_tblDrvAclRule_t *)((void *)0);

        ip_s = ((uint32) (*((uint8*)(&iphdr->ip_src))<<24)|(*(((uint8*)(&iphdr->ip_src))+1)<<16)|(*(((uint8*)(&iphdr->ip_src))+2)<<8) | *(((uint8*)(&iphdr->ip_src))+3));
        ip_d = ((uint32) (*((uint8*)(&iphdr->ip_dst))<<24)|(*(((uint8*)(&iphdr->ip_dst))+1)<<16)|(*(((uint8*)(&iphdr->ip_dst))+2)<<8) | *(((uint8*)(&iphdr->ip_dst))+3));



        tcphdr = (struct tcphdr *)((uint8 *)iphdr + ((iphdr->ip_vhl & 0x0f)<<2));
# 25765 "rtl8651_tblDrv.c"
        aclHead = (struct _aclStruct *)&DrvTbl.netIface->mnqHead;

        for (rule = ((aclHead)->tqh_first); rule; rule = ((rule)->nextRule.tqe_next)) {
                int ruleno = 0;


                if (DrvTbl.rateLimit[rule->rlIndex].mark != 1)
                        break;

                ruleno++;



                 if (((tcphdr->th_flags & rule->un_ty.L3L4.is.tcp._flagMask) != rule->un_ty.L3L4.is.tcp.un._flag) ||
                         !((tcphdr->th_sport)>=rule->un_ty.L3L4.is.tcp._srcPortLowerBound && (tcphdr->th_sport) <= rule->un_ty.L3L4.is.tcp._srcPortUpperBound) ||
                         !((tcphdr->th_dport)>=rule->un_ty.L3L4.is.tcp._dstPortLowerBound && (tcphdr->th_dport) <= rule->un_ty.L3L4.is.tcp._dstPortUpperBound) )
                                break;



                if (((iphdr->ip_tos & rule->un_ty.L3L4._tosMask) == rule->un_ty.L3L4._tos) && (rule->dsid==dsid)) {
                        if (rule->isIPRange_ == 1) {

                                if ((rule->un_ty.L3L4._srcIpAddr==0 && rule->un_ty.L3L4._srcIpAddrMask==0) ||
                                    (rule->un_ty.L3L4._srcIpAddr<=ip_s && rule->un_ty.L3L4._srcIpAddrMask>=ip_s)) {
                                        if ((rule->un_ty.L3L4._dstIpAddr==0 && rule->un_ty.L3L4._dstIpAddrMask==0) ||
                                            (rule->un_ty.L3L4._dstIpAddr<=ip_d && rule->un_ty.L3L4._dstIpAddrMask>=ip_d))
                                                return (_rtl8651_tblDrvAclRule_t *)rule;
                                }
                        }
                        else {
                                if ((( ip_s & rule->un_ty.L3L4._srcIpAddrMask) == rule->un_ty.L3L4._srcIpAddr) && ((ip_d & rule->un_ty.L3L4._dstIpAddrMask) == rule->un_ty.L3L4._dstIpAddr) )
                                        return (_rtl8651_tblDrvAclRule_t *)rule;
                        }
                }
        }



        return (_rtl8651_tblDrvAclRule_t *)((void *)0);
}
# 25823 "rtl8651_tblDrv.c"
int32 _rtl8651_addRateLimitCounter(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType)
{
        rtl8651_tblDrv_rateLimitCounter_t *freeEntry=((void *)0);
        uint32 index, GroupId, input;
        int32 retval;






        for ( index=0;index<10;index++ )
        {
                if ( !rateLimitCounterRegisterTable[index].valid )
                {
                        if ( freeEntry==((void *)0) )
                                freeEntry = &rateLimitCounterRegisterTable[index];
                        continue;
                }
                if ( rateLimitCounterRegisterTable[index].netif_t==netif_t &&
                     rateLimitCounterRegisterTable[index].counterType==counterType )
                {
                        return 0;
                }
        }
        if ( freeEntry==((void *)0) )
                return -9;

        input = GroupId = (freeEntry - &rateLimitCounterRegisterTable[0])+11;





        if ( (retval =_rtl8651_addRateLimitGroup(&input, netif_t->ifName, 0xffffff, 0, 0, 0, 0 ))
                == 0 )
        {




                do {} while (0);
                freeEntry->valid = 1;
                freeEntry->netif_t = netif_t;
                freeEntry->rateLimitIndex= input;
                freeEntry->counterType = counterType;


                retval = _rtl8651_getRateLimitCounter(netif_t, counterType, 1);

                return 0;
        }





        return retval;
}




int32 _rtl8651_addRateLimitCounterRule(rtl8651_tblDrvAclRule_t *rule, rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType)
{
        rtl8651_tblDrv_rateLimitCounter_t *entry = &rateLimitCounterRegisterTable[0];
        uint32 index;

        rule->isEgressRateLimitRule_ = 1;

        for ( index=0;index<10;index++,entry++ )
        {
                if ( entry->valid && entry->netif_t==netif_t && entry->counterType==counterType )
                {



                        return _rtl8651_addRateLimitRule(rule, index+11, 1);
                }
        }
        return -3;
}




int32 _rtl8651_delRateLimitCounterRule(rtl8651_tblDrvAclRule_t *rule, rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType)
{
        rtl8651_tblDrv_rateLimitCounter_t *entry = &rateLimitCounterRegisterTable[0];
        uint32 index;
        int32 retval;

        rule->isEgressRateLimitRule_ = 1;

        for ( index=0;index<10;index++,entry++ )
        {
                if ( entry->valid && entry->netif_t==netif_t && entry->counterType==counterType )
                {




                        retval = _rtl8651_delRateLimitRule(rule, index+11);

                        do {} while (0);




                        if (DrvTbl.rateLimit[entry->rateLimitIndex].ref_count == 0)
                        {




                                retval = _rtl8651_delRateLimitGroup(index+11);

                                do {} while (0);





                                memset(entry, 0, sizeof(rtl8651_tblDrv_rateLimitCounter_t));
                        }
                        return retval;
                }
        }
        return -3;
}





int32 _rtl8651_delRateLimitCounter(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType)
{
        rtl8651_tblDrv_rateLimitCounter_t *entry = &rateLimitCounterRegisterTable[0];
        uint32 index;
        int32 retval = -3;





        for ( index=0;index<10;index++,entry++ )
        {
                if ( entry->valid && entry->netif_t==netif_t && entry->counterType==counterType )
                {
                        _rtl8651_tblDrvAclRule_t *acl_t, *next_acl_t;






                        acl_t = ((&entry->netif_t->outRateLimitHead)->tqh_first);
                        while(acl_t) {

                                next_acl_t = ((acl_t)->nextRule.tqe_next);

                                if (acl_t->isRateLimitCounter_ &&
                                     acl_t->rlIndex == entry->rateLimitIndex) {




                                        retval = _rtl8651_delRateLimitRule((rtl8651_tblDrvAclRule_t *)acl_t, index+11);
                                        do {} while (0);



                                }

                                acl_t = next_acl_t;
                        }





                        retval = _rtl8651_delRateLimitGroup(index+11);
                        do {} while (0);





                        memset(entry, 0, sizeof(rtl8651_tblDrv_rateLimitCounter_t));

                        break;
                }
        }
        return retval;
}





int32 _rtl8651_getRateLimitCounter(rtl8651_tblDrv_networkIntfTable_t *netif_t, uint8 counterType, uint8 refill)
{
        rtl8651_tblDrv_rateLimitCounter_t *entry = &rateLimitCounterRegisterTable[0];
        rtl865x_tblAsicDrv_rateLimitParam_t asic_rl;
        uint32 index;
        uint32 counter = 0;

        for ( index=0;index<10;index++,entry++ )
        {
                if ( entry->valid && entry->netif_t==netif_t && entry->counterType==counterType )
                        break;
        }
        if ( index == 10 )
                goto fail;


        if (rtl8651_getAsicRateLimitTable(entry->rateLimitIndex, &asic_rl)==0)
        {
                counter = 0xffffff - asic_rl.token;




                if ( refill )
                {
                        asic_rl.token = 0xffffff;
                        asic_rl.maxToken = 0xffffff;
                        asic_rl.refill_number = 0;
# 26062 "rtl8651_tblDrv.c"
                        rtl8651_setAsicRateLimitTable(entry->rateLimitIndex, &asic_rl);
                }
        }
fail:
        return counter;
}






void _rtl8651_rateLimitCounterTimeUpdate(uint32 secpassed)
{
        rtl8651_tblDrv_rateLimitCounter_t *entry = &rateLimitCounterRegisterTable[0];
        uint32 index;

        for ( index=0;index<10;index++,entry++ )
        {
                if ( entry->valid )
                {
                        if ( !entry->netif_t->valid ) {
                                do {} while (0);
                                goto remove;
                        }
                        if ( _rtl8651_getRateLimitCounter(entry->netif_t, entry->counterType, 0) >=
                             (0xffffff - 0xfffff) )
                        {



remove:
                                _rtl8651_delRateLimitCounter(entry->netif_t, entry->counterType);
                        }
                }
        }
}

void _rtl8651_flushRateLimitCounter(void)
{
        rtl8651_tblDrv_rateLimitCounter_t *entry = &rateLimitCounterRegisterTable[0];
        uint32 index;

        for ( index=0;index<10;index++,entry++ )
        {
                if ( entry->valid )
                {
                        _rtl8651_delRateLimitCounter(entry->netif_t, entry->counterType);
                }
        }
}







static uint32 _l2Reserved_;

static int32 _rtl8651_init_nexthopEntry(uint32 entryIndex)
{
        ether_addr_t mac = { {0x00, 0x00, 0x0a, 0x00, 0x00, 0x0f} };
        rtl865x_tblAsicDrv_nextHopParam_t asic;
        rtl865x_tblAsicDrv_l2Param_t l2_asic;
        int32 retval;







        if (entryIndex >= 32)
                return -1;

        _l2Reserved_ = rtl8651_filterDbIndex(&mac);
        memset((void *)&l2_asic, 0, sizeof(rtl865x_tblAsicDrv_l2Param_t));
        memcpy((void *)&l2_asic.macAddr, (void *)&mac, 6);
        l2_asic.cpu = 1;
        l2_asic.isStatic = 1;
        l2_asic.ageSec = 500;
        if ((retval = rtl8651_setAsicL2Table(_l2Reserved_, 0, &l2_asic)) != 0)
                return retval;

        memset((void *)&asic, 0, sizeof(rtl865x_tblAsicDrv_nextHopParam_t));
        asic.nextHopColumn = 0;
        asic.nextHopRow = _l2Reserved_;
        retval = rtl8651_setAsicNextHopTable(entryIndex, &asic);
        return retval;
}



static void
_rtl8651_updateNextHop_NHIDX(rtl8651_tblDrv_arpEntry_t *arp_t, rtl8651_tblDrv_pppTable_t *session_t)
{
        rtl8651_tblDrv_nextHopEntry_t *entry_t;







        do {} while (0);
        do {} while (0);







        if (arp_t) {
                for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next) {
                        if (entry_t->nextHopType != 0x01)
                                continue;
                        if (!entry_t->nexthop_t && entry_t->nexthop == arp_t->ipAddr) {

                                entry_t->nexthop_t = (void *)arp_t;
                                _rtl8651_updateNextHopEntry(0, entry_t);
                        } else if (entry_t->nexthop_t && entry_t->nexthop == arp_t->ipAddr) {
                                entry_t->nexthop_t = (void *)((void *)0);
                                _rtl8651_updateNextHopEntry(0, entry_t);
                        }
                }
        }
        else {

                for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next) {
                        if (entry_t->nexthop_t == (void *)session_t)
                                _rtl8651_updateNextHopEntry(0, entry_t);
                }
        }
}



static void
_rtl8651_updateNextHopEntry(ipaddr_t nexthop, rtl8651_tblDrv_nextHopEntry_t *entry_t)
{
        rtl865x_tblAsicDrv_nextHopParam_t asic;






        do {} while (0);

        if (nexthop != 0) {
                for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next)
                        if (entry_t->nexthop == nexthop)
                                break;
        }

        bzero(&asic, sizeof(rtl865x_tblAsicDrv_nextHopParam_t));
        if (entry_t->nextHopType == 0x01 ) {
                rtl8651_tblDrv_arpEntry_t *arp_t = (rtl8651_tblDrv_arpEntry_t *)entry_t->nexthop_t;
                asic.nextHopRow = (arp_t)? rtl8651_filterDbIndex(&arp_t->macInfo->macAddr): _l2Reserved_;
                asic.nextHopColumn = (arp_t)? arp_t->macInfo->asicPos: 0;
                asic.isPppoe = 0;
                asic.pppoeIdx = 0;
        }
        else {




                rtl8651_tblDrv_pppTable_t *pppoe_t = (rtl8651_tblDrv_pppTable_t *)entry_t->nexthop_t;
                do {} while (0);
                asic.nextHopRow = (pppoe_t->initiated)? rtl8651_filterDbIndex(&pppoe_t->macInfo->macAddr): _l2Reserved_;
                asic.nextHopColumn = (pppoe_t->initiated)? pppoe_t->macInfo->asicPos: 0;
                asic.isPppoe = (pppoe_t->type == 0x01)? 1: 0;
                asic.pppoeIdx = (pppoe_t->type == 0x01)? ((pppoe_t - DrvTbl.pppoe)): 0;
        }






        asic.dvid = (entry_t->dvid& (8 -1));
        asic.extIntIpIdx = entry_t->ip_t? (entry_t->ip_t - DrvTbl.iptbl): 0;
        rtl8651_setAsicNextHopTable(entry_t->entryIndex, &asic);
}






static void _rtl8651_arrangeNextHopTable(ipaddr_t nexthop, rtl8651_tblDrv_filterDbTableEntry_t *macInfo)
{
        rtl8651_tblDrv_nextHopEntry_t *entry_t=((&DrvTbl.inuseList.nexthop)->slh_first);
        rtl865x_tblAsicDrv_nextHopParam_t nxthop;
        rtl8651_tblDrv_ipEntry_t *ipEntry_t=DrvTbl.iptbl;
        uint32 entry, flag=0;
# 26269 "rtl8651_tblDrv.c"
        bzero(&nxthop, sizeof(rtl865x_tblAsicDrv_nextHopParam_t));
        if (nexthop != 0) {
                for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next) {
                        if (entry_t->nexthop != nexthop)
                                break;
                        rtl8651_getAsicNextHopTable(entry_t->entryIndex, &nxthop);
                        nxthop.nextHopRow = (!macInfo)? _l2Reserved_: rtl8651_filterDbIndex(&macInfo->macAddr);
                        nxthop.nextHopColumn = (!macInfo)? 0: macInfo->asicPos;
                        nxthop.extIntIpIdx = (entry_t->ip_t)? (entry_t->ip_t - DrvTbl.iptbl): 0;
                        rtl8651_setAsicNextHopTable(entry_t->entryIndex, &nxthop);
                }
                return;
        }
# 26297 "rtl8651_tblDrv.c"
        for(entry=1; entry<32&&entry_t; entry++) {





                if (entry_t->rt_flag && (flag==0) && (entry&0x01)) {
                        flag = 1;
                        continue;
                }
                if (!entry_t->rt_flag)
                        flag = 0;
                else flag = 1;
                entry_t->entryIndex = entry;
                _rtl8651_updateNextHopEntry(0, entry_t);
                entry_t = ((entry_t)->next.sle_next);
        }

        {
                rtl8651_tblDrv_routeTable_t *rt_t = DrvTbl.route;
                for(entry=0; entry<rtl8651_tblDrvPara.routingTableSize; entry++, rt_t++) {
                        if (rt_t->valid && rt_t->process == 0x05)
                                _rtl8651_updateL3Entry(rt_t);
                }
        }



        for(entry=0; entry<16; entry++, ipEntry_t++)
                if (ipEntry_t->valid == 1)
                        _rtl8651_updateIPTableEntry(ipEntry_t);


        _rtl8651_arrangeAllACL();




}





static int32 _rtl8651_addNextHopEntry(int8 attr, void *ptr_t, rtl8651_tblDrv_networkIntfTable_t *netif_t, ipaddr_t nexthop, ipaddr_t naptip, rtl8651_tblDrv_pppTable_t *session_t)
{
        rtl8651_tblDrv_nextHopEntry_t *entry_t, *last_t=((void *)0);
        rtl8651_tblDrv_nextHopEntry_t **nht_tt=((void *)0);
        rtl8651_tblDrv_routeTable_t *rt_t=((void *)0);
        rtl8651_tblDrv_ipEntry_t *ip_t;
        int32 entry=0;
# 26367 "rtl8651_tblDrv.c"
        do {} while (0);
        if (netif_t->linkLayerType != 0x01 && netif_t->linkLayerType != 0x04) {
                if (!session_t || session_t->netif_t != netif_t)
                        return -1;
        }


        switch(attr) {
        case 0x04:
# 26384 "rtl8651_tblDrv.c"
                nht_tt = &(((rtl8651_tblDrv_ipEntry_t *)ptr_t)->nextHop_t);
                if (netif_t->linkLayerType == 0x01 ) {

                        if (nexthop == 0) {

                                if (DrvTbl.route[rtl8651_tblDrvPara.routingTableSize-1].valid == 0) {
                                        ((rtl8651_tblDrv_ipEntry_t *)ptr_t)->def_flag = 1;
                                        *nht_tt = ((void *)0);
                                        return 0;
                                }
                                nexthop = DrvTbl.route[rtl8651_tblDrvPara.routingTableSize-1].nextHop;
                                ((rtl8651_tblDrv_ipEntry_t *)ptr_t)->def_flag = 1;
                        }
                        for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next) {
                                if (entry_t->rt_flag == 1)
                                        continue;
                                if (entry_t->nextHopType==0x01 && entry_t->nexthop == nexthop) {
                                        entry_t->refcount ++;
                                        *nht_tt = entry_t;
                                        _rtl8651_updateIPTableEntry(ptr_t);
                                        return 0;
                                }
                        }
                }
                else {

                        for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next) {
                                if (entry_t->rt_flag == 1)
                                        continue;
                                if ( entry_t->nextHopType!=0x01 && entry_t->nexthop_t == session_t) {
                                        entry_t->refcount ++;
                                        *nht_tt = entry_t;
                                        _rtl8651_updateIPTableEntry(ptr_t);
                                        return 0;
                                }
                        }
                }
                break;


        case 0x05:

                rt_t = (rtl8651_tblDrv_routeTable_t *)ptr_t;



                for((entry_t) = (&DrvTbl.freeList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next)
                        entry++;
                if (entry < 2)
                        return -1;
                for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next)
                        last_t = entry_t;
                break;

        case 0x06:
                nht_tt = &(((_rtl8651_tblDrvPolicy_t *)ptr_t)->nexthop_t);

                for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next) {
                        if (entry_t->rt_flag == 1 || entry_t->nextHopType != netif_t->linkLayerType)
                                continue;
                        if (netif_t->linkLayerType == 0x01) {
                                if (entry_t->nexthop == nexthop && entry_t->ip_t && entry_t->ip_t->extip == naptip) {
                                        entry_t->refcount ++;
                                        *nht_tt = entry_t;
                                        return 0;
                                }
                        }
                        else {
                                do {} while (0);
                                if (entry_t->nexthop_t == session_t) {
                                        entry_t->refcount ++;
                                        *nht_tt = entry_t;
                                        return 0;
                                }
                        }
                }
                for((entry_t) = (&DrvTbl.inuseList.nexthop)->slh_first; (entry_t); (entry_t) = (entry_t)->next.sle_next) {
                        if (entry_t->rt_flag == 1 || entry_t->nextHopType != netif_t->linkLayerType)
                                continue;
                        if (netif_t->linkLayerType == 0x01) {
                                if (entry_t->nexthop == nexthop && !entry_t->ip_t) {
                                        entry_t->ip_t = _rtl8651_getIPTableEntry(naptip, 0, 0x00);
                                        do {} while (0);
                                        entry_t->refcount ++;
                                        *nht_tt = entry_t;
                                        return 0;
                                }
                        }
                }
                break;

        case 0x07:
                return -1;

        default: do {} while (0);

        }





        if ((entry_t=((&DrvTbl.freeList.nexthop)->slh_first)) == ((void *)0))
                return -1;

        do { (&DrvTbl.freeList.nexthop)->slh_first = (&DrvTbl.freeList.nexthop)->slh_first->next.sle_next; } while (0);
        entry_t->valid = 1;
        entry_t->dvid = netif_t->vid;
        entry_t->nextHopType = netif_t->linkLayerType;
        entry_t->refcount = 1;
        entry_t->rt_flag = (attr == 0x05) ? 1: 0;
        if (netif_t->linkLayerType == 0x01) {
                entry_t->nexthop_t = (void *)_rtl8651_getArpEntry(netif_t, nexthop, 0);
                entry_t->nexthop = nexthop;
        } else {
                entry_t->nexthop_t = (void *)session_t;
                entry_t->nexthop = (session_t->session_t->ip_t)? session_t->session_t->ip_t->ipAddr: 0;
                if (attr < 0x05)
                        naptip = 0;
                else naptip = entry_t->nexthop;

                if ( (netif_t->linkLayerType == 0x05) ||
                        (netif_t->linkLayerType == 0x06))
                        entry_t->dvid = tunnel.loopBackVid;
        }
        entry_t->ip_t = (naptip!=0&&attr!=0x04)? _rtl8651_getIPTableEntry(naptip, 0, 0x00): ((void *)0);

        if (attr != 0x05) {

                do { (entry_t)->next.sle_next = (&DrvTbl.inuseList.nexthop)->slh_first; (&DrvTbl.inuseList.nexthop)->slh_first = (entry_t); } while (0);
                *nht_tt = entry_t;
        }
        else {

                rt_t->un.nxthop.start_t = entry_t; entry = 0;
                if (netif_t->linkLayerType == 0x01) {
                        if (naptip == 0) {
                                if (!def_napt_t) {
                                        ip_t = ((void *)0);
                                } else ip_t = def_napt_t;
                        } else ip_t = entry_t->ip_t;
                }
                else ip_t = entry_t->ip_t;

                do {
                        entry ++;
                        if (!last_t)
                                do { (entry_t)->next.sle_next = (&DrvTbl.inuseList.nexthop)->slh_first; (&DrvTbl.inuseList.nexthop)->slh_first = (entry_t); } while (0);
                        else do { (entry_t)->next.sle_next = (last_t)->next.sle_next; (last_t)->next.sle_next = (entry_t); } while (0);
                        entry_t->ip_t = ip_t;
                        if (entry >= 2) break;
                        last_t = entry_t;
                        entry_t = ((&DrvTbl.freeList.nexthop)->slh_first);
                        do { (&DrvTbl.freeList.nexthop)->slh_first = (&DrvTbl.freeList.nexthop)->slh_first->next.sle_next; } while (0);
                        memcpy(entry_t, last_t, sizeof(rtl8651_tblDrv_nextHopEntry_t));
                } while (1);
                rt_t->un.nxthop.end_t = entry_t;
        }

        _rtl8651_arrangeNextHopTable(0, ((void *)0));
        return 0;
}



static int32 _rtl8651_delNextHopEntry(int8 attr, void *ptr_t)
{
        rtl8651_tblDrv_nextHopEntry_t *entry_t=((void *)0), *del_t, **p_t=((void *)0);
        rtl8651_tblDrv_routeTable_t *rt_t;

        rtl8651_tblDrv_ipEntry_t *ip_t;
        uint32 entry;

        do {} while (0);

        switch(attr)
        {
        case 0x04:
                ip_t = (rtl8651_tblDrv_ipEntry_t *)ptr_t;
                if ((entry_t=ip_t->nextHop_t) == ((void *)0))
                        return 0;
                if ((--entry_t->refcount) > 0) {
                        ip_t->nextHop_t = ((void *)0);
                        _rtl8651_updateIPTableEntry(ptr_t);
                        return 0;
                }
                p_t = &ip_t->nextHop_t ;
                break;

        case 0x05:
                rt_t = (rtl8651_tblDrv_routeTable_t *)ptr_t;
                del_t = rt_t->un.nxthop.start_t;
                entry = rt_t->un.nxthop.end_t->entryIndex - rt_t->un.nxthop.start_t->entryIndex + 1;
                while (entry> 0 ) {
                        entry_t = ((del_t)->next.sle_next);
                        do { if ((&DrvTbl.inuseList.nexthop)->slh_first == (del_t)) { do { ((&DrvTbl.inuseList.nexthop))->slh_first = ((&DrvTbl.inuseList.nexthop))->slh_first->next.sle_next; } while (0); } else { struct rtl8651_tblDrv_nextHopEntry_s *curelm = (&DrvTbl.inuseList.nexthop)->slh_first; while( curelm->next.sle_next != (del_t) ) curelm = curelm->next.sle_next; curelm->next.sle_next = curelm->next.sle_next->next.sle_next; } } while (0);
                        do { (del_t)->next.sle_next = (&DrvTbl.freeList.nexthop)->slh_first; (&DrvTbl.freeList.nexthop)->slh_first = (del_t); } while (0);
                        del_t = entry_t;
                        entry--;
                }
                rt_t->un.nxthop.start_t = rt_t->un.nxthop.end_t = ((void *)0);
                _rtl8651_arrangeNextHopTable(0, ((void *)0));
                return 0;
# 26601 "rtl8651_tblDrv.c"
        case 0x07:
                return -1;

        default: do {} while (0);

        }

        do { if ((&DrvTbl.inuseList.nexthop)->slh_first == (entry_t)) { do { ((&DrvTbl.inuseList.nexthop))->slh_first = ((&DrvTbl.inuseList.nexthop))->slh_first->next.sle_next; } while (0); } else { struct rtl8651_tblDrv_nextHopEntry_s *curelm = (&DrvTbl.inuseList.nexthop)->slh_first; while( curelm->next.sle_next != (entry_t) ) curelm = curelm->next.sle_next; curelm->next.sle_next = curelm->next.sle_next->next.sle_next; } } while (0);
        do { (entry_t)->next.sle_next = (&DrvTbl.freeList.nexthop)->slh_first; (&DrvTbl.freeList.nexthop)->slh_first = (entry_t); } while (0);
        *p_t = ((void *)0);

        _rtl8651_arrangeNextHopTable(0, ((void *)0));
        return 0;
}



int32 _rtl8651_addHash2ToNexthop(ipaddr_t nexthop, ipaddr_t naptip)
{
        rtl8651_tblDrv_networkIntfTable_t *netif_t;
        rtl8651_tblDrv_ipEntry_t *ipEntry_t;

        if ((netif_t = _rtl8651_getIpInfo(naptip, ((void *)0), ((void *)0), ((void *)0))) == ((void *)0))
                return -1;
        if (_rtl8651_isNaptMapping(naptip) == 0)
                return -1;

        if (netif_t->linkLayerType != 0x01)
                nexthop = 0;
        if ((ipEntry_t=_rtl8651_addIpEntry(naptip, nexthop, 0x00, netif_t)) == ((void *)0))
                return -1;

        return ((ipEntry_t - DrvTbl.iptbl));
}


int32 _rtl8651_delHash2FromNexthop(ipaddr_t nexthop, ipaddr_t naptip)
{

        int32 retval;

        if (_rtl8651_isNaptMapping(naptip) == 0)
                return -1;
        retval = _rtl8651_delIpEntry(0x00, naptip, nexthop);

        return retval;
}


int32 _rtl8651_findHash2ToNexthop(ipaddr_t nexthop, ipaddr_t naptip)
{
        rtl8651_tblDrv_ipEntry_t *ipEntry_t=DrvTbl.iptbl;
        struct rtl8651_tblDrv_nextHopEntry_s *nexthop_t;
        int32 entry;

        if (nexthop == 0) {
                if ( def_napt_t == ((void *)0) )
                        return -1;
                nexthop = def_napt_t->nextHop_t->nexthop;
                if (nexthop == 0)
                        return -1;
        }
        for(entry=0; entry<16; entry++, ipEntry_t++) {
                if (ipEntry_t->valid == 0 || ipEntry_t->extip!=naptip)
                        continue;
                nexthop_t = ipEntry_t->nextHop_t;
                if (nexthop_t == ((void *)0))
                        continue;
                if (nexthop_t->nexthop == nexthop)
                        return (ipEntry_t - DrvTbl.iptbl);
        }
        return -1;
}
# 26817 "rtl8651_tblDrv.c"
void _rtl8651_timeUpdate(uint32 secPassed)
{
        static uint32 secCounter=0;

        _rtl8651_timeUpdateNaptIcmpTable(secPassed);
        _rtl8651_softwareNaptAging(secPassed);
        _rtl8651_timeUpdateArp(secPassed);
        _rtl8651_timeUpdateSessionHangUp(secPassed);
        _rtl8651_timeUpdateMulticast(secPassed);

        _rtl8651_fwdEngineTimeUpdate(secPassed);

        _rtl8651_dynamicPolicyRouteTimeupdate(secPassed);

        _rtl8651_ipClassTimeUpdate();
        _rtl8651_naptTimerAdaptiveAdjust(1, 10, secPassed);
        _sysUpSeconds+=secPassed;

        _rtl8651_rateLimitCounterTimeUpdate(secPassed);

        _rtl8651_run_timer_list();
        _rtl8651_dosProc_blockSip_discharge(_sysUpSeconds);

        _rtl8651_dns_timeUpdate(secPassed);



        {

                if (++secCounter == 5) {
                        uint32 port, value;

                        for(port = 0; port < (6 - 1); port++) {
                                value = (port==4) ? ((*((volatile uint32 *)((0x0CC + (0xBC800000 + 0x00005000)))))) : (((*((volatile uint32 *)((0x0C8 + (0xBC800000 + 0x00005000))))))>> (port * 8));
                                if (( value&(1<<4) ) && (_rtl8651_portStatusPatch(port) == 0x00))
                                {
                                        printk("%s():%d  port %d link up!\n", __FUNCTION__, 26853, port );
                                        rtl8651_setAsicEthernetLinkStatus(port, 1);
                                }
                                else if ((!( value&(1<<4) )) && (_rtl8651_portStatusPatch(port) == 0x01))
                                {
                                        printk("%s():%d port %d link down!\n", __FUNCTION__, 26858, port);
                                        rtl8651_setAsicEthernetLinkStatus(port, 0);
                                }
                        }
                        secCounter = 0;
                }
        }
}
# 26885 "rtl8651_tblDrv.c"
uint32 tuRemind;
uint32 accJiffies;
uint32 timer1Sec;
uint32 prevTC1CNT;

void _rtl8651_realtimeSchedule( void )
{
    uint32 jifPassed;
    uint32 secPassed;
        uint32 currTC1CNT;
        uint32 systemHZ;
        uint32 tc0data;

        systemHZ = rtl865x_getHZ();
        tc0data = ((*((volatile uint32 *)((0x020 + (0xBD010000 +0x2000))))))>>8;
# 26911 "rtl8651_tblDrv.c"
        currTC1CNT = ((*((volatile uint32 *)((0x02C + (0xBD010000 +0x2000))))));
        if ( prevTC1CNT >= currTC1CNT )
        {

                tuRemind += (prevTC1CNT-currTC1CNT)>>8;
        }
        else
        {

                tuRemind += (prevTC1CNT+(0xffffff00-currTC1CNT)+(0x1<<8))>>8;
        }
        prevTC1CNT = currTC1CNT;


        if ( tc0data == 0 )
        {
                jifPassed = 0;
        }
        else
        {
                jifPassed = tuRemind / tc0data;
                tuRemind = tuRemind % tc0data;
        }







    secPassed = ((accJiffies+jifPassed)/systemHZ)-(accJiffies/systemHZ);
    if ( secPassed > 0 ) _rtl8651_timeUpdate(secPassed);

    timer1Sec += secPassed;
    accJiffies += jifPassed;
}


void rtl8651_realtimeSchedule( void )
{
        rtlglue_drvMutexLock();
        _rtl8651_realtimeSchedule();
        rtlglue_drvMutexUnlock();
}





void rtl8651_timeUpdate(uint32 dummy)
{
        _rtl8651_realtimeSchedule();
}


int32 rtl8651_layer3_alloc(void){
        int32 index;

        { (AsicTableUsage.arp) = (rtl8651_tblDrv_arpAsicArrangementEntry_t *)rtlglue_malloc((64) * sizeof(rtl8651_tblDrv_arpAsicArrangementEntry_t)); if(!(AsicTableUsage.arp)){ printk("MEM alloc failed at line %d\n", 26969); return -1; } };
        { (DrvTbl.route) = (rtl8651_tblDrv_routeTable_t *)rtlglue_malloc((rtl8651_tblDrvPara.routingTableSize) * sizeof(rtl8651_tblDrv_routeTable_t)); if(!(DrvTbl.route)){ printk("MEM alloc failed at line %d\n", 26970); return -1; } };
        { (DrvTbl.netIface) = (rtl8651_tblDrv_networkIntfTable_t *)rtlglue_malloc((rtl8651_tblDrvPara.networkIntfTableSize) * sizeof(rtl8651_tblDrv_networkIntfTable_t)); if(!(DrvTbl.netIface)){ printk("MEM alloc failed at line %d\n", 26971); return -1; } };
        { (DrvTbl.pppoe) = (rtl8651_tblDrv_pppTable_t *)rtlglue_malloc(((rtl8651_tblDrvPara.pptpSize+rtl8651_tblDrvPara.l2tpSize+8)) * sizeof(rtl8651_tblDrv_pppTable_t)); if(!(DrvTbl.pppoe)){ printk("MEM alloc failed at line %d\n", 26972); return -1; } };
        { (DrvTbl.iptbl) = (rtl8651_tblDrv_ipEntry_t *)rtlglue_malloc((16) * sizeof(rtl8651_tblDrv_ipEntry_t)); if(!(DrvTbl.iptbl)){ printk("MEM alloc failed at line %d\n", 26973); return -1; } };
        { (DrvTbl.rateLimit) = (rtl8651_tblDrv_rateLimit_t *)rtlglue_malloc((32) * sizeof(rtl8651_tblDrv_rateLimit_t)); if(!(DrvTbl.rateLimit)){ printk("MEM alloc failed at line %d\n", 26974); return -1; } };
# 26983 "rtl8651_tblDrv.c"
        {
                rtl8651_tblDrv_macACEntry_t *macCtrlTable;
                do { (&DrvTbl.freeList.freeMacAccessControl)->tqh_count=0; (&DrvTbl.freeList.freeMacAccessControl)->tqh_first = ((void *)0); (&DrvTbl.freeList.freeMacAccessControl)->tqh_last = &(&DrvTbl.freeList.freeMacAccessControl)->tqh_first; } while (0);
                if (rtl8651_tblDrvPara.macAccessControllSize > 0) {
                        { (macCtrlTable) = (rtl8651_tblDrv_macACEntry_t *)rtlglue_malloc((rtl8651_tblDrvPara.macAccessControllSize) * sizeof(rtl8651_tblDrv_macACEntry_t)); if(!(macCtrlTable)){ printk("MEM alloc failed at line %d\n", 26987); return -1; } };
                        for(index=0; index<rtl8651_tblDrvPara.macAccessControllSize; index++)
                                do { if (((&macCtrlTable[index])->nextMAC.tqe_next = (&DrvTbl.freeList.freeMacAccessControl)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMacAccessControl)->tqh_first->nextMAC.tqe_prev = &(&macCtrlTable[index])->nextMAC.tqe_next; else (&DrvTbl.freeList.freeMacAccessControl)->tqh_last = &(&macCtrlTable[index])->nextMAC.tqe_next; (&DrvTbl.freeList.freeMacAccessControl)->tqh_first = (&macCtrlTable[index]); (&macCtrlTable[index])->nextMAC.tqe_prev = &(&DrvTbl.freeList.freeMacAccessControl)->tqh_first; (&DrvTbl.freeList.freeMacAccessControl)->tqh_count++;} while (0);
                }
                { (DrvTbl.macACInfo) = (rtl8651_tblDrv_macContrl_t *)rtlglue_malloc((1) * sizeof(rtl8651_tblDrv_macContrl_t)); if(!(DrvTbl.macACInfo)){ printk("MEM alloc failed at line %d\n", 26991); return -1; } };
        }





        {
                rtl8651_tblDrv_mCast_t *multiCast_t;
                { (multiCast_t) = (rtl8651_tblDrv_mCast_t *)rtlglue_malloc((rtl8651_tblDrvPara.mCastTblSize) * sizeof(rtl8651_tblDrv_mCast_t)); if(!(multiCast_t)){ printk("MEM alloc failed at line %d\n", 27000); return -1; } };
                do { (&DrvTbl.freeList.freeMultiCast)->tqh_first = ((void *)0); (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);
                for(index=0; index<rtl8651_tblDrvPara.mCastTblSize; index++)
                        do { if (((&multiCast_t[index])->nextMCast.tqe_next = (&DrvTbl.freeList.freeMultiCast)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMultiCast)->tqh_first->nextMCast.tqe_prev = &(&multiCast_t[index])->nextMCast.tqe_next; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(&multiCast_t[index])->nextMCast.tqe_next; (&DrvTbl.freeList.freeMultiCast)->tqh_first = (&multiCast_t[index]); (&multiCast_t[index])->nextMCast.tqe_prev = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);

                { (multiCast_t) = (rtl8651_tblDrv_mCast_t *)rtlglue_malloc((64) * sizeof(rtl8651_tblDrv_mCast_t)); if(!(multiCast_t)){ printk("MEM alloc failed at line %d\n", 27005); return -1; } };
                DrvTbl.inuseList.mCastTbl = (void *)multiCast_t;
        }




        {
                rtl8651_tblDrvSession_t *session_t;
                { (session_t) = (rtl8651_tblDrvSession_t *)rtlglue_malloc((rtl8651_tblDrvPara.dialSessionNumber) * sizeof(rtl8651_tblDrvSession_t)); if(!(session_t)){ printk("MEM alloc failed at line %d\n", 27014); return -1; } };
                do { (&DrvTbl.freeList.freeSession)->tqh_first = ((void *)0); (&DrvTbl.freeList.freeSession)->tqh_last = &(&DrvTbl.freeList.freeSession)->tqh_first; } while (0);
                for(index=0; index<rtl8651_tblDrvPara.dialSessionNumber; index++)
                        do { if (((&session_t[index])->nextSession.tqe_next = (&DrvTbl.freeList.freeSession)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeSession)->tqh_first->nextSession.tqe_prev = &(&session_t[index])->nextSession.tqe_next; else (&DrvTbl.freeList.freeSession)->tqh_last = &(&session_t[index])->nextSession.tqe_next; (&DrvTbl.freeList.freeSession)->tqh_first = (&session_t[index]); (&session_t[index])->nextSession.tqe_prev = &(&DrvTbl.freeList.freeSession)->tqh_first; } while (0);
        }



        {
                _rtl8651_tblDrvPolicy_t *policy_t;
                { (policy_t) = (_rtl8651_tblDrvPolicy_t *)rtlglue_malloc((rtl8651_tblDrvPara.policyRules) * sizeof(_rtl8651_tblDrvPolicy_t)); if(!(policy_t)){ printk("MEM alloc failed at line %d\n", 27024); return -1; } };
                do { (&DrvTbl.freeList.freePolicy)->tqh_first = ((void *)0); (&DrvTbl.freeList.freePolicy)->tqh_last = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
                for(index=0; index<rtl8651_tblDrvPara.policyRules; index++)
                        do { if (((&policy_t[index])->nextPolicy_t.tqe_next = (&DrvTbl.freeList.freePolicy)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freePolicy)->tqh_first->nextPolicy_t.tqe_prev = &(&policy_t[index])->nextPolicy_t.tqe_next; else (&DrvTbl.freeList.freePolicy)->tqh_last = &(&policy_t[index])->nextPolicy_t.tqe_next; (&DrvTbl.freeList.freePolicy)->tqh_first = (&policy_t[index]); (&policy_t[index])->nextPolicy_t.tqe_prev = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
        }



        {

                struct tailqHead { struct _rtl8651_tblDrvPolicy_s *tqh_first; struct _rtl8651_tblDrvPolicy_s **tqh_last; };
                struct hashHead { struct _rtl8651_tblDrvPolicy_s *tqh_first; struct _rtl8651_tblDrvPolicy_s **tqh_last; };
                struct hashHead *tempPtr;

                { (tempPtr) = (struct hashHead *)rtlglue_malloc((rtl8651_tblDrvPara.dynamicPolicy) * sizeof(struct hashHead)); if(!(tempPtr)){ printk("MEM alloc failed at line %d\n", 27038); return -1; } };
                DrvTbl.dynamicPolicy.hashTable = (void *)tempPtr;
                { (DrvTbl.dynamicPolicy.policy_t) = (_rtl8651_tblDrvPolicy_t *)rtlglue_malloc((rtl8651_tblDrvPara.dynamicPolicy) * sizeof(_rtl8651_tblDrvPolicy_t)); if(!(DrvTbl.dynamicPolicy.policy_t)){ printk("MEM alloc failed at line %d\n", 27040); return -1; } };


        }



        {
                int32 i;
                _rtl8651_tblDrvAclRule_t *aclRule;
                { (aclRule) = (_rtl8651_tblDrvAclRule_t *)rtlglue_malloc((rtl8651_tblDrvPara.aclSize) * sizeof(_rtl8651_tblDrvAclRule_t)); if(!(aclRule)){ printk("MEM alloc failed at line %d\n", 27050); return -1; } };
                do { (&DrvTbl.freeList.aclRule)->tqh_count=0; (&DrvTbl.freeList.aclRule)->tqh_first = ((void *)0); (&DrvTbl.freeList.aclRule)->tqh_last = &(&DrvTbl.freeList.aclRule)->tqh_first; } while (0);
                for(i=0; i<rtl8651_tblDrvPara.aclSize; i++)
                        do { if (((&aclRule[i])->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(&aclRule[i])->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(&aclRule[i])->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (&aclRule[i]); (&aclRule[i])->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
        }



        {
                rtl8651_tblDrv_ipIntfEntry_t * tempIpIntf;
                { (tempIpIntf) = (rtl8651_tblDrv_ipIntfEntry_t *)rtlglue_malloc((rtl8651_tblDrvPara.ipIntfEntryNumber) * sizeof(rtl8651_tblDrv_ipIntfEntry_t)); if(!(tempIpIntf)){ printk("MEM alloc failed at line %d\n", 27060); return -1; } };
                { (&DrvTbl.freeList.ipIface)->slh_first = ((void *)0); };
                for(index=0; index<rtl8651_tblDrvPara.ipIntfEntryNumber; index++){
                        { (&tempIpIntf[index].ipAddr)->slh_first = ((void *)0); };
                        { (&tempIpIntf[index].localServer)->slh_first = ((void *)0); };
                        { (&tempIpIntf[index].nextArp)->slh_first = ((void *)0); };
                        do { (&tempIpIntf[index])->nextIp.sle_next = (&DrvTbl.freeList.ipIface)->slh_first; (&DrvTbl.freeList.ipIface)->slh_first = (&tempIpIntf[index]); } while (0);
                }
        }




        {
                rtl8651_tblDrv_ipIntfIpAddrEntry_t * tempIpAddr;
                { (tempIpAddr) = (rtl8651_tblDrv_ipIntfIpAddrEntry_t *)rtlglue_malloc((rtl8651_tblDrvPara.ipIntfIpAddrNumber) * sizeof(rtl8651_tblDrv_ipIntfIpAddrEntry_t)); if(!(tempIpAddr)){ printk("MEM alloc failed at line %d\n", 27075); return -1; } };
                { (&DrvTbl.freeList.ipAddr)->slh_first = ((void *)0); };
                for(index=0; index<rtl8651_tblDrvPara.ipIntfIpAddrNumber; index++)
                        do { (&tempIpAddr[index])->nextIpAddr.sle_next = (&DrvTbl.freeList.ipAddr)->slh_first; (&DrvTbl.freeList.ipAddr)->slh_first = (&tempIpAddr[index]); } while (0);
        }



        {
                rtl8651_tblDrv_arpEntry_t * tempArp;
                { (tempArp) = (rtl8651_tblDrv_arpEntry_t *)rtlglue_malloc((rtl8651_tblDrvPara.arpTableSize) * sizeof(rtl8651_tblDrv_arpEntry_t)); if(!(tempArp)){ printk("MEM alloc failed at line %d\n", 27085); return -1; } };
                { (&DrvTbl.freeList.arp)->slh_count=0; (&DrvTbl.freeList.arp)->slh_first = ((void *)0); };
                for(index=0; index<rtl8651_tblDrvPara.arpTableSize; index++)
                        do { (&tempArp[index])->next.sle_next = (&DrvTbl.freeList.arp)->slh_first; (&DrvTbl.freeList.arp)->slh_first = (&tempArp[index]); (&DrvTbl.freeList.arp)->slh_count++;} while (0);
        }





        {
                rtl8651_tblDrv_protocolBasedNat_t *pbNat;
                { (pbNat) = (rtl8651_tblDrv_protocolBasedNat_t *)rtlglue_malloc((rtl8651_tblDrvPara.protocolBasedNatSize) * sizeof(rtl8651_tblDrv_protocolBasedNat_t)); if(!(pbNat)){ printk("MEM alloc failed at line %d\n", 27097); return -1; } };
                { (&DrvTbl.inuseList.protocolBasedNat)->slh_first = ((void *)0); };
                { (&DrvTbl.freeList.protocolBasedNat)->slh_first = ((void *)0); };
                for(index=0;index<rtl8651_tblDrvPara.protocolBasedNatSize;index++)
                {
                        do { (&pbNat[index])->next.sle_next = (&DrvTbl.freeList.protocolBasedNat)->slh_first; (&DrvTbl.freeList.protocolBasedNat)->slh_first = (&pbNat[index]); } while (0);
                }
        }




        {
                rtl8651_tblDrv_nextHopEntry_t *tmp_t;
                { (&DrvTbl.freeList.nexthop)->slh_first = ((void *)0); };
                { (tmp_t) = (rtl8651_tblDrv_nextHopEntry_t *)rtlglue_malloc((32) * sizeof(rtl8651_tblDrv_nextHopEntry_t)); if(!(tmp_t)){ printk("MEM alloc failed at line %d\n", 27112); return -1; } };
                for(index=0; index<32; index++)
                        do { (&tmp_t[index])->next.sle_next = (&DrvTbl.freeList.nexthop)->slh_first; (&DrvTbl.freeList.nexthop)->slh_first = (&tmp_t[index]); } while (0);
        }




        {
                rtl8651_tblDrv_ipUnnumbered_t *tmp_t;
                { (&DrvTbl.freeList.freeIpUnnumber)->slh_first = ((void *)0); };
                { (&DrvTbl.inuseList.ipUnnumber)->slh_first = ((void *)0); };
                { (tmp_t) = (rtl8651_tblDrv_ipUnnumbered_t *)rtlglue_malloc((rtl8651_tblDrvPara.ipUnnumberSize) * sizeof(rtl8651_tblDrv_ipUnnumbered_t)); if(!(tmp_t)){ printk("MEM alloc failed at line %d\n", 27124); return -1; } };
                for(index=0; index<rtl8651_tblDrvPara.ipUnnumberSize; index++)
                        do { (&tmp_t[index])->nextIpUnnumberEntry.sle_next = (&DrvTbl.freeList.freeIpUnnumber)->slh_first; (&DrvTbl.freeList.freeIpUnnumber)->slh_first = (&tmp_t[index]); } while (0);
        }
# 27139 "rtl8651_tblDrv.c"
        return 0;
# 27151 "rtl8651_tblDrv.c"
        return 0;
}


int32 rtl8651_layer3_collect(void) {
        uint32 entry, index;





        {
                rtl8651_tblDrv_macACEntry_t *macCtrl;
                while ((macCtrl=((&DrvTbl.macACInfo->macAccessControl)->tqh_first))) {
                        do { if (((macCtrl)->nextMAC.tqe_next) != ((void *)0)) (macCtrl)->nextMAC.tqe_next->nextMAC.tqe_prev = (macCtrl)->nextMAC.tqe_prev; else (&DrvTbl.macACInfo->macAccessControl)->tqh_last = (macCtrl)->nextMAC.tqe_prev; *(macCtrl)->nextMAC.tqe_prev = (macCtrl)->nextMAC.tqe_next; (&DrvTbl.macACInfo->macAccessControl)->tqh_count--;} while (0);
                        do { if (((macCtrl)->nextMAC.tqe_next = (&DrvTbl.freeList.freeMacAccessControl)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMacAccessControl)->tqh_first->nextMAC.tqe_prev = &(macCtrl)->nextMAC.tqe_next; else (&DrvTbl.freeList.freeMacAccessControl)->tqh_last = &(macCtrl)->nextMAC.tqe_next; (&DrvTbl.freeList.freeMacAccessControl)->tqh_first = (macCtrl); (macCtrl)->nextMAC.tqe_prev = &(&DrvTbl.freeList.freeMacAccessControl)->tqh_first; (&DrvTbl.freeList.freeMacAccessControl)->tqh_count++;} while (0);
                }
                do {} while (0);
        }





        {
                rtl8651_tblDrv_mCast_t *mCast_t;
                for(entry=0; entry<rtl8651_tblDrvPara.mCastTblSize; entry++) {
                        while ((mCast_t=((&DrvTbl.inuseList.mCastTbl[entry])->tqh_first))) {
                                do { if (((mCast_t)->nextMCast.tqe_next) != ((void *)0)) (mCast_t)->nextMCast.tqe_next->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_prev; else (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = (mCast_t)->nextMCast.tqe_prev; *(mCast_t)->nextMCast.tqe_prev = (mCast_t)->nextMCast.tqe_next; } while (0);
                                do { if (((mCast_t)->nextMCast.tqe_next = (&DrvTbl.freeList.freeMultiCast)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeMultiCast)->tqh_first->nextMCast.tqe_prev = &(mCast_t)->nextMCast.tqe_next; else (&DrvTbl.freeList.freeMultiCast)->tqh_last = &(mCast_t)->nextMCast.tqe_next; (&DrvTbl.freeList.freeMultiCast)->tqh_first = (mCast_t); (mCast_t)->nextMCast.tqe_prev = &(&DrvTbl.freeList.freeMultiCast)->tqh_first; } while (0);
                        }
                }
                entry = 0;
                for (mCast_t = ((&DrvTbl.freeList.freeMultiCast)->tqh_first); mCast_t; mCast_t = ((mCast_t)->nextMCast.tqe_next))
                        entry ++;
                do {} while (0);
        }





        {
                rtl8651_tblDrvSession_t *session_t;
                rtl8651_tblDrv_networkIntfTable_t *netif_t=DrvTbl.netIface;
                for(entry=0; entry<rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                        if (netif_t->valid == 0)
                                continue;
                        while((session_t=((&netif_t->sessionHead)->tqh_first))) {
                                do { if (((session_t)->nextSession.tqe_next) != ((void *)0)) (session_t)->nextSession.tqe_next->nextSession.tqe_prev = (session_t)->nextSession.tqe_prev; else (&netif_t->sessionHead)->tqh_last = (session_t)->nextSession.tqe_prev; *(session_t)->nextSession.tqe_prev = (session_t)->nextSession.tqe_next; (&netif_t->sessionHead)->tqh_count--;} while (0);
                                do { if (((session_t)->nextSession.tqe_next = (&DrvTbl.freeList.freeSession)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freeSession)->tqh_first->nextSession.tqe_prev = &(session_t)->nextSession.tqe_next; else (&DrvTbl.freeList.freeSession)->tqh_last = &(session_t)->nextSession.tqe_next; (&DrvTbl.freeList.freeSession)->tqh_first = (session_t); (session_t)->nextSession.tqe_prev = &(&DrvTbl.freeList.freeSession)->tqh_first; } while (0);
                        }
                }
                entry = 0;
                for (session_t = ((&DrvTbl.freeList.freeSession)->tqh_first); session_t; session_t = ((session_t)->nextSession.tqe_next))
                        entry ++;
                do {} while (0);
        }



        {
                _rtl8651_tblDrvPolicy_t *policy_t;
                rtl8651_tblDrv_networkIntfTable_t *netif_t=DrvTbl.netIface;
                while((policy_t=((&DrvTbl.inuseList.policyRoute)->tqh_first))) {
                        do { if (((policy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (policy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (policy_t)->nextPolicy_t.tqe_prev; else (&DrvTbl.inuseList.policyRoute)->tqh_last = (policy_t)->nextPolicy_t.tqe_prev; *(policy_t)->nextPolicy_t.tqe_prev = (policy_t)->nextPolicy_t.tqe_next; } while (0);
                        do { if (((policy_t)->nextPolicy_t.tqe_next = (&DrvTbl.freeList.freePolicy)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freePolicy)->tqh_first->nextPolicy_t.tqe_prev = &(policy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.freeList.freePolicy)->tqh_last = &(policy_t)->nextPolicy_t.tqe_next; (&DrvTbl.freeList.freePolicy)->tqh_first = (policy_t); (policy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
                }
                for(entry=0; entry< rtl8651_tblDrvPara.networkIntfTableSize; entry++, netif_t++) {
                        if (netif_t->valid == 0)
                                continue;
                        while((policy_t=((&netif_t->policyQosHead)->tqh_first))) {
                                do { if (((policy_t)->nextPolicy_t.tqe_next) != ((void *)0)) (policy_t)->nextPolicy_t.tqe_next->nextPolicy_t.tqe_prev = (policy_t)->nextPolicy_t.tqe_prev; else (&netif_t->policyQosHead)->tqh_last = (policy_t)->nextPolicy_t.tqe_prev; *(policy_t)->nextPolicy_t.tqe_prev = (policy_t)->nextPolicy_t.tqe_next; (&netif_t->policyQosHead)->tqh_count--;} while (0);
                                do { if (((policy_t)->nextPolicy_t.tqe_next = (&DrvTbl.freeList.freePolicy)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.freePolicy)->tqh_first->nextPolicy_t.tqe_prev = &(policy_t)->nextPolicy_t.tqe_next; else (&DrvTbl.freeList.freePolicy)->tqh_last = &(policy_t)->nextPolicy_t.tqe_next; (&DrvTbl.freeList.freePolicy)->tqh_first = (policy_t); (policy_t)->nextPolicy_t.tqe_prev = &(&DrvTbl.freeList.freePolicy)->tqh_first; } while (0);
                        }
                }
                entry = 0;
                for (policy_t = ((&DrvTbl.freeList.freePolicy)->tqh_first); policy_t; policy_t = ((policy_t)->nextPolicy_t.tqe_next))
                        entry ++;
                do {} while (0);
        }

        {
                _rtl8651_tblDrvAclRule_t *rule;
                rtl8651_tblDrv_networkIntfTable_t *netIfPtr;
                int32 i;
                for(i=0,netIfPtr=&DrvTbl.netIface[0]; i< rtl8651_tblDrvPara.networkIntfTableSize; i++,netIfPtr++)
                        if (netIfPtr->valid == 1) {

                                while ((rule=((&netIfPtr->inAclHead)->tqh_first))) {
                                        do { if (((rule)->nextRule.tqe_next) != ((void *)0)) (rule)->nextRule.tqe_next->nextRule.tqe_prev = (rule)->nextRule.tqe_prev; else (&netIfPtr->inAclHead)->tqh_last = (rule)->nextRule.tqe_prev; *(rule)->nextRule.tqe_prev = (rule)->nextRule.tqe_next; (&netIfPtr->inAclHead)->tqh_count--;} while (0);
                                        do { if (((rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rule); (rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                                }

                                while ((rule=((&netIfPtr->outAclHead)->tqh_first))) {
                                        do { if (((rule)->nextRule.tqe_next) != ((void *)0)) (rule)->nextRule.tqe_next->nextRule.tqe_prev = (rule)->nextRule.tqe_prev; else (&netIfPtr->outAclHead)->tqh_last = (rule)->nextRule.tqe_prev; *(rule)->nextRule.tqe_prev = (rule)->nextRule.tqe_next; (&netIfPtr->outAclHead)->tqh_count--;} while (0);
                                        do { if (((rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rule); (rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                                }

                                while ((rule=((&netIfPtr->inRateLimitHead)->tqh_first))) {
                                        do { if (((rule)->nextRule.tqe_next) != ((void *)0)) (rule)->nextRule.tqe_next->nextRule.tqe_prev = (rule)->nextRule.tqe_prev; else (&netIfPtr->inRateLimitHead)->tqh_last = (rule)->nextRule.tqe_prev; *(rule)->nextRule.tqe_prev = (rule)->nextRule.tqe_next; (&netIfPtr->inRateLimitHead)->tqh_count--;} while (0);
                                        do { if (((rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rule); (rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                                }

                                while ((rule = ((&netIfPtr->outRateLimitHead)->tqh_first))) {
                                        do { if (((rule)->nextRule.tqe_next) != ((void *)0)) (rule)->nextRule.tqe_next->nextRule.tqe_prev = (rule)->nextRule.tqe_prev; else (&netIfPtr->outRateLimitHead)->tqh_last = (rule)->nextRule.tqe_prev; *(rule)->nextRule.tqe_prev = (rule)->nextRule.tqe_next; (&netIfPtr->outRateLimitHead)->tqh_count--;} while (0);
                                        do { if (((rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rule); (rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                                }


                                while ((rule=((&netIfPtr->mnqHead)->tqh_first))) {
                                        do { if (((rule)->nextRule.tqe_next) != ((void *)0)) (rule)->nextRule.tqe_next->nextRule.tqe_prev = (rule)->nextRule.tqe_prev; else (&netIfPtr->mnqHead)->tqh_last = (rule)->nextRule.tqe_prev; *(rule)->nextRule.tqe_prev = (rule)->nextRule.tqe_next; (&netIfPtr->mnqHead)->tqh_count--;} while (0);
                                        do { if (((rule)->nextRule.tqe_next = (&DrvTbl.freeList.aclRule)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.aclRule)->tqh_first->nextRule.tqe_prev = &(rule)->nextRule.tqe_next; else (&DrvTbl.freeList.aclRule)->tqh_last = &(rule)->nextRule.tqe_next; (&DrvTbl.freeList.aclRule)->tqh_first = (rule); (rule)->nextRule.tqe_prev = &(&DrvTbl.freeList.aclRule)->tqh_first; (&DrvTbl.freeList.aclRule)->tqh_count++;} while (0);
                                }
                        }
                do {} while (0);
        }

        {
                rtl8651_tblDrv_ipIntfEntry_t * ipIntfPtr;
                rtl8651_tblDrv_ipIntfIpAddrEntry_t * ipIntfIpPtr;
                rtl8651_tblDrv_arpEntry_t * tempArpPtr;
                rtl8651_tblDrv_networkIntfTable_t *netIfPtr;


                for(index=0,netIfPtr=&DrvTbl.netIface[0]; index< rtl8651_tblDrvPara.networkIntfTableSize; index++,netIfPtr++) {
                        if(netIfPtr->valid == 1) {
                                while (((&(netIfPtr->IpHead))->slh_first)) {

                                        ipIntfPtr = ((&(netIfPtr->IpHead))->slh_first);
                                        do { (&(netIfPtr->IpHead))->slh_first = (&(netIfPtr->IpHead))->slh_first->nextIp.sle_next; } while (0);
                                        do { (ipIntfPtr)->nextIp.sle_next = (&DrvTbl.freeList.ipIface)->slh_first; (&DrvTbl.freeList.ipIface)->slh_first = (ipIntfPtr); } while (0);

                                        while(((&ipIntfPtr->ipAddr)->slh_first)) {
                                                ipIntfIpPtr = ((&ipIntfPtr->ipAddr)->slh_first);
                                                do { (&(ipIntfPtr->ipAddr))->slh_first = (&(ipIntfPtr->ipAddr))->slh_first->nextIpAddr.sle_next; } while (0);
                                                do { (ipIntfIpPtr)->nextIpAddr.sle_next = (&DrvTbl.freeList.ipAddr)->slh_first; (&DrvTbl.freeList.ipAddr)->slh_first = (ipIntfIpPtr); } while (0);
                                        }

                                        while(((&(ipIntfPtr->localServer))->slh_first)) {
                                                ipIntfIpPtr = ((&(ipIntfPtr->localServer))->slh_first);
                                                do { (&(ipIntfPtr->localServer))->slh_first = (&(ipIntfPtr->localServer))->slh_first->nextIpAddr.sle_next; } while (0);
                                                do { (ipIntfIpPtr)->nextIpAddr.sle_next = (&DrvTbl.freeList.ipAddr)->slh_first; (&DrvTbl.freeList.ipAddr)->slh_first = (ipIntfIpPtr); } while (0);
                                        }

                                        while((tempArpPtr=((&ipIntfPtr->nextArp)->slh_first))) {
                                                do { (&ipIntfPtr->nextArp)->slh_first = (&ipIntfPtr->nextArp)->slh_first->next.sle_next; } while (0);
                                                do { (tempArpPtr)->next.sle_next = (&DrvTbl.freeList.arp)->slh_first; (&DrvTbl.freeList.arp)->slh_first = (tempArpPtr); (&DrvTbl.freeList.arp)->slh_count++;} while (0);
                                        }
                                }
                        }
                }
                entry = 0;
                for((ipIntfPtr) = (&DrvTbl.freeList.ipIface)->slh_first; (ipIntfPtr); (ipIntfPtr) = (ipIntfPtr)->nextIp.sle_next)
                        entry ++;
                for((ipIntfIpPtr) = (&DrvTbl.freeList.ipAddr)->slh_first; (ipIntfIpPtr); (ipIntfIpPtr) = (ipIntfIpPtr)->nextIpAddr.sle_next)
                        entry ++;
                do {} while (0);
                do {} while (0);
        }





        {
                rtl8651_tblDrv_protocolBasedNat_t *pbNat;

                while( (pbNat = ((&DrvTbl.inuseList.protocolBasedNat)->slh_first))!=((void *)0) )
                {
                        do { (&DrvTbl.inuseList.protocolBasedNat)->slh_first = (&DrvTbl.inuseList.protocolBasedNat)->slh_first->next.sle_next; } while (0);
                        do { (pbNat)->next.sle_next = (&DrvTbl.freeList.protocolBasedNat)->slh_first; (&DrvTbl.freeList.protocolBasedNat)->slh_first = (pbNat); } while (0);
                }
                entry = 0;
                for((pbNat) = (&DrvTbl.freeList.protocolBasedNat)->slh_first; (pbNat); (pbNat) = (pbNat)->next.sle_next)
                        entry++;
                do {} while (0);
        }




        {
                rtl8651_tblDrv_nextHopEntry_t *tmp_t;
                while((tmp_t=((&DrvTbl.inuseList.nexthop)->slh_first))) {
                        do { (&DrvTbl.inuseList.nexthop)->slh_first = (&DrvTbl.inuseList.nexthop)->slh_first->next.sle_next; } while (0);
                        do { (tmp_t)->next.sle_next = (&DrvTbl.freeList.nexthop)->slh_first; (&DrvTbl.freeList.nexthop)->slh_first = (tmp_t); } while (0);
                }
                entry = 0;
                for((tmp_t) = (&DrvTbl.freeList.nexthop)->slh_first; (tmp_t); (tmp_t) = (tmp_t)->next.sle_next)
                        entry ++;
                do {} while (0);
        }




        {
                rtl8651_tblDrv_ipUnnumbered_t *ipUnnumber;

                while( (ipUnnumber = ((&DrvTbl.inuseList.ipUnnumber)->slh_first))!=((void *)0) )
                {
                        do { (&DrvTbl.inuseList.ipUnnumber)->slh_first = (&DrvTbl.inuseList.ipUnnumber)->slh_first->nextIpUnnumberEntry.sle_next; } while (0);
                        do { (ipUnnumber)->nextIpUnnumberEntry.sle_next = (&DrvTbl.freeList.freeIpUnnumber)->slh_first; (&DrvTbl.freeList.freeIpUnnumber)->slh_first = (ipUnnumber); } while (0);
                }
                entry = 0;
                for((ipUnnumber) = (&DrvTbl.freeList.freeIpUnnumber)->slh_first; (ipUnnumber); (ipUnnumber) = (ipUnnumber)->nextIpUnnumberEntry.sle_next)
                        entry++;
                do {} while (0);
        }
# 27379 "rtl8651_tblDrv.c"
        return 0;
}



int32 rtl8651_layer3_init(void)
{
        uint32 entry=0,i, netIdx;
        rtl8651_tblDrv_networkIntfTable_t *netIfPtr;


        pureSoftFwd = 0;
        for(i=0; i< 16; i++)
                _gidxRegister[i]=-1;

        for (i=0;i<32 -1;i++){
                rtDynamicPolicy[i].timenext=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[i+1];
                rtDynamicPolicy[i+1].timeprev=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[i];
        }
        rtDynamicPolicy[0].timeprev=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[32 -1];
        rtDynamicPolicy[32 -1].timenext=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[0];
        rtDynamicPolicyHeadPtr=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[0];
        lanSideIpUnnumberedWan = ((void *)0);
        lanSideIpUnnumberedLan = ((void *)0);
        rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_ACL_budget = (125 - 64);
        rtl8651_ipUnnumberGlobalCtrlBlock.ip_unnumber_LS_budget = 8;
        naptIpCount = localServerCount = natIpCount = 0;
        aclMode = 0x00;
        rtEntry = 0;
        arpAgingTime = 30;

        _rtl8651_multiple_dsid = 0;
        _rtl8651_pppoe_count = 0;





        memset((int8 *)DrvTbl.iptbl, 0, sizeof(rtl8651_tblDrv_ipEntry_t)*16);

        memset((int8 *)AsicTableUsage.arp, 0, 64*sizeof(rtl8651_tblDrv_arpAsicArrangementEntry_t));

        memset((int8 *)DrvTbl.netIface, 0, rtl8651_tblDrvPara.networkIntfTableSize*sizeof(rtl8651_tblDrv_networkIntfTable_t));
        for(netIdx=0,netIfPtr=DrvTbl.netIface; netIdx< rtl8651_tblDrvPara.networkIntfTableSize; netIdx++, netIfPtr++){
                { (&(netIfPtr->IpHead))->slh_first = ((void *)0); };
                { (&(netIfPtr->nextNat))->slh_first = ((void *)0); };
                { (&(netIfPtr->nextNaptServerPort))->slh_first = ((void *)0); };
                do { (&netIfPtr->inAclHead)->tqh_count=0; (&netIfPtr->inAclHead)->tqh_first = ((void *)0); (&netIfPtr->inAclHead)->tqh_last = &(&netIfPtr->inAclHead)->tqh_first; } while (0);
                do { (&netIfPtr->outAclHead)->tqh_count=0; (&netIfPtr->outAclHead)->tqh_first = ((void *)0); (&netIfPtr->outAclHead)->tqh_last = &(&netIfPtr->outAclHead)->tqh_first; } while (0);
        }

        memset((int8 *)DrvTbl.route, 0, rtl8651_tblDrvPara.routingTableSize*sizeof(rtl8651_tblDrv_routeTable_t));


        ipClassCount = 0;
        cur_rt_t = &DrvTbl.route[8 -2];
        memset(ipClassABMonitorTable, 0,sizeof(ipClassABMonitorTable_t)*10);
        _rtl8651_dsid = 0;


        DrvTbl.macACInfo->def_permit = 1;
        DrvTbl.macACInfo->enable = 0;
        do { (&DrvTbl.macACInfo->macAccessControl)->tqh_count=0; (&DrvTbl.macACInfo->macAccessControl)->tqh_first = ((void *)0); (&DrvTbl.macACInfo->macAccessControl)->tqh_last = &(&DrvTbl.macACInfo->macAccessControl)->tqh_first; } while (0);


        _rtl8651_setAsicAclDefaultRule((126), 0x02);
        _rtl8651_setAsicAclDefaultRule((127), 0x03);
        _rtl8651_setAsicAclDefaultRule((125), 0x01);


        rtl8651_installPortStatusChangeNotifier(rtl8651_updatePortStatus);
        rtl8651_installFDBEntryChangeNotifier(_rtl8651_syncL2Entrychange);


        memset(rateLimitCounterRegisterTable, 0, sizeof(rtl8651_tblDrv_rateLimitCounter_t)*10);

        bzero(&tunnel, sizeof(rtl8651_tblDrv_miiTunneling_t));
# 27480 "rtl8651_tblDrv.c"
        for(entry=0; entry<rtl8651_tblDrvPara.mCastTblSize; entry++)
                do { (&DrvTbl.inuseList.mCastTbl[entry])->tqh_first = ((void *)0); (&DrvTbl.inuseList.mCastTbl[entry])->tqh_last = &(&DrvTbl.inuseList.mCastTbl[entry])->tqh_first; } while (0);


        bzero(DrvTbl.pppoe, (sizeof(rtl8651_tblDrv_pppTable_t)*(rtl8651_tblDrvPara.pptpSize+rtl8651_tblDrvPara.l2tpSize+8)));
        DrvTbl.pptp = &DrvTbl.pppoe[8];
        DrvTbl.l2tp = &DrvTbl.pppoe[8 + rtl8651_tblDrvPara.pptpSize];




        {

                uint32 entry;
                bzero(DrvTbl.dynamicPolicy.hashTable, sizeof(_rtl8651_tblDrvPolicy_t *)*rtl8651_tblDrvPara.dynamicPolicy);
                bzero(DrvTbl.dynamicPolicy.policy_t, sizeof(_rtl8651_tblDrvPolicy_t)*rtl8651_tblDrvPara.dynamicPolicy);
                do { (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (void *)(&DrvTbl.dynamicPolicy.dyHead); (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (void *)(&DrvTbl.dynamicPolicy.dyHead); } while (0);
                for(entry=0; entry<rtl8651_tblDrvPara.dynamicPolicy; entry++)
                        do { (&DrvTbl.dynamicPolicy.policy_t[entry])->nextTime_t.cqe_next = (&DrvTbl.dynamicPolicy.dyHead)->cqh_first; (&DrvTbl.dynamicPolicy.policy_t[entry])->nextTime_t.cqe_prev = (void *)(&DrvTbl.dynamicPolicy.dyHead); if ((&DrvTbl.dynamicPolicy.dyHead)->cqh_last == (void *)(&DrvTbl.dynamicPolicy.dyHead)) (&DrvTbl.dynamicPolicy.dyHead)->cqh_last = (&DrvTbl.dynamicPolicy.policy_t[entry]); else (&DrvTbl.dynamicPolicy.dyHead)->cqh_first->nextTime_t.cqe_prev = (&DrvTbl.dynamicPolicy.policy_t[entry]); (&DrvTbl.dynamicPolicy.dyHead)->cqh_first = (&DrvTbl.dynamicPolicy.policy_t[entry]); } while (0);
        }




        do { (&DrvTbl.inuseList.policyRoute)->tqh_first = ((void *)0); (&DrvTbl.inuseList.policyRoute)->tqh_last = &(&DrvTbl.inuseList.policyRoute)->tqh_first; } while (0);

        {

                bzero(rtStaticPolicy, sizeof(_rtl8651_tblDrvPolicyRoute_t)*32);
                bzero(rtDemandRouteTable, sizeof(rtl8651_tblDrvDemandRoute_t) * 32);
                bzero(rtDynamicPolicy, sizeof(_rtl8651_tblDrvPolicyRoute_t)*32);
                bzero(rtHashTable, sizeof(_rtl8651_tblDrvPolicyRoute_t *)*32);
                for (i=0;i<32 -1;i++)
                {
                        rtDynamicPolicy[i].timenext=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[i+1];
                        rtDynamicPolicy[i+1].timeprev=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[i];
                }
                rtDynamicPolicy[0].timeprev=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[32 -1];
                rtDynamicPolicy[32 -1].timenext=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[0];
                rtDynamicPolicyHeadPtr=(_rtl8651_tblDrvPolicyRoute_t *)&rtDynamicPolicy[0];
        }




        {
                rtl8651_tblDrv_rateLimit_t *rl_t = DrvTbl.rateLimit;
                for(entry=0; entry<32; entry++, rl_t++)
                {
                        rl_t->groupId = 0;
                        rl_t->queueType = 0;
                }
        }





        rtl8651_gVlanIDforPassthru = (4096+1);
        rtl8651_gRefCountofVlanforPassthru = 0;




        rtl8651_l2protoPassThrough &= ~(1<<0);
        rtl8651_drvDropUnknownPppoePADT = 0;
        memset(&rtl8651_knownPppoePassthruEthHdr,0,sizeof(struct ether_header));


        rtl8651_gPPPoEExternalVlanIndex = 8;
        memset(&rtl8651_gPPPoEExternalGatewayMAC,0,sizeof(rtl8651_gPPPoEExternalGatewayMAC));
        rtl8651_gPPPoEPassthruVlanID = (4096+1);



        _rtl8651_arrangeAllACL();





        rtl8651_l2protoPassThrough &= ~(1<<1);

        rtl8651_gIPv6ExternalVlanIndex = 8;
        memset(&rtl8651_gIPv6ExternalGatewayMAC, 0, sizeof(rtl8651_gIPv6ExternalGatewayMAC));
        rtl8651_gIPv6PassthruVlanID = (4096+1);
        rtl8651_pbv_ipv6passthru = 7;



        rtl8651_l2protoPassThrough &= ~(1<<2);

        rtl8651_gIPXExternalVlanIndex = 8;
        memset(&rtl8651_gIPXExternalGatewayMAC, 0, sizeof(rtl8651_gIPXExternalGatewayMAC));
        rtl8651_gIPXPassthruVlanID = (4096+1);
        rtl8651_pbv_ipxpassthru = 1;



        rtl8651_l2protoPassThrough &= ~(1<<3);

        rtl8651_gNetbiosExternalVlanIndex = 8;
        memset(&rtl8651_gNetbiosExternalGatewayMAC, 0, sizeof(rtl8651_gNetbiosExternalGatewayMAC));
        rtl8651_gNetbiosPassthruVlanID = (4096+1);
        rtl8651_pbv_netbiospassthru = 2;





        rtl8651_drvProtocolBasedNatEnable = 0;

        p_mtuHandler = ((void *)0);


        _rtl8651_updateDefaultRoute();


        _rtl8651_init_nexthopEntry(0);






        memset( rtl8651_sessionHangUp, 0, sizeof( rtl8651_sessionHangUp ) );
        memset( &rtl8651AsicAge, 0, sizeof( rtl8651AsicAge ) );
        memset( &rtl8651GlobalControl, 0, sizeof( rtl8651GlobalControl ) );

        return 0;
}



int32 rtl8651_layer4_alloc(void){
        int32 i;


        { (AsicTableUsage.serverPort) = (rtl8651_tblDrv_serverPortAsicArrangementEntry_t *)rtlglue_malloc((16) * sizeof(rtl8651_tblDrv_serverPortAsicArrangementEntry_t)); if(!(AsicTableUsage.serverPort)){ printk("MEM alloc failed at line %d\n", 27618); return -1; } };
        { (AsicTableUsage.alg) = (rtl8651_tblDrv_algAsicArrangementEntry_t *)rtlglue_malloc((128) * sizeof(rtl8651_tblDrv_algAsicArrangementEntry_t)); if(!(AsicTableUsage.alg)){ printk("MEM alloc failed at line %d\n", 27619); return -1; } };
        { (DrvTbl.tcpudp) = (rtl8651DrvNaptLine_t *)rtlglue_malloc((1024) * sizeof(rtl8651DrvNaptLine_t)); if(!(DrvTbl.tcpudp)){ printk("MEM alloc failed at line %d\n", 27620); return -1; } };
        { (DrvTbl.icmp) = (rtl8651_tblDrv_naptIcmpFlowEntry_t* *)rtlglue_malloc((32) * sizeof(rtl8651_tblDrv_naptIcmpFlowEntry_t*)); if(!(DrvTbl.icmp)){ printk("MEM alloc failed at line %d\n", 27621); return -1; } };
        { (rtl8651NaptIcmpBackwardCollisionCountTable) = (uint16 *)rtlglue_malloc((32) * sizeof(uint16)); if(!(rtl8651NaptIcmpBackwardCollisionCountTable)){ printk("MEM alloc failed at line %d\n", 27622); return -1; } };
        { (rtl8651NaptIcmpFlowNumberTable) = (uint16 *)rtlglue_malloc((32) * sizeof(uint16)); if(!(rtl8651NaptIcmpFlowNumberTable)){ printk("MEM alloc failed at line %d\n", 27623); return -1; } };
        { (rtl8651NaptIcmpFlowNonAsicNumberTable) = (uint16 *)rtlglue_malloc((32) * sizeof(uint16)); if(!(rtl8651NaptIcmpFlowNonAsicNumberTable)){ printk("MEM alloc failed at line %d\n", 27624); return -1; } };

        { (rtl8651DmzHost) = (rtl8651DmzHostStruct_t *)rtlglue_malloc((rtl8651_tblDrvPara.dmzHostsNum) * sizeof(rtl8651DmzHostStruct_t)); if(!(rtl8651DmzHost)){ printk("MEM alloc failed at line %d\n", 27626); return -1; } };
        { (_rtl8651_udpSizeThreshValue) = (uint16 *)rtlglue_malloc((rtl8651_tblDrvPara.dialSessionNumber) * sizeof(uint16)); if(!(_rtl8651_udpSizeThreshValue)){ printk("MEM alloc failed at line %d\n", 27627); return -1; } };
        { (rtl8651_wanStatus) = (int *)rtlglue_malloc((rtl8651_tblDrvPara.dialSessionNumber) * sizeof(int)); if(!(rtl8651_wanStatus)){ printk("MEM alloc failed at line %d\n", 27628); return -1; } };




        {
                rtl8651_tblDrv_naptServerPortEntry_t * tempNaptServerPortPtr;
                { (tempNaptServerPortPtr) = (rtl8651_tblDrv_naptServerPortEntry_t *)rtlglue_malloc((rtl8651_tblDrvPara.naptServerPortEntryNumber) * sizeof(rtl8651_tblDrv_naptServerPortEntry_t)); if(!(tempNaptServerPortPtr)){ printk("MEM alloc failed at line %d\n", 27635); return -1; } };
                { (&DrvTbl.freeList.serverPort)->slh_first = ((void *)0); };
                for(i=0; i<rtl8651_tblDrvPara.naptServerPortEntryNumber; i++)
                        do { (&tempNaptServerPortPtr[i])->nextServerPort.sle_next = (&DrvTbl.freeList.serverPort)->slh_first; (&DrvTbl.freeList.serverPort)->slh_first = (&tempNaptServerPortPtr[i]); } while (0);
        }



        {
                rtl8651_tblDrv_natEntry_t * tempNatMappintPtr;
                { (tempNatMappintPtr) = (rtl8651_tblDrv_natEntry_t *)rtlglue_malloc((rtl8651_tblDrvPara.natSize) * sizeof(rtl8651_tblDrv_natEntry_t)); if(!(tempNatMappintPtr)){ printk("MEM alloc failed at line %d\n", 27645); return -1; } };
                { (&DrvTbl.freeList.natMapping)->slh_first = ((void *)0); };
                for(i=0; i<rtl8651_tblDrvPara.natSize; i++)
                        do { (&tempNatMappintPtr[i])->nextNatEntry.sle_next = (&DrvTbl.freeList.natMapping)->slh_first; (&DrvTbl.freeList.natMapping)->slh_first = (&tempNatMappintPtr[i]); } while (0);
        }



        {
                rtl8651_tblDrv_algEntry_t * tempAlgPtr;
                { (tempAlgPtr) = (rtl8651_tblDrv_algEntry_t *)rtlglue_malloc((rtl8651_tblDrvPara.algSize) * sizeof(rtl8651_tblDrv_algEntry_t)); if(!(tempAlgPtr)){ printk("MEM alloc failed at line %d\n", 27655); return -1; } };
                { (&DrvTbl.freeList.alg)->slh_first = ((void *)0); };
                for(i=0; i<rtl8651_tblDrvPara.algSize; i++)
                        do { (&tempAlgPtr[i])->nextAlgEntry.sle_next = (&DrvTbl.freeList.alg)->slh_first; (&DrvTbl.freeList.alg)->slh_first = (&tempAlgPtr[i]); } while (0);
        }



        {
                rtl8651_tblDrv_naptTcpUdpFlowEntry_t *_naptFlowPool;
                int wanted, allocated;

                wanted = rtl8651_tblDrvPara.naptTcpUdpFlowSize;
                allocated = 0;
                do { (&DrvTbl.freeList.tcpudp)->tqh_count=0; (&DrvTbl.freeList.tcpudp)->tqh_first = ((void *)0); (&DrvTbl.freeList.tcpudp)->tqh_last = &(&DrvTbl.freeList.tcpudp)->tqh_first; } while (0);

                while( allocated < wanted )
                {
                        int allocMore;
                        allocMore = wanted - allocated;




                        if ( allocMore > 512 ) allocMore = 512;


                        { (_naptFlowPool) = (rtl8651_tblDrv_naptTcpUdpFlowEntry_t *)rtlglue_malloc((allocMore) * sizeof(rtl8651_tblDrv_naptTcpUdpFlowEntry_t)); if(!(_naptFlowPool)){ printk("MEM alloc failed at line %d\n", 27682); return -1; } };
                        memset( _naptFlowPool, 0,sizeof(rtl8651_tblDrv_naptTcpUdpFlowEntry_t)*allocMore);

                        for(i=0; i<allocMore; i++)
                                do { if (((&_naptFlowPool[i])->next.tqe_next = (&DrvTbl.freeList.tcpudp)->tqh_first) != ((void *)0)) (&DrvTbl.freeList.tcpudp)->tqh_first->next.tqe_prev = &(&_naptFlowPool[i])->next.tqe_next; else (&DrvTbl.freeList.tcpudp)->tqh_last = &(&_naptFlowPool[i])->next.tqe_next; (&DrvTbl.freeList.tcpudp)->tqh_first = (&_naptFlowPool[i]); (&_naptFlowPool[i])->next.tqe_prev = &(&DrvTbl.freeList.tcpudp)->tqh_first; (&DrvTbl.freeList.tcpudp)->tqh_count++;} while (0);

                        allocated += allocMore;
                }
        }



        {
                rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr;
                { (tempNaptIcmpFlowPtr) = (rtl8651_tblDrv_naptIcmpFlowEntry_t *)rtlglue_malloc((1) * sizeof(rtl8651_tblDrv_naptIcmpFlowEntry_t)); if(!(tempNaptIcmpFlowPtr)){ printk("MEM alloc failed at line %d\n", 27696); return -1; } };
                DrvTbl.freeList.icmp = tempNaptIcmpFlowPtr;
                for(i=1; i<rtl8651_tblDrvPara.naptIcmpFlowSize; i++) {
                        tempNaptIcmpFlowPtr->next = (rtl8651_tblDrv_naptIcmpFlowEntry_t *) rtlglue_malloc(sizeof(rtl8651_tblDrv_naptIcmpFlowEntry_t));
                        do {} while (0);
                        tempNaptIcmpFlowPtr = tempNaptIcmpFlowPtr->next;
                }
                tempNaptIcmpFlowPtr->next = (rtl8651_tblDrv_naptIcmpFlowEntry_t *)((void *)0);
        }




        {
                uint8 httpHdrPattern[5] = "\r\n\r\n";
                uint8 httpHostpattern[9] = "\r\nHost: ";
                uint8 httpGetPattern[6] = "GET \\";
                uint8 httpGet1Pattern[5] = "GET ";
                uint8 httphttpPattern[8] = "http://";
                uint8 httpPathGetPattern[5] = "GET /";
                uint16 *_temp2, *_temp4;
                int8 *_temp, *_temp3;
                int32 index;


                _urlFilter.urlFilterCount = 0;
                mBuf_getBMjmpTable(httpHdrPattern, _urlFilter.urlHdrJmpTbl, 4, 1);
                mBuf_getBMjmpTable(httpHostpattern, _urlFilter.urlHostJmpTbl, 8, 1);
                mBuf_getBMjmpTable(httpGetPattern, _urlFilter.urlGetJmpTbl, 5, 1);
                mBuf_getBMjmpTable(httpGet1Pattern, _urlFilter.urlGet1JmpTbl, 4, 1);
                mBuf_getBMjmpTable(httphttpPattern, _urlFilter.urlhttpJmpTbl, 7, 0);
                mBuf_getBMjmpTable(httpPathGetPattern, _urlFilter.pathGetJmpTbl, 5, 1);

                _urlFilter.urlFilterDB = (int8 **)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(int8 *));
                if (_urlFilter.urlFilterDB == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27731, "urlFilterDB memory allocation failed."); while(1);} while (0);;
                _urlFilter.pathFilterDB = (int8 **)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(int8 *));
                if (_urlFilter.pathFilterDB == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27734, "pathFilterDB memory allocation failed."); while(1);} while (0);;
                _urlFilter.urlFilterJmpTbl = (uint16 **)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(uint16 *));
                if (_urlFilter.urlFilterJmpTbl == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27737, "urlFilterJmpTbl memory allocation failed."); while(1);} while (0);;
                _urlFilter.pathFilterJmpTbl = (uint16 **)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(uint16 *));
                if (_urlFilter.pathFilterJmpTbl == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27740, "pathFilterJmpTbl memory allocation failed."); while(1);} while (0);;
                _urlFilter.urlFilterStrLen = (int32 *)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(int32));
                if (_urlFilter.urlFilterStrLen == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27743, "urlFilterStrLen memory allocation failed."); while(1);} while (0);;
                _urlFilter.pathFilterStrLen = (int32 *)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(int32));
                if (_urlFilter.pathFilterStrLen == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27746, "pathFilterStrLen memory allocation failed."); while(1);} while (0);;
                _urlFilter.urlExactlyMatch = (uint8 *)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(uint8));
                if (_urlFilter.urlExactlyMatch == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27749, "urlExactlyMatch memory allocation failed."); while(1);} while (0);;
                _urlFilter.pathExactlyMatch = (uint8 *)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(uint8));
                if (_urlFilter.pathExactlyMatch == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27752, "pathExactlyMatch memory allocation failed."); while(1);} while (0);;
                _urlFilter.sessionId = (uint32 *)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(uint32));
                if (_urlFilter.sessionId == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27755, "sessionId memory allocation failed."); while(1);} while (0);;

                _urlFilter.ruleType = (uint8 *)rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*sizeof(uint8));
                if (_urlFilter.ruleType == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27759, "ruleType memory allocation failed."); while(1);} while (0);;


                do {} while (0);


                _temp = (int8 *) rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*rtl8651_tblDrvPara.urlfilterStringLen);
                if (_temp == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27767, "_temp memory allocation failed."); while(1);} while (0);;
                _temp2 =(uint16 *) rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*256*sizeof(uint16));
                if (_temp2 == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27770, "_temp2 memory allocation failed."); while(1);} while (0);;
                _temp3 = (int8 *) rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*rtl8651_tblDrvPara.pathfilterStringLen);
                if (_temp3 == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27773, "_temp3 memory allocation failed."); while(1);} while (0);;
                _temp4 =(uint16 *) rtlglue_malloc((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*256*sizeof(uint16));
                if (_temp4 == ((void *)0))
                        do {printk(" [= !! BUG !! =] at %s line %d\n\t=> Cause: %s\n\t=>-- system Halt\n", __FUNCTION__, 27776, "_temp4 memory allocation failed."); while(1);} while (0);;
                do {} while (0);

                memset( _temp, 0, (rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*rtl8651_tblDrvPara.urlfilterStringLen);
                memset( _temp2, 0, ((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*256*sizeof(uint16)));
                memset( _temp3, 0, (rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*rtl8651_tblDrvPara.pathfilterStringLen);
                memset( _temp4, 0, ((rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber)*256*sizeof(uint16)));
                for(index=0; index<(rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber); index++) {
                        _urlFilter.urlFilterDB[index] = &_temp[index*rtl8651_tblDrvPara.urlfilterStringLen];
                        _urlFilter.urlFilterJmpTbl[index] = &_temp2[index*256];
                        _urlFilter.urlFilterStrLen[index] = 0;
                        _urlFilter.urlExactlyMatch[index] = 0;
                        _urlFilter.pathFilterDB[index] = &_temp3[index*rtl8651_tblDrvPara.pathfilterStringLen];
                        _urlFilter.pathFilterJmpTbl[index] = &_temp4[index*256];
                        _urlFilter.pathFilterStrLen[index] = 0;
                        _urlFilter.pathExactlyMatch[index] = 0;
                        _urlFilter.sessionId[index] = 0;

                        _urlFilter.ruleType[index] = 0;

                        _urlFilter.callBackFunc = ((void *)0);
                        { (&(_urlFilter.pktFilter[index]))->slh_first = ((void *)0); };
                }
        }




        {
                urlPktFiltering_t *tmp_t;
                { (&DrvTbl.freeList.freeUrlPktFilter)->slh_first = ((void *)0); };
                { (&DrvTbl.inuseList.urlPktFilter)->slh_first = ((void *)0); };
                { (tmp_t) = (urlPktFiltering_t *)rtlglue_malloc((rtl8651_tblDrvPara.urlPktfilterDBSize) * sizeof(urlPktFiltering_t)); if(!(tmp_t)){ printk("MEM alloc failed at line %d\n", 27808); return -1; } };
                for(i=0; i<rtl8651_tblDrvPara.urlPktfilterDBSize; i++)
                        do { (&tmp_t[i])->next.sle_next = (&DrvTbl.freeList.freeUrlPktFilter)->slh_first; (&DrvTbl.freeList.freeUrlPktFilter)->slh_first = (&tmp_t[i]); } while (0);
        }




        return 0;
}

int32 rtl8651_layer4_collect(void) {
        int32 i;





        {
                rtl8651_tblDrv_networkIntfTable_t *netif_t;
                rtl8651_tblDrv_naptServerPortEntry_t *delsp_t;
                uint32 entry = 0;

                for(i=0, netif_t=DrvTbl.netIface; i<rtl8651_tblDrvPara.networkIntfTableSize;i++, netif_t++) {
                        if (netif_t->valid == 0)
                                continue;
                        while ((delsp_t=((&netif_t->nextNaptServerPort)->slh_first))) {
                                do { (&netif_t->nextNaptServerPort)->slh_first = (&netif_t->nextNaptServerPort)->slh_first->nextServerPort.sle_next; } while (0);
                                do { (delsp_t)->nextServerPort.sle_next = (&DrvTbl.freeList.serverPort)->slh_first; (&DrvTbl.freeList.serverPort)->slh_first = (delsp_t); } while (0);
                        }
                }
                for((delsp_t) = (&DrvTbl.freeList.serverPort)->slh_first; (delsp_t); (delsp_t) = (delsp_t)->nextServerPort.sle_next)
                        entry ++;
                do {} while (0);
        }

        {
                rtl8651_tblDrv_natEntry_t * tempNatPtr;
                rtl8651_tblDrv_networkIntfTable_t *netIfPtr;

                for(i=0,netIfPtr=&DrvTbl.netIface[0];i<rtl8651_tblDrvPara.networkIntfTableSize;i++,netIfPtr++)
                        if (netIfPtr->valid == 1) {

                                for((tempNatPtr) = (&(netIfPtr->nextNat))->slh_first; (tempNatPtr); (tempNatPtr) = (tempNatPtr)->nextNatEntry.sle_next)
                                        if (tempNatPtr->nextNatEntry.sle_next == ((void *)0))
                                                break;
                                if (tempNatPtr != ((void *)0)) {
                                        tempNatPtr->nextNatEntry.sle_next = DrvTbl.freeList.natMapping.slh_first;
                                        DrvTbl.freeList.natMapping.slh_first = netIfPtr->nextNat.slh_first;
                                }
                                { (&(netIfPtr->nextNat))->slh_first = ((void *)0); };
                        }
                i=0;
                for((tempNatPtr) = (&DrvTbl.freeList.natMapping)->slh_first; (tempNatPtr); (tempNatPtr) = (tempNatPtr)->nextNatEntry.sle_next)
                        i++;
                do {} while (0);
        }
        {
                rtl8651_tblDrv_naptIcmpFlowEntry_t * tempNaptIcmpFlowPtr;
                rtl8651_flushAllNaptConnections();
                do {} while (0);
                i=0;
                tempNaptIcmpFlowPtr = DrvTbl.freeList.icmp;
                while(tempNaptIcmpFlowPtr) {
                        i++;
                        tempNaptIcmpFlowPtr = tempNaptIcmpFlowPtr->next;
                }
                do {} while (0);
        }
        {
                rtl8651_tblDrv_algEntry_t * tempAlgPtr;
                for((tempAlgPtr) = (&DrvTbl.inuseList.alg)->slh_first; (tempAlgPtr); (tempAlgPtr) = (tempAlgPtr)->nextAlgEntry.sle_next)
                        if (tempAlgPtr->nextAlgEntry.sle_next == ((void *)0))
                                break;
                if (tempAlgPtr) {
                        tempAlgPtr->nextAlgEntry.sle_next = DrvTbl.freeList.alg.slh_first;
                        DrvTbl.freeList.alg.slh_first = DrvTbl.inuseList.alg.slh_first;
                        DrvTbl.inuseList.alg.slh_first = ((void *)0);
                }
                i=0;
                for((tempAlgPtr) = (&DrvTbl.freeList.alg)->slh_first; (tempAlgPtr); (tempAlgPtr) = (tempAlgPtr)->nextAlgEntry.sle_next)
                        i++;
                do {} while (0);
        }



        {
                urlPktFiltering_t *pktFilter;

                while( (pktFilter = ((&DrvTbl.inuseList.urlPktFilter)->slh_first))!=((void *)0) )
                {
                        do { (&DrvTbl.inuseList.urlPktFilter)->slh_first = (&DrvTbl.inuseList.urlPktFilter)->slh_first->next.sle_next; } while (0);
                        do { (pktFilter)->next.sle_next = (&DrvTbl.freeList.freeUrlPktFilter)->slh_first; (&DrvTbl.freeList.freeUrlPktFilter)->slh_first = (pktFilter); } while (0);
                }
                i = 0;
                for((pktFilter) = (&DrvTbl.freeList.freeUrlPktFilter)->slh_first; (pktFilter); (pktFilter) = (pktFilter)->next.sle_next)
                        i++;
                do {} while (0);
        }







        return 0;
}



int32 rtl8651_layer4_init(void){
        int32 i,j;


        _enableAdaptiveNAPTfastTimeout=0;
        _enableSmartNaptSwappingByLoad=1;
        _smartNaptSwappingThresholdTcp = 100;
        _smartNaptSwappingThresholdUdp = 5;
        _smartNaptSwappingThresholdCdrouter = 5;
        _adaptiveTimeoutThreshold=100;
        rtl8651ExistedNaptIcmpFlows = 0;
        multiNxtHop = ((void *)0);
        softNaptIp = 0;
        mnqueue_ctrl.wanBandwidth = 0;
        mnQ_enable = 0;
        enable4WayHash = 0;
        def_napt_t = ((void *)0);






        memset(DrvTbl.tcpudp, 0, 1024 * sizeof(rtl8651DrvNaptLine_t));
        memset((char*)rtl8651_wanStatus, 0,rtl8651_tblDrvPara.dialSessionNumber*sizeof(int));
        for(i=0; i < 1024; i++)
                for(j=0; j < 8; j++)
                        { (&DrvTbl.tcpudp[i].list[j])->slh_first = ((void *)0); };

        for(i=0; i<16; i++)
                AsicTableUsage.serverPort[i].valid = 0;


        for(i=0; i<32; i++) {
                DrvTbl.icmp[i] = (rtl8651_tblDrv_naptIcmpFlowEntry_t *)((void *)0);
                rtl8651NaptIcmpBackwardCollisionCountTable[i] = 0;
                rtl8651NaptIcmpFlowNumberTable[i] = 0;
                rtl8651NaptIcmpFlowNonAsicNumberTable[i] = 0;
        }


        for(i=0; i<128; i++)
                AsicTableUsage.alg[i].valid = 0;


        rtl8651_setNaptIcmpTimeout(60);
        rtl8651_setNaptIcmpFastTimeout(2);
        rtl8651_setNaptUdpTimeout(60*15);
        rtl8651_setNaptTcpLongTimeout(24 * 60 * 60);
        rtl8651_setNaptTcpMediumTimeout(600);
        rtl8651_setNaptTcpFastTimeout(20);
        rtl8651_setNaptTcpFinTimeout(20);

        rtl8651_getAsicNaptAutoAddDelete(&naptAutoLearn, ((void *)0));

        { (&DrvTbl.inuseList.alg)->slh_first = ((void *)0); };
        do { (&DrvTbl.inuseList.tcpudp)->tqh_count=0; (&DrvTbl.inuseList.tcpudp)->tqh_first = ((void *)0); (&DrvTbl.inuseList.tcpudp)->tqh_last = &(&DrvTbl.inuseList.tcpudp)->tqh_first; } while (0);
        memset(rtl8651DmzHost, 0, sizeof(rtl8651DmzHostStruct_t)*rtl8651_tblDrvPara.dmzHostsNum);


        for (i=0;i<rtl8651_tblDrvPara.dialSessionNumber;i++)
                _rtl8651_udpSizeThreshValue[i]=0xffff;
# 28005 "rtl8651_tblDrv.c"
        candidateToBeFreed = ((void *)0);





        {


                int32 index;

                for(index=0; index<(rtl8651_tblDrvPara.urlfilterDBSize*rtl8651_tblDrvPara.dialSessionNumber); index++) {
                        memset(_urlFilter.urlFilterDB[index], 0, rtl8651_tblDrvPara.urlfilterStringLen);
                        memset(_urlFilter.urlFilterJmpTbl[index], 0, 256 * sizeof(uint16));
                        _urlFilter.urlFilterStrLen[index] = 0;
                        _urlFilter.urlExactlyMatch[index] = 0;
                        memset(_urlFilter.pathFilterDB[index], 0, rtl8651_tblDrvPara.pathfilterStringLen);
                        memset(_urlFilter.pathFilterJmpTbl[index], 0, 256 * sizeof(uint16));
                        _urlFilter.pathFilterStrLen[index] = 0;
                        _urlFilter.pathExactlyMatch[index] = 0;
                        _urlFilter.sessionId[index] = 0;

                        _urlFilter.ruleType[index] = 0;

                        _urlFilter.callBackFunc = ((void *)0);
                        { (&(_urlFilter.pktFilter[index]))->slh_first = ((void *)0); };
                }

        }






        return 0;

}


int32 rtl8651_log_alloc(void){

        { (_loggingModule) = (uint32 *)rtlglue_malloc((rtl8651_tblDrvPara.dialSessionNumber) * sizeof(uint32)); if(!(_loggingModule)){ printk("MEM alloc failed at line %d\n", 28047); return -1; } };


        { (_rtl8651_acl_drop_nolog) = (uint8 *)rtlglue_malloc((rtl8651_tblDrvPara.dialSessionNumber) * sizeof(uint8)); if(!(_rtl8651_acl_drop_nolog)){ printk("MEM alloc failed at line %d\n", 28050); return -1; } };

        return 0;
}

int32 rtl8651_log_init(void){
        int32 index;


        _pUserLoggingFunc = ((void *)0);


        for(index=0;index<rtl8651_tblDrvPara.dialSessionNumber;index++)
                _loggingModule[index]=0;

        for(index=0;index<rtl8651_tblDrvPara.dialSessionNumber;index++)
                _rtl8651_acl_drop_nolog[index]=0;

        return 0;
}




int32 rtl8651_tblDrvReinit(void) {




        int32 retval;

        do { if((rtl8651_initAsic())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28081); return -1; }}while(0);
        do { if((rtl8651_layer2_collect())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28082); return -1; }}while(0);
        do { if((rtl8651_layer4_collect())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28083); return -1; }}while(0);
        do { if((rtl8651_layer3_collect())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28084); return -1; }}while(0);




        do { if((rtl8651_layer2_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28089); return -1; }}while(0);
        rtl8651_installPortStatusChangeNotifier(rtl8651_updatePortStatus);

        rtl8651_installFDBEntryChangeNotifier(_rtl8651_syncL2Entrychange);
        do { if((rtl8651_layer3_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28093); return -1; }}while(0);
        do { if((rtl8651_layer4_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28094); return -1; }}while(0);
        do { if((rtl8651_log_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28095); return -1; }}while(0);


        _rtl8651_ReinitUrlFilterTrustedUserDb();



        retval = rtl8651_addSpanningTreeInstance(0); do {} while (0);
        retval = rtl8651_addFilterDatabase(0); do {} while (0);
# 28113 "rtl8651_tblDrv.c"
        _sysUpSeconds = 0;
# 28125 "rtl8651_tblDrv.c"
        candidateToBeFreed = ((void *)0);


        (*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))=(((*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))) & ~(1 << 29));
        (*((volatile uint32 *)((0x024 + (0xBD010000 +0x2000)))))=(0xffffff00);
        prevTC1CNT = ((*((volatile uint32 *)((0x024 + (0xBD010000 +0x2000))))));




        (*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))=(( ((*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))) | (1 << 29) ) | (1 << 28));
        (*((volatile uint32 *)((0x034 + (0xBD010000 +0x2000)))))=(((*((volatile uint32 *)((0x034 + (0xBD010000 +0x2000)))))) & ~(1 << 30));

        return 0;
}


int32 rtl8651_tblDrvReset(void) {



        rtl8651_initAsic();


        do { if((rtl8651_layer2_collect())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28149); return -1; }}while(0);
        do { if((rtl8651_layer3_collect())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28150); return -1; }}while(0);
        do { if((rtl8651_layer4_collect())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28151); return -1; }}while(0);


        do { if((rtl8651_layer2_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28154); return -1; }}while(0);
        rtl8651_installPortStatusChangeNotifier(rtl8651_updatePortStatus);

        rtl8651_installFDBEntryChangeNotifier(_rtl8651_syncL2Entrychange);
        do { if((rtl8651_layer3_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28158); return -1; }}while(0);
        do { if((rtl8651_layer4_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28159); return -1; }}while(0);
        do { if((rtl8651_log_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28160); return -1; }}while(0);

        return 0;
}
# 28175 "rtl8651_tblDrv.c"
int32 rtl8651_tblDrvInit(rtl8651_tblDrvInitPara_t * configPara) {
        do { if((rtl8651_initDrvParam(configPara))!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28176); return -1; }}while(0);

        do { if((rtl8651_initAsic())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28178); return -1; }}while(0);
        do { if((rtl8651_layer2_alloc())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28179); return -1; }}while(0);
        do { if((rtl8651_layer3_alloc())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28180); return -1; }}while(0);
        do { if((rtl8651_layer4_alloc())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28181); return -1; }}while(0);
        do { if((rtl8651_log_alloc())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28182); return -1; }}while(0);

        do { if((rtl8651_layer2_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28184); return -1; }}while(0);
        rtl8651_installPortStatusChangeNotifier(rtl8651_updatePortStatus);

        rtl8651_installFDBEntryChangeNotifier(_rtl8651_syncL2Entrychange);
        do { if((rtl8651_layer3_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28188); return -1; }}while(0);
        do { if((rtl8651_layer4_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28189); return -1; }}while(0);
        do { if((rtl8651_log_init())!=0){ printk("Error >>> initialize failed at line %d!!!\n", 28190); return -1; }}while(0);
        _rtl8651_initURLfilter();

        _rtl8651_initUrlFilterTrustedUserDb();




        (*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))=(((*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))) & ~(1 << 29));
        (*((volatile uint32 *)((0x024 + (0xBD010000 +0x2000)))))=(0xffffff00);
        prevTC1CNT = ((*((volatile uint32 *)((0x024 + (0xBD010000 +0x2000))))));




        (*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))=(( ((*((volatile uint32 *)((0x030 + (0xBD010000 +0x2000)))))) | (1 << 29) ) | (1 << 28));
        (*((volatile uint32 *)((0x034 + (0xBD010000 +0x2000)))))=(((*((volatile uint32 *)((0x034 + (0xBD010000 +0x2000)))))) & ~(1 << 30));

        return 0;
}
# 28230 "rtl8651_tblDrv.c"
static int32 _rtl8651_createVlanForPassthru( ether_addr_t *gmac, uint16 *pvid )
{
        rtl8651_tblDrv_vlanTable_t *vlanPtr;
        uint16 vid;
        int i;
        uint32 retval;

        do {} while (0);


        if ( rtl8651_gVlanIDforPassthru == (4096+1) )
        {


                for( i = 0; i < 8; i++ )
                {
                        rtl865x_tblAsicDrv_vlanParam_t try;
                        retval = rtl8651_getAsicVlan( i, &try );
                        if ( try.valid == 0 )
                                break;
                }
                if ( i == 8 )
                {
                        printk("No more availiable VLAN entry!\n");
                        return -2015;
                }

                vid = i+8;

                *pvid = vid;
                rtl8651_gVlanIDforPassthru = vid;

                retval = _rtl8651_addVlan( vid );

                do {} while (0);

                vlanPtr = &DrvTbl.vlan[(vid& (8 -1))];
                vlanPtr->broadcastToCpu = 0;
                vlanPtr->inAclEnd = 125;
                vlanPtr->inAclStart = 125;
                vlanPtr->internal = 0;
                memcpy( &vlanPtr->macAddr, gmac, 6 );
                vlanPtr->macAddrNumber = 1;
                vlanPtr->memberPortMask = 0x1f|0x1e0;
                vlanPtr->outAclEnd = 125;
                vlanPtr->outAclStart = 125;
                vlanPtr->promiscuous = 0;
                vlanPtr->untagPortMask = 0x1f|0x1e0;
                vlanPtr->valid = 1;
                vlanPtr->softRoute = 0;
                vlanPtr->ipAttached = 1;


                _rtl8651_arrangeMulticastPortStatus();

                retval = RTL8651_SETASICVLAN( vlanPtr );
        }
        else
        {

                *pvid = rtl8651_gVlanIDforPassthru;

                retval = 0;
        }


        if ( retval == 0 ) rtl8651_gRefCountofVlanforPassthru++;

        do {} while (0);

        return retval;
}
# 28311 "rtl8651_tblDrv.c"
static int32 _rtl8651_destroyVlanForPassthru( ether_addr_t gmac, uint16 vid )
{
        int32 ret;


        ret = _rtl8651_assignVlanMacAddress( vid, &gmac, 0 );
        do {} while (0);


        rtl8651_gRefCountofVlanforPassthru--;
        do {} while (0);


        if ( rtl8651_gRefCountofVlanforPassthru == 0 )
        {
                ret = _rtl8651_delVlan( vid );
                rtl8651_gVlanIDforPassthru = (4096+1);
        }
        else
        {

                ret = 0;
        }

        return ret;
}
# 28349 "rtl8651_tblDrv.c"
int32 rtl8651_transformPassthruVlanId( uint32 oldVlanIdx, uint32* newVlanIdx )
{
        int32 retval = 0;

        rtlglue_drvMutexLock();

        if ( ( rtl8651_l2protoPassThrough & (1<<0) ) &&
             oldVlanIdx == (rtl8651_gPPPoEPassthruVlanID& (8 -1)) )
        {
                *newVlanIdx = rtl8651_gPPPoEExternalVlanIndex;
        }
        else if ( ( rtl8651_l2protoPassThrough & (1<<1) ) &&
                  oldVlanIdx == (rtl8651_gIPv6PassthruVlanID& (8 -1)) )
        {
                *newVlanIdx = rtl8651_gIPv6ExternalVlanIndex;
        }
        else if ( ( rtl8651_l2protoPassThrough & (1<<2) ) &&
                  oldVlanIdx == (rtl8651_gIPXPassthruVlanID& (8 -1)) )
        {
                *newVlanIdx = rtl8651_gIPXExternalVlanIndex;
        }
        else if ( ( rtl8651_l2protoPassThrough & (1<<3) ) &&
                  oldVlanIdx == (rtl8651_gNetbiosPassthruVlanID& (8 -1)) )
        {
                *newVlanIdx = rtl8651_gNetbiosExternalVlanIndex;
        }
        else
                retval = -1;

        rtlglue_drvMutexUnlock();

        return retval;
}







int8 rtl8651_EnablePppoePassthru( int8 enable )
{
        int8 prevValue;
        int32 retval;


        rtlglue_drvMutexLock();

        prevValue = rtl8651_l2protoPassThrough & (1<<0) ? 1 : 0;

        if ( enable )
                rtl8651_l2protoPassThrough |= (1<<0);
        else
                rtl8651_l2protoPassThrough &= ~(1<<0);



        if ( prevValue == 1 && enable == 0 )
        {

                retval = _rtl8651_destroyProtocolBasedVLANforPPPoEPassthru();
        }
        else if ( prevValue == 0 && enable == 1 )
        {

                retval = _rtl8651_createProtocolBasedVLANforPPPoEPassthru();
        }





        _rtl8651_arrangeAllACL();


        rtlglue_drvMutexUnlock();

        return prevValue;
}







int32 rtl8651_getPppoePassthruVid()
{
        int32 retval;

        rtlglue_drvMutexLock();

        if ( rtl8651_l2protoPassThrough & (1<<0) )
                retval = rtl8651_gPPPoEPassthruVlanID;
        else
                retval = -1;

        rtlglue_drvMutexUnlock();

        return retval;
}
# 28460 "rtl8651_tblDrv.c"
int8 rtl8651_enableDropUnknownPppoePADT( int8 enable )
{
        int8 prevValue;
        int i;






        rtlglue_drvMutexLock();

        prevValue = rtl8651_drvDropUnknownPppoePADT;

        rtl8651_drvDropUnknownPppoePADT = enable;


        _rtl8651_arrangeAllACL();






        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        rtl8651_setEthernetPortLinkStatus( i, linkup );
                }
        }

        rtlglue_drvMutexUnlock();

        return prevValue;
}





int32 _rtl8651_setExternalInterfaceforPPPoEPassthru( ether_addr_t* gmac, uint16 ExtVid )
{


        rtl8651_gPPPoEExternalVlanIndex = (ExtVid& (8 -1));
        memcpy( &rtl8651_gPPPoEExternalGatewayMAC, gmac, sizeof(ether_addr_t) );

        return 0;
}


int32 rtl8651_getExternalInterfaceforPPPoEPassthru()
{
        if ( rtl8651_l2protoPassThrough & (1<<0) )
                return rtl8651_gPPPoEExternalVlanIndex;
        else
                return 0;
}


int32 _rtl8651_createProtocolBasedVLANforPPPoEPassthru(void)
{
        int i;
        uint32 retval;
        rtl8651_tblDrv_vlanTable_t *vlan;




        if ( rtl8651_gPPPoEExternalVlanIndex == 8 )
        {
                printk( "PPPoE Passthru: External Interface is unknown !!!\n" );
                return -1;
        }

        if ( rtl8651_gPPPoEPassthruVlanID != (4096+1) )
        {
                printk( "PPPoE Passthru already enabled, rtl8651_gPPPoEPassthruVlanID=%d\n", rtl8651_gPPPoEPassthruVlanID );
                return 0;
        }

        retval = _rtl8651_createVlanForPassthru( &rtl8651_gPPPoEExternalGatewayMAC, &rtl8651_gPPPoEPassthruVlanID );
        do {} while (0);


        vlan = &DrvTbl.vlan[(rtl8651_gPPPoEPassthruVlanID& (8 -1))];
        vlan->inAclStart = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].inAclStart;
        vlan->inAclEnd = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].inAclEnd;
        vlan->outAclStart = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].outAclStart;
        vlan->outAclEnd = DrvTbl.vlan[rtl8651_gPPPoEExternalVlanIndex].outAclEnd;
        retval = RTL8651_SETASICVLAN( vlan );
        do {} while (0);
# 28565 "rtl8651_tblDrv.c"
        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        rtl8651_setEthernetPortLinkStatus( i, linkup );
                }
        }

        return 0;
}


int32 _rtl8651_destroyProtocolBasedVLANforPPPoEPassthru(void)
{
        int32 ret, i;

        if ( rtl8651_gPPPoEExternalVlanIndex == 8 )
        {
                printk( "PPPoE Passthru: External Interface is unknown !!!\n" );
                return -1;
        }

        if( rtl8651_gPPPoEPassthruVlanID == (4096+1) )
        {
                printk("rtl8651_gPPPoEExternalVlanIndex is NOT set, but _rtl8651_destroyProtocolBasedVLANforPPPoEPassthru() is called.\n");
                return 0;
        }




        ret = _rtl8651_destroyVlanForPassthru( rtl8651_gPPPoEExternalGatewayMAC, rtl8651_gPPPoEPassthruVlanID );
        do {} while (0);




        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        uint8 valid, vlanIdx;




                        if ( 1 || rtl8651_drvDropUnknownPppoePADT == 0 )
                        {

                                rtl8651_getProtocolBasedVLAN( 3, i, &valid, &vlanIdx );
                                do {} while (0);


                                rtl8651_setProtocolBasedVLAN( 3, i, 0, 0 );
                        }


                        rtl8651_getProtocolBasedVLAN( 4, i, &valid, &vlanIdx );
                        do {} while (0);


                        rtl8651_setProtocolBasedVLAN( 4, i, 0, 0 );
                }
        }

        rtl8651_gPPPoEPassthruVlanID = (4096+1);

        return 0;
}
# 28700 "rtl8651_tblDrv.c"
int8 rtl8651_EnableIpv6Passthru( int8 enable )
{
        int8 prevValue;
        int32 retval;


        rtlglue_drvMutexLock();

        prevValue = rtl8651_l2protoPassThrough&(1<<1)?1:0;

        if ( enable )
                rtl8651_l2protoPassThrough |= (1<<1);
        else
                rtl8651_l2protoPassThrough &= ~(1<<1);



        if ( prevValue == 1 && enable == 0 )
        {

                retval = _rtl8651_destroyProtocolBasedVLANforIPv6Passthru();
        }
        else if ( prevValue == 0 && enable == 1 )
        {

                retval = _rtl8651_createProtocolBasedVLANforIPv6Passthru();
        }
# 28735 "rtl8651_tblDrv.c"
        rtlglue_drvMutexUnlock();

        return prevValue;
}







int32 rtl8651_getIpv6PassthruVid()
{
        int32 retval;

        rtlglue_drvMutexLock();

        if ( rtl8651_l2protoPassThrough & (1<<1) )
                retval = rtl8651_gIPv6PassthruVlanID;
        else
                retval = -1;

        rtlglue_drvMutexUnlock();

        return retval;
}





int32 _rtl8651_setExternalInterfaceforIPv6Passthru( ether_addr_t* gmac, uint16 ExtVid )
{


        rtl8651_gIPv6ExternalVlanIndex = (ExtVid& (8 -1));
        memcpy( &rtl8651_gIPv6ExternalGatewayMAC, gmac, sizeof(ether_addr_t) );

        return 0;
}


int32 rtl8651_getExternalInterfaceforIPv6Passthru()
{
        if ( rtl8651_l2protoPassThrough & (1<<1) )
                return rtl8651_gIPv6ExternalVlanIndex;
        else
                return -1;
}


int32 _rtl8651_createProtocolBasedVLANforIPv6Passthru(void)
{
        int i;
        uint32 retval;
        uint8 ProtocolType;
        uint16 ProtocolValue;



        if( rtl8651_gIPv6ExternalVlanIndex == 8 )
                return -1;

        if ( rtl8651_gIPv6PassthruVlanID != (4096+1) )
                return 0;

        retval = _rtl8651_createVlanForPassthru( &rtl8651_gIPv6ExternalGatewayMAC, &rtl8651_gIPv6PassthruVlanID );
        do {} while (0);




        for( rtl8651_pbv_ipv6passthru = 5;
             rtl8651_pbv_ipv6passthru <= 6;
             rtl8651_pbv_ipv6passthru++ )
        {

                rtl8651_queryProtocolBasedVLAN( rtl8651_pbv_ipv6passthru, &ProtocolType, &ProtocolValue );
                if ( ProtocolType == 0x0 && ProtocolValue == 0x0000 )
                        break;
        }
        do {} while (0);


        rtl8651_defineProtocolBasedVLAN( rtl8651_pbv_ipv6passthru, 0x0, 0x86DD );
# 28828 "rtl8651_tblDrv.c"
        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        rtl8651_setEthernetPortLinkStatus( i, linkup );
                }
        }

        return 0;
}


int32 _rtl8651_destroyProtocolBasedVLANforIPv6Passthru(void)
{
        int32 ret, i;

        if ( rtl8651_gIPv6ExternalVlanIndex == 8 )
                return -1;

        if( rtl8651_gIPv6PassthruVlanID == (4096+1) )
        {

                return 0;
        }




        ret = _rtl8651_destroyVlanForPassthru( rtl8651_gIPv6ExternalGatewayMAC, rtl8651_gIPv6PassthruVlanID );
        do {} while (0);




        (*((volatile uint32 *)((0x090 + (0xBC800000 + 0x00005000))+(rtl8651_pbv_ipv6passthru-5)*4)))=(0x0 << 0 | 0x0000 << 2);




        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        uint8 valid, vlanIdx;


                        rtl8651_getProtocolBasedVLAN( rtl8651_pbv_ipv6passthru, i, &valid, &vlanIdx );
                        do {} while (0);


                        rtl8651_setProtocolBasedVLAN( rtl8651_pbv_ipv6passthru, i, 0, 0 );
                }
        }

        rtl8651_gIPv6PassthruVlanID = (4096+1);
        rtl8651_pbv_ipv6passthru = 7;

        return 0;
}
# 28937 "rtl8651_tblDrv.c"
int8 rtl8651_EnableIpxPassthru( int8 enable )
{
        int8 prevValue;
        int32 retval;

        rtlglue_drvMutexLock();

        prevValue = rtl8651_l2protoPassThrough & (1<<2)?1:0;

        if ( enable )
                rtl8651_l2protoPassThrough |= (1<<2);
        else
                rtl8651_l2protoPassThrough &= ~(1<<2);




        if ( prevValue == 1 && enable == 0 )
        {

                retval = _rtl8651_destroyProtocolBasedVLANforIPXPassthru();
        }
        else if ( prevValue == 0 && enable == 1 )
        {

                retval = _rtl8651_createProtocolBasedVLANforIPXPassthru();
        }



        rtlglue_drvMutexUnlock();

        return prevValue;
}







int32 rtl8651_getIpxPassthruVid()
{
        int32 retval;

        rtlglue_drvMutexLock();

        if ( rtl8651_l2protoPassThrough & (1<<2) )
                retval = rtl8651_gIPXPassthruVlanID;
        else
                retval = -1;

        rtlglue_drvMutexUnlock();

        return retval;
}





int32 _rtl8651_setExternalInterfaceforIPXPassthru( ether_addr_t* gmac, uint16 ExtVid )
{


        rtl8651_gIPXExternalVlanIndex = (ExtVid& (8 -1));
        memcpy( &rtl8651_gIPXExternalGatewayMAC, gmac, sizeof(ether_addr_t) );

        return 0;
}


int32 rtl8651_getExternalInterfaceforIPXPassthru()
{
        if ( rtl8651_l2protoPassThrough & (1<<2) )
                return rtl8651_gIPXExternalVlanIndex;
        else
                return -1;
}


int32 _rtl8651_createProtocolBasedVLANforIPXPassthru(void)
{
        int i;
        uint32 retval;



        if( rtl8651_gIPXExternalVlanIndex == 8 )
                return -1;

        if ( rtl8651_gIPXPassthruVlanID != (4096+1) )
                return 0;

        retval = _rtl8651_createVlanForPassthru( &rtl8651_gIPXExternalGatewayMAC, &rtl8651_gIPXPassthruVlanID );
        do {} while (0);
# 29041 "rtl8651_tblDrv.c"
        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        rtl8651_setEthernetPortLinkStatus( i, linkup );
                }
        }

        return 0;
}


int32 _rtl8651_destroyProtocolBasedVLANforIPXPassthru(void)
{
        int32 ret, i;

        if ( rtl8651_gIPXExternalVlanIndex == 8 )
                return -1;

        if( rtl8651_gIPXPassthruVlanID == (4096+1) )
        {

                return 0;
        }




        ret = _rtl8651_destroyVlanForPassthru( rtl8651_gIPXExternalGatewayMAC, rtl8651_gIPXPassthruVlanID );
        do {} while (0);




        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        uint8 valid, vlanIdx;


                        rtl8651_getProtocolBasedVLAN( rtl8651_pbv_ipxpassthru, i, &valid, &vlanIdx );
                        do {} while (0);


                        rtl8651_setProtocolBasedVLAN( rtl8651_pbv_ipxpassthru, i, 0, 0 );
                }
        }

        rtl8651_gIPXPassthruVlanID = (4096+1);

        return 0;
}
# 29114 "rtl8651_tblDrv.c"
int8 rtl8651_EnableNetbiosPassthru( int8 enable )
{
        int8 prevValue;
        int32 retval;

        rtlglue_drvMutexLock();

        prevValue = rtl8651_l2protoPassThrough&(1<<3)?1:0;

        if ( enable )
                rtl8651_l2protoPassThrough |= (1<<3);
        else
                rtl8651_l2protoPassThrough &= ~(1<<3);




        if ( prevValue == 1 && enable == 0 )
        {

                retval = _rtl8651_destroyProtocolBasedVLANforNetbiosPassthru();
        }
        else if ( prevValue == 0 && enable == 1 )
        {

                retval = _rtl8651_createProtocolBasedVLANforNetbiosPassthru();
        }



        rtlglue_drvMutexUnlock();

        return prevValue;
}







int32 rtl8651_getNetbiosPassthruVid()
{
        int32 retval;

        rtlglue_drvMutexLock();

        if ( rtl8651_l2protoPassThrough & (1<<3) )
                retval = rtl8651_gNetbiosPassthruVlanID;
        else
                retval = -1;

        rtlglue_drvMutexUnlock();

        return retval;
}





int32 _rtl8651_setExternalInterfaceforNetbiosPassthru( ether_addr_t* gmac, uint16 ExtVid )
{


        rtl8651_gNetbiosExternalVlanIndex = (ExtVid& (8 -1));
        memcpy( &rtl8651_gNetbiosExternalGatewayMAC, gmac, sizeof(ether_addr_t) );

        return 0;
}


int32 rtl8651_getExternalInterfaceforNetbiosPassthru()
{
        if ( rtl8651_l2protoPassThrough & (1<<3) )
                return rtl8651_gNetbiosExternalVlanIndex;
        else
                return -1;
}


int32 _rtl8651_createProtocolBasedVLANforNetbiosPassthru(void)
{
        int i;
        uint32 retval;



        if( rtl8651_gNetbiosExternalVlanIndex == 8 )
                return -1;

        if ( rtl8651_gNetbiosPassthruVlanID != (4096+1) )
                return 0;

        retval = _rtl8651_createVlanForPassthru( &rtl8651_gNetbiosExternalGatewayMAC, &rtl8651_gNetbiosPassthruVlanID );
        do {} while (0);
# 29218 "rtl8651_tblDrv.c"
        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        rtl8651_setEthernetPortLinkStatus( i, linkup );
                }
        }

        return 0;
}


int32 _rtl8651_destroyProtocolBasedVLANforNetbiosPassthru(void)
{
        int32 ret, i;

        if ( rtl8651_gNetbiosExternalVlanIndex == 8 )
                return -1;

        if( rtl8651_gNetbiosPassthruVlanID == (4096+1) )
        {

                return 0;
        }




        ret = _rtl8651_destroyVlanForPassthru( rtl8651_gNetbiosExternalGatewayMAC, rtl8651_gNetbiosPassthruVlanID );
        do {} while (0);




        for( i = 0; i < 6 +rtl8651_totalExtPortNum; i++ )
        {
                int8 linkup;

                rtl8651_getEthernetPortLinkStatus( i, &linkup, ((void *)0), ((void *)0), ((void *)0) );

                if ( linkup )
                {
                        uint8 valid, vlanIdx;


                        rtl8651_getProtocolBasedVLAN( rtl8651_pbv_netbiospassthru, i, &valid, &vlanIdx );
                        do {} while (0);


                        rtl8651_setProtocolBasedVLAN( rtl8651_pbv_netbiospassthru, i, 0, 0 );
                }
        }

        rtl8651_gNetbiosPassthruVlanID = (4096+1);

        return 0;
}
# 29292 "rtl8651_tblDrv.c"
uint8 rtl8651_EnableProtocolBasedNAT( uint8 enable )
{
        uint8 prevValue;

        rtlglue_drvMutexLock();
        prevValue = rtl8651_drvProtocolBasedNatEnable;
        rtl8651_drvProtocolBasedNatEnable = enable;
        rtlglue_drvMutexUnlock();

        return prevValue;
}
# 29313 "rtl8651_tblDrv.c"
int32 _rtl8651_addProtocolBasedNAT( uint8 protocol, ipaddr_t ExtIp, ipaddr_t IntIp )
{
        rtl8651_tblDrv_protocolBasedNat_t *pbNat;


        switch( protocol )
        {
                case 1:
                case 2:
                case 6:
                case 17:
                case 47:
                        return -3304;
        }


        for( pbNat = ((&DrvTbl.inuseList.protocolBasedNat)->slh_first);
             pbNat != ((void *)0);
             pbNat = ((pbNat)->next.sle_next) )
        {
                if ( pbNat->protocol == protocol &&
                     pbNat->ExtIp == ExtIp )
                {

                        break;
                }
        }

        if ( pbNat != ((void *)0) )
        {
                return -3301;
        }
        else
        {

                pbNat = ((&DrvTbl.freeList.protocolBasedNat)->slh_first);


                if ( pbNat == ((void *)0) )
                        return -3302;

                pbNat->protocol = protocol;
                pbNat->ExtIp = ExtIp;
                pbNat->IntIp = IntIp;


                do { (&DrvTbl.freeList.protocolBasedNat)->slh_first = (&DrvTbl.freeList.protocolBasedNat)->slh_first->next.sle_next; } while (0);
                do { (pbNat)->next.sle_next = (&DrvTbl.inuseList.protocolBasedNat)->slh_first; (&DrvTbl.inuseList.protocolBasedNat)->slh_first = (pbNat); } while (0);


        }

        return 0;
}


int32 rtl8651_addProtocolBasedNAT( uint8 protocol, ipaddr_t ExtIp, ipaddr_t IntIp )
{
        int32 retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_addProtocolBasedNAT( protocol, ExtIp, IntIp );
        rtlglue_drvMutexUnlock();

        return retval;
}
# 29389 "rtl8651_tblDrv.c"
int32 _rtl8651_delProtocolBasedNAT( uint8 protocol, ipaddr_t ExtIp, ipaddr_t IntIp )
{
        rtl8651_tblDrv_protocolBasedNat_t *pbNat;


        for( pbNat = ((&DrvTbl.inuseList.protocolBasedNat)->slh_first);
             pbNat != ((void *)0);
             pbNat = ((pbNat)->next.sle_next) )
        {
                if ( pbNat->protocol == protocol &&
                     pbNat->ExtIp == ExtIp &&
                     pbNat->IntIp == IntIp )
                {

                        break;
                }
        }

        if ( pbNat == ((void *)0) )
        {
                return -3303;
        }

        memset( pbNat, 0, ((size_t) &((struct rtl8651_tblDrv_protocolBasedNat_s *)0)->next) );


        do { if ((&DrvTbl.inuseList.protocolBasedNat)->slh_first == (pbNat)) { do { ((&DrvTbl.inuseList.protocolBasedNat))->slh_first = ((&DrvTbl.inuseList.protocolBasedNat))->slh_first->next.sle_next; } while (0); } else { struct rtl8651_tblDrv_protocolBasedNat_s *curelm = (&DrvTbl.inuseList.protocolBasedNat)->slh_first; while( curelm->next.sle_next != (pbNat) ) curelm = curelm->next.sle_next; curelm->next.sle_next = curelm->next.sle_next->next.sle_next; } } while (0);
        do { (pbNat)->next.sle_next = (&DrvTbl.freeList.protocolBasedNat)->slh_first; (&DrvTbl.freeList.protocolBasedNat)->slh_first = (pbNat); } while (0);

        return 0;
}


int32 rtl8651_delProtocolBasedNAT( uint8 protocol, ipaddr_t ExtIp, ipaddr_t IntIp )
{
        int32 retval;

        rtlglue_drvMutexLock();
        retval = _rtl8651_delProtocolBasedNAT( protocol, ExtIp, IntIp );
        rtlglue_drvMutexUnlock();

        return retval;
}
# 29442 "rtl8651_tblDrv.c"
int32 _rtl8651_getInboundProtocolBasedNAT( uint8 protocol, ipaddr_t ExtIp, ipaddr_t *IntIp )
{
        rtl8651_tblDrv_protocolBasedNat_t *pbNat;


        for( pbNat = ((&DrvTbl.inuseList.protocolBasedNat)->slh_first);
             pbNat != ((void *)0);
             pbNat = ((pbNat)->next.sle_next) )
        {
                if ( pbNat->protocol == protocol &&
                     pbNat->ExtIp == ExtIp )
                {

                        break;
                }
        }

        if ( pbNat == ((void *)0) )
        {
                return -3303;
        }

        if ( IntIp ) *IntIp = pbNat->IntIp;

        return 0;
}
# 29478 "rtl8651_tblDrv.c"
int32 _rtl8651_getOutboundProtocolBasedNAT( uint8 protocol, ipaddr_t *ExtIp, ipaddr_t IntIp )
{
        rtl8651_tblDrv_protocolBasedNat_t *pbNat;


        for( pbNat = ((&DrvTbl.inuseList.protocolBasedNat)->slh_first);
             pbNat != ((void *)0);
             pbNat = ((pbNat)->next.sle_next) )
        {
                if ( pbNat->protocol == protocol &&
                     pbNat->IntIp == IntIp )
                {

                        break;
                }
        }

        if ( pbNat == ((void *)0) )
        {
                return -3303;
        }

        if ( ExtIp ) *ExtIp = pbNat->ExtIp;

        return 0;
}
# 29523 "rtl8651_tblDrv.c"
int32 rtl8651_autoCrossOverDetect(uint32 isEnable)
{
        uint32 port;
        int32 retval;
        for(port=0; port<6 -1; port++) {
                retval = rtl8651_autoMdiMdix(port, isEnable);
                if (retval != 0)
                        return -1;
        }
        return 0;
}
# 29543 "rtl8651_tblDrv.c"
int32 rtl8651_portAutoCrossOverDetect(uint32 port, uint32 isEnable)
{
        return rtl8651_autoMdiMdix(port, isEnable);
}


int32 rtl8651_setMdiMdix(uint32 isMdi)
{
        uint32 port;
        int32 retval;
        for(port=0; port<6 -1; port++) {
                retval = rtl8651_selectMdiMdix(port, isMdi);
                if (retval != 0)
                        return -1;
        }
        return 0;
}


int32 rtl8651_setPortMdiMdix(uint32 port, uint32 isMdi)
{
        return rtl8651_selectMdiMdix(port, isMdi);
}
# 29593 "rtl8651_tblDrv.c"
rtl8651_ACLDB_t acldb[125];




int32 _rtl8651_initACLDB(void)
{
        int i;

        for( i = 0; i < 125; i++ )
        {
                acldb[i].func = ((void *)0);
                acldb[i].userDefined = ((void *)0);
        }

        return 0;
}




int32 _rtl8651_registerACLDB( int32 ruleNo,
                             acldb_callback_t func,
                             void *userDefined )
{


        acldb[ruleNo].func = func;
        acldb[ruleNo].userDefined = userDefined;

        return 0;
}




inline int32 _rtl8651_jumptoACLDB( int32 ruleNo, struct rtl_pktHdr *pkthdr, struct ip *pip )
{
        int32 retval = -1;



        if ( acldb[ruleNo].func )
        {
                acldb[ruleNo].count++;
                retval = (*acldb[ruleNo].func)( ruleNo, pkthdr, pip, acldb[ruleNo].userDefined );
        }

        return retval;
}
